// Generated by astgen at 2025-07-05T14:30:01.254948676+00:00[UTC]
//
// See `astgen/src/main.rs` and `astgen/src/runtime.rs`

use super::{AssignOp, Ast, FloatId, IdentId, InfixOp, PrefixOp, StrId};
use crate::span::{Span, Spanned};

mod private {
    pub trait Sealed {}
}
use private::Sealed;

use std::marker::PhantomData;

trait DebugWithAstExt {
    fn debug(self, ast: &Ast) -> impl std::fmt::Debug + '_;
}

impl DebugWithAstExt for f32 {
    fn debug(self, _: &Ast) -> impl std::fmt::Debug + '_ {
        self
    }
}

impl DebugWithAstExt for bool {
    fn debug(self, _: &Ast) -> impl std::fmt::Debug + '_ {
        self
    }
}

#[allow(non_camel_case_types)]
#[derive(Clone, Copy, Hash)]
#[repr(packed)]
pub struct u24([u8; 3]);

impl u24 {
    pub const MAX: u24 = u24([255; 3]);
    pub const MIN: u24 = u24([0; 3]);
    pub const ZERO: u24 = u24([0; 3]);

    #[inline]
    pub const fn new(v: u32) -> Self {
        if v > Self::MAX.get() {
            panic!("value is out of bounds for u24");
        }

        unsafe { Self::new_unchecked(v) }
    }

    #[inline]
    pub const unsafe fn new_unchecked(v: u32) -> Self {
        let [a, b, c, _] = v.to_le_bytes();
        Self([a, b, c])
    }

    #[inline]
    pub const fn get(self) -> u32 {
        let [a, b, c] = self.0;
        u32::from_le_bytes([a, b, c, 0])
    }
}

impl PartialEq for u24 {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        PartialEq::eq(&self.get(), &other.get())
    }
}

impl Eq for u24 {}

impl PartialOrd for u24 {
    #[inline]
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        PartialOrd::partial_cmp(&self.get(), &other.get())
    }
}

impl Ord for u24 {
    #[inline]
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        Ord::cmp(&self.get(), &other.get())
    }
}

impl std::fmt::Debug for u24 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        <u32 as std::fmt::Debug>::fmt(&self.get(), f)
    }
}

impl u24 {
    pub fn debug(self, _: &Ast) -> impl std::fmt::Debug + '_ {
        self
    }
}

#[allow(non_camel_case_types)]
#[derive(Clone, Copy, Hash)]
#[repr(packed)]
pub struct u56([u8; 7]);

impl u56 {
    pub const MAX: u56 = u56([255; 7]);
    pub const MIN: u56 = u56([0; 7]);
    pub const ZERO: u56 = u56([0; 7]);

    #[inline]
    pub const fn new(v: u64) -> Self {
        if v > Self::MAX.get() {
            panic!("value is out of bounds for u56");
        }

        unsafe { Self::new_unchecked(v) }
    }

    #[inline]
    pub const unsafe fn new_unchecked(v: u64) -> Self {
        let [a, b, c, d, e, f, g, _] = v.to_le_bytes();
        Self([a, b, c, d, e, f, g])
    }

    #[inline]
    pub const fn get(self) -> u64 {
        let [a, b, c, d, e, f, g] = self.0;
        u64::from_le_bytes([a, b, c, d, e, f, g, 0])
    }

    fn from_u56(v: u56) -> Self {
        v
    }

    fn into_u56(self) -> u56 {
        self
    }
}

impl PartialEq for u56 {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        PartialEq::eq(&self.get(), &other.get())
    }
}

impl Eq for u56 {}

impl PartialOrd for u56 {
    #[inline]
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        PartialOrd::partial_cmp(&self.get(), &other.get())
    }
}

impl Ord for u56 {
    #[inline]
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        Ord::cmp(&self.get(), &other.get())
    }
}

impl std::fmt::Debug for u56 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        <u64 as std::fmt::Debug>::fmt(&self.get(), f)
    }
}

impl u56 {
    pub fn debug(self, _: &Ast) -> impl std::fmt::Debug + '_ {
        self
    }
}

trait IntoU56 {
    fn into_u56(self) -> u56;
}

trait FromU56 {
    fn from_u56(v: u56) -> Self;
}

impl IntoU56 for bool {
    fn into_u56(self) -> u56 {
        unsafe { u56::new_unchecked(self as u64) }
    }
}

impl FromU56 for bool {
    #[allow(unnecessary_transmutes)]
    fn from_u56(v: u56) -> Self {
        unsafe { core::mem::transmute(v.get() as u8) }
    }
}

impl IntoU56 for f32 {
    fn into_u56(self) -> u56 {
        unsafe { u56::new_unchecked(self.to_bits() as u64) }
    }
}

impl FromU56 for f32 {
    fn from_u56(v: u56) -> Self {
        f32::from_bits(v.get() as u32)
    }
}

#[derive(Clone, Copy)]
#[repr(C)]
pub struct Packed {
    repr: PackedRepr,
    #[cfg(debug_assertions)]
    debug_tag: DebugPackedReprTag,
}

impl Packed {
    fn copy(&self) -> Self {
        unsafe { (self as *const Self).read() }
    }

    #[inline]
    pub fn kind(&self) -> NodeKind {
        // SAFETY: `kind` is present in every union variant
        let kind = unsafe { self.repr.kind_only.kind.get() };
        debug_assert!(NodeKind::all().iter().map(|(_, v)| *v).any(|v| v == kind));

        // SAFETY: All writes of `kind` are in this file, and we know
        // that what's written is always a valid bitpattern of `NodeKind`.
        unsafe { core::mem::transmute(kind) }
    }

    #[inline]
    fn kind_only(kind: NodeKind) -> Self {
        Self {
            repr: PackedRepr {
                kind_only: KindOnly {
                    kind: unsafe { core::num::NonZero::new_unchecked(kind as u8) },
                    _padding: u56::ZERO,
                },
            },
            debug_tag: DebugPackedReprTag::KindOnly,
        }
    }

    #[inline]
    fn fixed_arity(kind: NodeKind, index: u32) -> Self {
        Self {
            repr: PackedRepr {
                fixed_arity: FixedArity {
                    kind: unsafe { core::num::NonZero::new_unchecked(kind as u8) },
                    _padding: u24::ZERO,
                    index,
                },
            },
            debug_tag: DebugPackedReprTag::FixedArity,
        }
    }

    #[inline]
    fn fixed_arity_inline(kind: NodeKind, value: u24, index: u32) -> Self {
        Self {
            repr: PackedRepr {
                fixed_arity_inline: FixedArity_Inline {
                    kind: unsafe { core::num::NonZero::new_unchecked(kind as u8) },
                    value,
                    index,
                },
            },
            debug_tag: DebugPackedReprTag::FixedArity_Inline,
        }
    }

    #[inline]
    fn variable_arity(kind: NodeKind, length: u24, index: u32) -> Self {
        Self {
            repr: PackedRepr {
                variable_arity: VariableArity {
                    kind: unsafe { core::num::NonZero::new_unchecked(kind as u8) },
                    length,
                    index,
                },
            },
            debug_tag: DebugPackedReprTag::VariableArity,
        }
    }

    #[inline]
    fn mixed_arity(kind: NodeKind, length: u24, index: u32) -> Self {
        Self {
            repr: PackedRepr {
                mixed_arity: MixedArity {
                    kind: unsafe { core::num::NonZero::new_unchecked(kind as u8) },
                    tail_length: length,
                    index,
                },
            },
            debug_tag: DebugPackedReprTag::MixedArity,
        }
    }

    #[inline]
    fn inline(kind: NodeKind, value: u56) -> Self {
        Self {
            repr: PackedRepr {
                inline: Inline {
                    kind: unsafe { core::num::NonZero::new_unchecked(kind as u8) },
                    value,
                },
            },
            debug_tag: DebugPackedReprTag::Inline,
        }
    }

    #[inline]
    unsafe fn as_kind_only(&self) -> &KindOnly {
        debug_assert!(self.debug_tag == DebugPackedReprTag::KindOnly);
        unsafe { &self.repr.kind_only }
    }

    #[inline]
    unsafe fn as_fixed_arity(&self) -> &FixedArity {
        debug_assert!(self.debug_tag == DebugPackedReprTag::FixedArity);
        unsafe { &self.repr.fixed_arity }
    }

    #[inline]
    unsafe fn as_fixed_arity_inline(&self) -> &FixedArity_Inline {
        debug_assert!(self.debug_tag == DebugPackedReprTag::FixedArity_Inline);
        unsafe { &self.repr.fixed_arity_inline }
    }

    #[inline]
    unsafe fn as_variable_arity(&self) -> &VariableArity {
        debug_assert!(self.debug_tag == DebugPackedReprTag::VariableArity);
        unsafe { &self.repr.variable_arity }
    }

    #[inline]
    unsafe fn as_mixed_arity(&self) -> &MixedArity {
        debug_assert!(self.debug_tag == DebugPackedReprTag::MixedArity);
        unsafe { &self.repr.mixed_arity }
    }

    #[inline]
    unsafe fn as_inline(&self) -> &Inline {
        debug_assert!(self.debug_tag == DebugPackedReprTag::Inline);
        unsafe { &self.repr.inline }
    }
}

const _: () = {
    let _ = core::mem::transmute::<Option<Packed>, Packed>;
};

#[allow(non_camel_case_types)]
#[cfg(debug_assertions)]
#[derive(Debug, Clone, Copy, PartialEq)]
enum DebugPackedReprTag {
    KindOnly,
    FixedArity,
    FixedArity_Inline,
    VariableArity,
    MixedArity,
    Inline,
}

#[derive(Clone, Copy)]
union PackedRepr {
    kind_only: KindOnly,
    fixed_arity: FixedArity,
    fixed_arity_inline: FixedArity_Inline,
    variable_arity: VariableArity,
    mixed_arity: MixedArity,
    inline: Inline,
}

type RawKind = core::num::NonZero<u8>;

#[derive(Clone, Copy)]
#[repr(C)]
struct KindOnly {
    kind: RawKind,
    _padding: u56,
}

#[derive(Clone, Copy)]
#[repr(C)]
struct FixedArity {
    kind: RawKind,
    _padding: u24,
    index: u32,
}

#[allow(non_camel_case_types)]
#[derive(Clone, Copy)]
#[repr(C)]
struct FixedArity_Inline {
    kind: RawKind,
    value: u24,
    index: u32,
}

#[derive(Clone, Copy)]
#[repr(C)]
struct VariableArity {
    kind: RawKind,
    length: u24,
    index: u32,
}

#[derive(Clone, Copy)]
#[repr(C)]
struct MixedArity {
    kind: RawKind,
    tail_length: u24,
    index: u32,
}

#[derive(Clone, Copy)]
#[repr(C)]
struct Inline {
    kind: RawKind,
    value: u56,
}

/// Marker for types which are transparent wrappers over [`Packed`].
pub unsafe trait PackedAbi: Sealed + Sized {
    /// Check if `kind` matches `Self`'s kind.
    fn check_kind(kind: NodeKind) -> bool;
}

/// Conversion traits to/from [`Packed`].
pub trait PackedNode: PackedAbi {
    /// SAFETY:
    /// - `Self` must be a transparent wrapper over `Packed`.
    /// - `v` must have the same kind as `Self`.
    unsafe fn from_packed(v: &Packed) -> &Self;

    fn into_packed(v: &Self) -> &Packed;

    /// SAFETY:
    /// - All nodes in `v` must have the same kind as `Self`.
    /// - `Self` must be a transparent wrapper over `Packed`.
    unsafe fn from_packed_slice(v: &[Packed]) -> &[Self];

    fn into_packed_slice(v: &[Self]) -> &[Packed];

    /// SAFETY:
    /// - `Self` must be a transparent wrapper over `Packed`.
    /// - `Spanned` is a repr(C) struct, meaning it has the
    ///   same layout for the same `T`.
    unsafe fn from_spanned_packed(v: Spanned<Packed>) -> Spanned<Self>;

    fn into_spanned_packed(v: Spanned<Self>) -> Spanned<Packed>;

    /// SAFETY:
    /// - `Self` must be a transparent wrapper over `Packed`.
    /// - All nodes in `v` must have the same kind as `Self`.
    /// - `Spanned` is a repr(C) struct, meaning it has the
    ///   same layout for the same `T`.
    unsafe fn from_spanned_packed_slice(v: &[Spanned<Packed>]) -> &[Spanned<Self>];

    fn into_spanned_packed_slice(v: &[Spanned<Self>]) -> &[Spanned<Packed>];
}

impl<T: PackedAbi> PackedNode for T {
    unsafe fn from_packed(v: &Packed) -> &Self {
        debug_assert!(T::check_kind(v.kind()));
        unsafe { core::mem::transmute(v) }
    }

    fn into_packed(v: &Self) -> &Packed {
        unsafe { core::mem::transmute(v) }
    }

    unsafe fn from_packed_slice(v: &[Packed]) -> &[Self] {
        debug_assert!(v.iter().all(|v| T::check_kind(v.kind())));
        unsafe { core::mem::transmute(v) }
    }

    fn into_packed_slice(v: &[Self]) -> &[Packed] {
        unsafe { core::mem::transmute(v) }
    }

    unsafe fn from_spanned_packed(v: Spanned<Packed>) -> Spanned<Self> {
        debug_assert!(T::check_kind(v.kind()));
        unsafe { core::mem::transmute_copy(&v) }
    }

    fn into_spanned_packed(v: Spanned<Self>) -> Spanned<Packed> {
        unsafe { core::mem::transmute_copy(&v) }
    }

    unsafe fn from_spanned_packed_slice(v: &[Spanned<Packed>]) -> &[Spanned<Self>] {
        debug_assert!(v.iter().all(|v| T::check_kind(v.kind())));
        unsafe { core::mem::transmute(v) }
    }

    fn into_spanned_packed_slice(v: &[Spanned<Self>]) -> &[Spanned<Packed>] {
        unsafe { core::mem::transmute(v) }
    }
}

#[derive(Clone, Copy, Debug)]
pub struct NodeCastError;
impl std::fmt::Display for NodeCastError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "invalid cast between node types")
    }
}
impl std::error::Error for NodeCastError {}

pub trait Pack {
    type Node;

    fn pack(self, ast: &mut Ast) -> Self::Node;
}

pub struct Node<'a, T: PackedAbi> {
    pub(super) ast: &'a Ast,
    pub(super) node: &'a T,
}

impl<'a, T: PackedAbi> std::ops::Deref for Node<'a, T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        self.node
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Opt<T>(Packed, PhantomData<T>);

impl<T: Sealed> Sealed for Opt<T> {}
/// SAFETY: `Opt` is a transparent wrapper over `Packed`.
unsafe impl<T: PackedAbi> PackedAbi for Opt<T> {
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::None || T::check_kind(kind)
    }
}

impl<T: PackedAbi> Opt<T> {
    #[inline]
    pub fn some(v: T) -> Self {
        Self(unsafe { core::mem::transmute_copy(&v) }, PhantomData)
    }

    #[inline]
    pub fn none() -> Self {
        Self(Packed::kind_only(NodeKind::None), PhantomData)
    }

    #[inline]
    pub fn is_some(&self) -> bool {
        !self.is_none()
    }

    #[inline]
    pub fn is_none(&self) -> bool {
        matches!(self.0.kind(), NodeKind::None)
    }

    #[inline]
    pub fn unwrap(&self) -> &T {
        if self.is_none() {
            panic!("unwrapped an Opt::None value");
        }
        unsafe { T::from_packed(&self.0) }
    }

    #[inline]
    pub unsafe fn unwrap_unchecked(&self) -> &T {
        debug_assert!(self.is_some());
        unsafe { T::from_packed(&self.0) }
    }

    #[inline]
    pub fn as_option(&self) -> Option<&T> {
        match self.is_some() {
            true => Some(unsafe { self.unwrap_unchecked() }),
            false => None,
        }
    }
}

struct DebugIter<T>(T);

impl<T: Clone + Iterator<Item = I>, I: std::fmt::Debug> std::fmt::Debug for DebugIter<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_list().entries(self.0.clone()).finish()
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u8)]
pub enum NodeKind {
    Root = 1,
    Var = 2,
    Loop = 3,
    StmtExpr = 4,
    FuncDecl = 5,
    Return = 6,
    Break = 7,
    Continue = 8,
    IfSimple = 9,
    IfMulti = 10,
    Block = 11,
    FuncAnon = 12,
    GetVar = 13,
    SetVar = 14,
    GetField = 15,
    SetField = 16,
    GetIndex = 17,
    SetIndex = 18,
    Call = 19,
    CallObject = 20,
    Infix = 21,
    Prefix = 22,
    Array = 23,
    Object = 24,
    Int = 25,
    Float32 = 26,
    Float64 = 27,
    Bool = 28,
    Str = 29,
    Nil = 30,
    Branch = 31,
    ObjectEntry = 32,
    Ident = 33,
    None = 255,
}

impl NodeKind {
    const fn all() -> &'static [(&'static str, u8)] {
        &[
            ("Root", 1),
            ("Var", 2),
            ("Loop", 3),
            ("StmtExpr", 4),
            ("FuncDecl", 5),
            ("Return", 6),
            ("Break", 7),
            ("Continue", 8),
            ("IfSimple", 9),
            ("IfMulti", 10),
            ("Block", 11),
            ("FuncAnon", 12),
            ("GetVar", 13),
            ("SetVar", 14),
            ("GetField", 15),
            ("SetField", 16),
            ("GetIndex", 17),
            ("SetIndex", 18),
            ("Call", 19),
            ("CallObject", 20),
            ("Infix", 21),
            ("Prefix", 22),
            ("Array", 23),
            ("Object", 24),
            ("Int", 25),
            ("Float32", 26),
            ("Float64", 27),
            ("Bool", 28),
            ("Str", 29),
            ("Nil", 30),
            ("Branch", 31),
            ("ObjectEntry", 32),
            ("Ident", 33),
            ("None", 255),
        ]
    }
}

#[repr(u8)]
pub enum StmtKind<'a> {
    Var(&'a Var) = NodeKind::Var as u8,
    Loop(&'a Loop) = NodeKind::Loop as u8,
    StmtExpr(&'a StmtExpr) = NodeKind::StmtExpr as u8,
    FuncDecl(&'a FuncDecl) = NodeKind::FuncDecl as u8,
}

impl Stmt {
    #[inline]
    pub fn kind(&self) -> StmtKind {
        match self.0.kind() {
            NodeKind::Var => StmtKind::Var(unsafe { Var::from_packed(&self.0) }),
            NodeKind::Loop => StmtKind::Loop(unsafe { Loop::from_packed(&self.0) }),
            NodeKind::StmtExpr => StmtKind::StmtExpr(unsafe { StmtExpr::from_packed(&self.0) }),
            NodeKind::FuncDecl => StmtKind::FuncDecl(unsafe { FuncDecl::from_packed(&self.0) }),
            // SAFETY: guaranteed to be a valid `Stmt`
            _ => unsafe { std::hint::unreachable_unchecked() },
        }
    }
}
#[repr(u8)]
pub enum ExprKind<'a> {
    Return(&'a Return) = NodeKind::Return as u8,
    Break(&'a Break) = NodeKind::Break as u8,
    Continue(&'a Continue) = NodeKind::Continue as u8,
    IfSimple(&'a IfSimple) = NodeKind::IfSimple as u8,
    IfMulti(&'a IfMulti) = NodeKind::IfMulti as u8,
    Block(&'a Block) = NodeKind::Block as u8,
    FuncAnon(&'a FuncAnon) = NodeKind::FuncAnon as u8,
    GetVar(&'a GetVar) = NodeKind::GetVar as u8,
    SetVar(&'a SetVar) = NodeKind::SetVar as u8,
    GetField(&'a GetField) = NodeKind::GetField as u8,
    SetField(&'a SetField) = NodeKind::SetField as u8,
    GetIndex(&'a GetIndex) = NodeKind::GetIndex as u8,
    SetIndex(&'a SetIndex) = NodeKind::SetIndex as u8,
    Call(&'a Call) = NodeKind::Call as u8,
    CallObject(&'a CallObject) = NodeKind::CallObject as u8,
    Infix(&'a Infix) = NodeKind::Infix as u8,
    Prefix(&'a Prefix) = NodeKind::Prefix as u8,
    Array(&'a Array) = NodeKind::Array as u8,
    Object(&'a Object) = NodeKind::Object as u8,
    Int(&'a Int) = NodeKind::Int as u8,
    Float32(&'a Float32) = NodeKind::Float32 as u8,
    Float64(&'a Float64) = NodeKind::Float64 as u8,
    Bool(&'a Bool) = NodeKind::Bool as u8,
    Str(&'a Str) = NodeKind::Str as u8,
    Nil(&'a Nil) = NodeKind::Nil as u8,
}

impl Expr {
    #[inline]
    pub fn kind(&self) -> ExprKind {
        match self.0.kind() {
            NodeKind::Return => ExprKind::Return(unsafe { Return::from_packed(&self.0) }),
            NodeKind::Break => ExprKind::Break(unsafe { Break::from_packed(&self.0) }),
            NodeKind::Continue => ExprKind::Continue(unsafe { Continue::from_packed(&self.0) }),
            NodeKind::IfSimple => ExprKind::IfSimple(unsafe { IfSimple::from_packed(&self.0) }),
            NodeKind::IfMulti => ExprKind::IfMulti(unsafe { IfMulti::from_packed(&self.0) }),
            NodeKind::Block => ExprKind::Block(unsafe { Block::from_packed(&self.0) }),
            NodeKind::FuncAnon => ExprKind::FuncAnon(unsafe { FuncAnon::from_packed(&self.0) }),
            NodeKind::GetVar => ExprKind::GetVar(unsafe { GetVar::from_packed(&self.0) }),
            NodeKind::SetVar => ExprKind::SetVar(unsafe { SetVar::from_packed(&self.0) }),
            NodeKind::GetField => ExprKind::GetField(unsafe { GetField::from_packed(&self.0) }),
            NodeKind::SetField => ExprKind::SetField(unsafe { SetField::from_packed(&self.0) }),
            NodeKind::GetIndex => ExprKind::GetIndex(unsafe { GetIndex::from_packed(&self.0) }),
            NodeKind::SetIndex => ExprKind::SetIndex(unsafe { SetIndex::from_packed(&self.0) }),
            NodeKind::Call => ExprKind::Call(unsafe { Call::from_packed(&self.0) }),
            NodeKind::CallObject => {
                ExprKind::CallObject(unsafe { CallObject::from_packed(&self.0) })
            }
            NodeKind::Infix => ExprKind::Infix(unsafe { Infix::from_packed(&self.0) }),
            NodeKind::Prefix => ExprKind::Prefix(unsafe { Prefix::from_packed(&self.0) }),
            NodeKind::Array => ExprKind::Array(unsafe { Array::from_packed(&self.0) }),
            NodeKind::Object => ExprKind::Object(unsafe { Object::from_packed(&self.0) }),
            NodeKind::Int => ExprKind::Int(unsafe { Int::from_packed(&self.0) }),
            NodeKind::Float32 => ExprKind::Float32(unsafe { Float32::from_packed(&self.0) }),
            NodeKind::Float64 => ExprKind::Float64(unsafe { Float64::from_packed(&self.0) }),
            NodeKind::Bool => ExprKind::Bool(unsafe { Bool::from_packed(&self.0) }),
            NodeKind::Str => ExprKind::Str(unsafe { Str::from_packed(&self.0) }),
            NodeKind::Nil => ExprKind::Nil(unsafe { Nil::from_packed(&self.0) }),
            // SAFETY: guaranteed to be a valid `Stmt`
            _ => unsafe { std::hint::unreachable_unchecked() },
        }
    }
}
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Stmt(Packed);

impl Sealed for Stmt {}

impl From<Stmt> for Packed {
    #[inline]
    fn from(v: Stmt) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Expr(Packed);

impl Sealed for Expr {}

impl From<Expr> for Packed {
    #[inline]
    fn from(v: Expr) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Root(Packed);

impl Sealed for Root {}

impl From<Root> for Packed {
    #[inline]
    fn from(v: Root) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Var(Packed);

impl Sealed for Var {}

impl From<Var> for Packed {
    #[inline]
    fn from(v: Var) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Loop(Packed);

impl Sealed for Loop {}

impl From<Loop> for Packed {
    #[inline]
    fn from(v: Loop) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct StmtExpr(Packed);

impl Sealed for StmtExpr {}

impl From<StmtExpr> for Packed {
    #[inline]
    fn from(v: StmtExpr) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct FuncDecl(Packed);

impl Sealed for FuncDecl {}

impl From<FuncDecl> for Packed {
    #[inline]
    fn from(v: FuncDecl) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Return(Packed);

impl Sealed for Return {}

impl From<Return> for Packed {
    #[inline]
    fn from(v: Return) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Break(Packed);

impl Sealed for Break {}

impl From<Break> for Packed {
    #[inline]
    fn from(v: Break) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Continue(Packed);

impl Sealed for Continue {}

impl From<Continue> for Packed {
    #[inline]
    fn from(v: Continue) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct IfSimple(Packed);

impl Sealed for IfSimple {}

impl From<IfSimple> for Packed {
    #[inline]
    fn from(v: IfSimple) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct IfMulti(Packed);

impl Sealed for IfMulti {}

impl From<IfMulti> for Packed {
    #[inline]
    fn from(v: IfMulti) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Block(Packed);

impl Sealed for Block {}

impl From<Block> for Packed {
    #[inline]
    fn from(v: Block) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct FuncAnon(Packed);

impl Sealed for FuncAnon {}

impl From<FuncAnon> for Packed {
    #[inline]
    fn from(v: FuncAnon) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct GetVar(Packed);

impl Sealed for GetVar {}

impl From<GetVar> for Packed {
    #[inline]
    fn from(v: GetVar) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct SetVar(Packed);

impl Sealed for SetVar {}

impl From<SetVar> for Packed {
    #[inline]
    fn from(v: SetVar) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct GetField(Packed);

impl Sealed for GetField {}

impl From<GetField> for Packed {
    #[inline]
    fn from(v: GetField) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct SetField(Packed);

impl Sealed for SetField {}

impl From<SetField> for Packed {
    #[inline]
    fn from(v: SetField) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct GetIndex(Packed);

impl Sealed for GetIndex {}

impl From<GetIndex> for Packed {
    #[inline]
    fn from(v: GetIndex) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct SetIndex(Packed);

impl Sealed for SetIndex {}

impl From<SetIndex> for Packed {
    #[inline]
    fn from(v: SetIndex) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Call(Packed);

impl Sealed for Call {}

impl From<Call> for Packed {
    #[inline]
    fn from(v: Call) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct CallObject(Packed);

impl Sealed for CallObject {}

impl From<CallObject> for Packed {
    #[inline]
    fn from(v: CallObject) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Infix(Packed);

impl Sealed for Infix {}

impl From<Infix> for Packed {
    #[inline]
    fn from(v: Infix) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Prefix(Packed);

impl Sealed for Prefix {}

impl From<Prefix> for Packed {
    #[inline]
    fn from(v: Prefix) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Array(Packed);

impl Sealed for Array {}

impl From<Array> for Packed {
    #[inline]
    fn from(v: Array) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Object(Packed);

impl Sealed for Object {}

impl From<Object> for Packed {
    #[inline]
    fn from(v: Object) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Int(Packed);

impl Sealed for Int {}

impl From<Int> for Packed {
    #[inline]
    fn from(v: Int) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Float32(Packed);

impl Sealed for Float32 {}

impl From<Float32> for Packed {
    #[inline]
    fn from(v: Float32) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Float64(Packed);

impl Sealed for Float64 {}

impl From<Float64> for Packed {
    #[inline]
    fn from(v: Float64) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Bool(Packed);

impl Sealed for Bool {}

impl From<Bool> for Packed {
    #[inline]
    fn from(v: Bool) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Str(Packed);

impl Sealed for Str {}

impl From<Str> for Packed {
    #[inline]
    fn from(v: Str) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Nil(Packed);

impl Sealed for Nil {}

impl From<Nil> for Packed {
    #[inline]
    fn from(v: Nil) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Branch(Packed);

impl Sealed for Branch {}

impl From<Branch> for Packed {
    #[inline]
    fn from(v: Branch) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct ObjectEntry(Packed);

impl Sealed for ObjectEntry {}

impl From<ObjectEntry> for Packed {
    #[inline]
    fn from(v: ObjectEntry) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Ident(Packed);

impl Sealed for Ident {}

impl From<Ident> for Packed {
    #[inline]
    fn from(v: Ident) -> Self {
        v.0
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Stmt {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind >= NodeKind::Var && kind <= NodeKind::FuncDecl
    }
}

impl TryFrom<Packed> for Stmt {
    type Error = ();

    #[inline]
    fn try_from(v: Packed) -> Result<Self, Self::Error> {
        if <Self as PackedAbi>::check_kind(v.kind()) {
            Ok(Self(v))
        } else {
            Err(())
        }
    }
}
/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Expr {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind >= NodeKind::Return && kind <= NodeKind::Nil
    }
}

impl TryFrom<Packed> for Expr {
    type Error = ();

    #[inline]
    fn try_from(v: Packed) -> Result<Self, Self::Error> {
        if <Self as PackedAbi>::check_kind(v.kind()) {
            Ok(Self(v))
        } else {
            Err(())
        }
    }
}
impl TryFrom<Packed> for Root {
    type Error = ();

    #[inline]
    fn try_from(v: Packed) -> Result<Self, Self::Error> {
        if <Self as PackedAbi>::check_kind(v.kind()) {
            Ok(Self(v))
        } else {
            Err(())
        }
    }
}
/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Root {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Root
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Var {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Var
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Loop {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Loop
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for StmtExpr {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::StmtExpr
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for FuncDecl {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::FuncDecl
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Return {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Return
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Break {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Break
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Continue {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Continue
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for IfSimple {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::IfSimple
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for IfMulti {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::IfMulti
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Block {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Block
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for FuncAnon {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::FuncAnon
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for GetVar {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::GetVar
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for SetVar {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::SetVar
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for GetField {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::GetField
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for SetField {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::SetField
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for GetIndex {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::GetIndex
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for SetIndex {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::SetIndex
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Call {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Call
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for CallObject {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::CallObject
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Infix {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Infix
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Prefix {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Prefix
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Array {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Array
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Object {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Object
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Int {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Int
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Float32 {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Float32
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Float64 {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Float64
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Bool {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Bool
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Str {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Str
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Nil {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Nil
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Branch {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Branch
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for ObjectEntry {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::ObjectEntry
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Ident {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Ident
    }
}

impl From<Var> for Stmt {
    #[inline]
    fn from(v: Var) -> Self {
        Stmt(v.0)
    }
}

impl TryFrom<Stmt> for Var {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Stmt) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), StmtKind::Var(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Loop> for Stmt {
    #[inline]
    fn from(v: Loop) -> Self {
        Stmt(v.0)
    }
}

impl TryFrom<Stmt> for Loop {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Stmt) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), StmtKind::Loop(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<StmtExpr> for Stmt {
    #[inline]
    fn from(v: StmtExpr) -> Self {
        Stmt(v.0)
    }
}

impl TryFrom<Stmt> for StmtExpr {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Stmt) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), StmtKind::StmtExpr(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<FuncDecl> for Stmt {
    #[inline]
    fn from(v: FuncDecl) -> Self {
        Stmt(v.0)
    }
}

impl TryFrom<Stmt> for FuncDecl {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Stmt) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), StmtKind::FuncDecl(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Return> for Expr {
    #[inline]
    fn from(v: Return) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Return {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::Return(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Break> for Expr {
    #[inline]
    fn from(v: Break) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Break {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::Break(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Continue> for Expr {
    #[inline]
    fn from(v: Continue) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Continue {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::Continue(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<IfSimple> for Expr {
    #[inline]
    fn from(v: IfSimple) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for IfSimple {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::IfSimple(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<IfMulti> for Expr {
    #[inline]
    fn from(v: IfMulti) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for IfMulti {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::IfMulti(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Block> for Expr {
    #[inline]
    fn from(v: Block) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Block {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::Block(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<FuncAnon> for Expr {
    #[inline]
    fn from(v: FuncAnon) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for FuncAnon {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::FuncAnon(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<GetVar> for Expr {
    #[inline]
    fn from(v: GetVar) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for GetVar {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::GetVar(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<SetVar> for Expr {
    #[inline]
    fn from(v: SetVar) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for SetVar {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::SetVar(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<GetField> for Expr {
    #[inline]
    fn from(v: GetField) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for GetField {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::GetField(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<SetField> for Expr {
    #[inline]
    fn from(v: SetField) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for SetField {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::SetField(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<GetIndex> for Expr {
    #[inline]
    fn from(v: GetIndex) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for GetIndex {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::GetIndex(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<SetIndex> for Expr {
    #[inline]
    fn from(v: SetIndex) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for SetIndex {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::SetIndex(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Call> for Expr {
    #[inline]
    fn from(v: Call) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Call {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::Call(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<CallObject> for Expr {
    #[inline]
    fn from(v: CallObject) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for CallObject {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::CallObject(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Infix> for Expr {
    #[inline]
    fn from(v: Infix) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Infix {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::Infix(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Prefix> for Expr {
    #[inline]
    fn from(v: Prefix) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Prefix {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::Prefix(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Array> for Expr {
    #[inline]
    fn from(v: Array) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Array {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::Array(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Object> for Expr {
    #[inline]
    fn from(v: Object) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Object {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::Object(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Int> for Expr {
    #[inline]
    fn from(v: Int) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Int {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::Int(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Float32> for Expr {
    #[inline]
    fn from(v: Float32) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Float32 {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::Float32(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Float64> for Expr {
    #[inline]
    fn from(v: Float64) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Float64 {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::Float64(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Bool> for Expr {
    #[inline]
    fn from(v: Bool) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Bool {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::Bool(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Str> for Expr {
    #[inline]
    fn from(v: Str) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Str {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::Str(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Nil> for Expr {
    #[inline]
    fn from(v: Nil) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Nil {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.kind(), ExprKind::Nil(..)) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

pub mod spanned {
    use super::{Opt, Spanned};
    pub struct Root<'a> {
        pub body: &'a [Spanned<super::Stmt>],
    }
    pub struct Var {
        pub name: Spanned<super::Ident>,
        pub value: Spanned<super::Expr>,
    }
    pub struct Loop<'a> {
        pub body: &'a [Spanned<super::Stmt>],
    }
    pub struct StmtExpr {
        pub inner: Spanned<super::Expr>,
    }
    pub struct FuncDecl<'a> {
        pub name: Spanned<super::Ident>,
        pub body: Spanned<super::Block>,
        pub params: &'a [Spanned<super::Ident>],
    }
    pub struct Return {
        pub value: Spanned<Opt<super::Expr>>,
    }
    pub struct Break {}
    pub struct Continue {}
    pub struct IfSimple<'a> {
        pub cond: Spanned<super::Expr>,
        pub tail: Spanned<Opt<super::Block>>,
        pub body: &'a [Spanned<super::Stmt>],
    }
    pub struct IfMulti<'a> {
        pub tail: Spanned<Opt<super::Block>>,
        pub branches: &'a [Spanned<super::Branch>],
    }
    pub struct Block<'a> {
        pub body: &'a [Spanned<super::Stmt>],
    }
    pub struct FuncAnon<'a> {
        pub name: Spanned<Opt<super::Ident>>,
        pub body: Spanned<super::Block>,
        pub params: &'a [Spanned<super::Ident>],
    }
    pub struct GetVar {
        pub name: Spanned<super::Ident>,
    }
    pub struct SetVar {
        pub base: Spanned<super::GetVar>,
        pub value: Spanned<super::Expr>,
        pub op: super::AssignOp,
    }
    pub struct GetField {
        pub parent: Spanned<super::Expr>,
        pub key: Spanned<super::Ident>,
    }
    pub struct SetField {
        pub base: Spanned<super::GetField>,
        pub value: Spanned<super::Expr>,
        pub op: super::AssignOp,
    }
    pub struct GetIndex {
        pub parent: Spanned<super::Expr>,
        pub key: Spanned<super::Expr>,
    }
    pub struct SetIndex {
        pub base: Spanned<super::GetIndex>,
        pub value: Spanned<super::Expr>,
        pub op: super::AssignOp,
    }
    pub struct Call<'a> {
        pub callee: Spanned<super::Expr>,
        pub args: &'a [Spanned<super::Expr>],
    }
    pub struct CallObject<'a> {
        pub callee: Spanned<super::Expr>,
        pub args: &'a [Spanned<super::ObjectEntry>],
    }
    pub struct Infix {
        pub lhs: Spanned<super::Expr>,
        pub rhs: Spanned<super::Expr>,
        pub op: super::InfixOp,
    }
    pub struct Prefix {
        pub rhs: Spanned<super::Expr>,
        pub op: super::PrefixOp,
    }
    pub struct Array<'a> {
        pub items: &'a [Spanned<super::Expr>],
    }
    pub struct Object<'a> {
        pub entries: &'a [Spanned<super::ObjectEntry>],
    }
    pub struct Int {
        pub value: super::u56,
    }
    pub struct Float32 {
        pub value: f32,
    }
    pub struct Float64 {
        pub value: super::FloatId,
    }
    pub struct Bool {
        pub value: bool,
    }
    pub struct Str {
        pub value: super::StrId,
    }
    pub struct Nil {}
    pub struct Branch<'a> {
        pub cond: Spanned<super::Expr>,
        pub body: &'a [Spanned<super::Stmt>],
    }
    pub struct ObjectEntry {
        pub key: Spanned<super::Str>,
        pub value: Spanned<super::Expr>,
    }
    pub struct Ident {
        pub id: super::IdentId,
    }
}

impl<'a> Pack for spanned::Root<'a> {
    type Node = Root;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { body } = self;
        let length = body.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let body = <_>::into_spanned_packed_slice(body);
        let index = ast.append(body);
        let node = Packed::variable_arity(NodeKind::Root, length, index);
        Root(node)
    }
}

impl Pack for spanned::Var {
    type Node = Var;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { name, value } = self;
        let name = name.map(|v| v.0);
        let value = value.map(|v| v.0);
        let index = ast.append(&[name, value]);
        let node = Packed::fixed_arity(NodeKind::Var, index);
        Var(node)
    }
}

impl<'a> Pack for spanned::Loop<'a> {
    type Node = Loop;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { body } = self;
        let length = body.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let body = <_>::into_spanned_packed_slice(body);
        let index = ast.append(body);
        let node = Packed::variable_arity(NodeKind::Loop, length, index);
        Loop(node)
    }
}

impl Pack for spanned::StmtExpr {
    type Node = StmtExpr;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { inner } = self;
        let inner = inner.map(|v| v.0);
        let index = ast.append(&[inner]);
        let node = Packed::fixed_arity(NodeKind::StmtExpr, index);
        StmtExpr(node)
    }
}

impl<'a> Pack for spanned::FuncDecl<'a> {
    type Node = FuncDecl;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { name, body, params } = self;
        let name = name.map(|v| v.0);
        let body = body.map(|v| v.0);
        let index = ast.append(&[name, body]);

        let length = params.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let params = <_>::into_spanned_packed_slice(params);
        let _ = ast.append(params);
        let node = Packed::mixed_arity(NodeKind::FuncDecl, length, index);
        FuncDecl(node)
    }
}

impl Pack for spanned::Return {
    type Node = Return;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { value } = self;
        let value = value.map(|v| v.0);
        let index = ast.append(&[value]);
        let node = Packed::fixed_arity(NodeKind::Return, index);
        Return(node)
    }
}

impl Pack for spanned::Break {
    type Node = Break;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = (self, ast);
        let node = Packed::kind_only(NodeKind::Break);
        Break(node)
    }
}

impl Pack for spanned::Continue {
    type Node = Continue;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = (self, ast);
        let node = Packed::kind_only(NodeKind::Continue);
        Continue(node)
    }
}

impl<'a> Pack for spanned::IfSimple<'a> {
    type Node = IfSimple;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { cond, tail, body } = self;
        let cond = cond.map(|v| v.0);
        let tail = tail.map(|v| v.0);
        let index = ast.append(&[cond, tail]);

        let length = body.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let body = <_>::into_spanned_packed_slice(body);
        let _ = ast.append(body);
        let node = Packed::mixed_arity(NodeKind::IfSimple, length, index);
        IfSimple(node)
    }
}

impl<'a> Pack for spanned::IfMulti<'a> {
    type Node = IfMulti;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { tail, branches } = self;
        let tail = tail.map(|v| v.0);
        let index = ast.append(&[tail]);

        let length = branches.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let branches = <_>::into_spanned_packed_slice(branches);
        let _ = ast.append(branches);
        let node = Packed::mixed_arity(NodeKind::IfMulti, length, index);
        IfMulti(node)
    }
}

impl<'a> Pack for spanned::Block<'a> {
    type Node = Block;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { body } = self;
        let length = body.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let body = <_>::into_spanned_packed_slice(body);
        let index = ast.append(body);
        let node = Packed::variable_arity(NodeKind::Block, length, index);
        Block(node)
    }
}

impl<'a> Pack for spanned::FuncAnon<'a> {
    type Node = FuncAnon;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { name, body, params } = self;
        let name = name.map(|v| v.0);
        let body = body.map(|v| v.0);
        let index = ast.append(&[name, body]);

        let length = params.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let params = <_>::into_spanned_packed_slice(params);
        let _ = ast.append(params);
        let node = Packed::mixed_arity(NodeKind::FuncAnon, length, index);
        FuncAnon(node)
    }
}

impl Pack for spanned::GetVar {
    type Node = GetVar;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { name } = self;
        let name = name.map(|v| v.0);
        let index = ast.append(&[name]);
        let node = Packed::fixed_arity(NodeKind::GetVar, index);
        GetVar(node)
    }
}

impl Pack for spanned::SetVar {
    type Node = SetVar;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { op, base, value } = self;
        let base = base.map(|v| v.0);
        let value = value.map(|v| v.0);
        let index = ast.append(&[base, value]);
        let op: u24 = op.into_u24();
        let node = Packed::fixed_arity_inline(NodeKind::SetVar, op, index);
        SetVar(node)
    }
}

impl Pack for spanned::GetField {
    type Node = GetField;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { parent, key } = self;
        let parent = parent.map(|v| v.0);
        let key = key.map(|v| v.0);
        let index = ast.append(&[parent, key]);
        let node = Packed::fixed_arity(NodeKind::GetField, index);
        GetField(node)
    }
}

impl Pack for spanned::SetField {
    type Node = SetField;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { op, base, value } = self;
        let base = base.map(|v| v.0);
        let value = value.map(|v| v.0);
        let index = ast.append(&[base, value]);
        let op: u24 = op.into_u24();
        let node = Packed::fixed_arity_inline(NodeKind::SetField, op, index);
        SetField(node)
    }
}

impl Pack for spanned::GetIndex {
    type Node = GetIndex;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { parent, key } = self;
        let parent = parent.map(|v| v.0);
        let key = key.map(|v| v.0);
        let index = ast.append(&[parent, key]);
        let node = Packed::fixed_arity(NodeKind::GetIndex, index);
        GetIndex(node)
    }
}

impl Pack for spanned::SetIndex {
    type Node = SetIndex;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { op, base, value } = self;
        let base = base.map(|v| v.0);
        let value = value.map(|v| v.0);
        let index = ast.append(&[base, value]);
        let op: u24 = op.into_u24();
        let node = Packed::fixed_arity_inline(NodeKind::SetIndex, op, index);
        SetIndex(node)
    }
}

impl<'a> Pack for spanned::Call<'a> {
    type Node = Call;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { callee, args } = self;
        let callee = callee.map(|v| v.0);
        let index = ast.append(&[callee]);

        let length = args.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let args = <_>::into_spanned_packed_slice(args);
        let _ = ast.append(args);
        let node = Packed::mixed_arity(NodeKind::Call, length, index);
        Call(node)
    }
}

impl<'a> Pack for spanned::CallObject<'a> {
    type Node = CallObject;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { callee, args } = self;
        let callee = callee.map(|v| v.0);
        let index = ast.append(&[callee]);

        let length = args.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let args = <_>::into_spanned_packed_slice(args);
        let _ = ast.append(args);
        let node = Packed::mixed_arity(NodeKind::CallObject, length, index);
        CallObject(node)
    }
}

impl Pack for spanned::Infix {
    type Node = Infix;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { op, lhs, rhs } = self;
        let lhs = lhs.map(|v| v.0);
        let rhs = rhs.map(|v| v.0);
        let index = ast.append(&[lhs, rhs]);
        let op: u24 = op.into_u24();
        let node = Packed::fixed_arity_inline(NodeKind::Infix, op, index);
        Infix(node)
    }
}

impl Pack for spanned::Prefix {
    type Node = Prefix;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { op, rhs } = self;
        let rhs = rhs.map(|v| v.0);
        let index = ast.append(&[rhs]);
        let op: u24 = op.into_u24();
        let node = Packed::fixed_arity_inline(NodeKind::Prefix, op, index);
        Prefix(node)
    }
}

impl<'a> Pack for spanned::Array<'a> {
    type Node = Array;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { items } = self;
        let length = items.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let items = <_>::into_spanned_packed_slice(items);
        let index = ast.append(items);
        let node = Packed::variable_arity(NodeKind::Array, length, index);
        Array(node)
    }
}

impl<'a> Pack for spanned::Object<'a> {
    type Node = Object;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { entries } = self;
        let length = entries.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let entries = <_>::into_spanned_packed_slice(entries);
        let index = ast.append(entries);
        let node = Packed::variable_arity(NodeKind::Object, length, index);
        Object(node)
    }
}

impl Pack for spanned::Int {
    type Node = Int;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = ast;
        let Self { value } = self;
        let value: u56 = value.into_u56();
        let node = Packed::inline(NodeKind::Int, value);
        Int(node)
    }
}

impl Pack for spanned::Float32 {
    type Node = Float32;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = ast;
        let Self { value } = self;
        let value: u56 = value.into_u56();
        let node = Packed::inline(NodeKind::Float32, value);
        Float32(node)
    }
}

impl Pack for spanned::Float64 {
    type Node = Float64;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = ast;
        let Self { value } = self;
        let value: u56 = value.into_u56();
        let node = Packed::inline(NodeKind::Float64, value);
        Float64(node)
    }
}

impl Pack for spanned::Bool {
    type Node = Bool;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = ast;
        let Self { value } = self;
        let value: u56 = value.into_u56();
        let node = Packed::inline(NodeKind::Bool, value);
        Bool(node)
    }
}

impl Pack for spanned::Str {
    type Node = Str;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = ast;
        let Self { value } = self;
        let value: u56 = value.into_u56();
        let node = Packed::inline(NodeKind::Str, value);
        Str(node)
    }
}

impl Pack for spanned::Nil {
    type Node = Nil;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = (self, ast);
        let node = Packed::kind_only(NodeKind::Nil);
        Nil(node)
    }
}

impl<'a> Pack for spanned::Branch<'a> {
    type Node = Branch;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { cond, body } = self;
        let cond = cond.map(|v| v.0);
        let index = ast.append(&[cond]);

        let length = body.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let body = <_>::into_spanned_packed_slice(body);
        let _ = ast.append(body);
        let node = Packed::mixed_arity(NodeKind::Branch, length, index);
        Branch(node)
    }
}

impl Pack for spanned::ObjectEntry {
    type Node = ObjectEntry;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { key, value } = self;
        let key = key.map(|v| v.0);
        let value = value.map(|v| v.0);
        let index = ast.append(&[key, value]);
        let node = Packed::fixed_arity(NodeKind::ObjectEntry, index);
        ObjectEntry(node)
    }
}

impl Pack for spanned::Ident {
    type Node = Ident;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = ast;
        let Self { id } = self;
        let id: u56 = id.into_u56();
        let node = Packed::inline(NodeKind::Ident, id);
        Ident(node)
    }
}

impl<'a> Node<'a, Root> {
    #[inline]
    pub fn body(&self) -> &'a [Stmt] {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        unsafe { Stmt::from_packed_slice(nodes) }
    }
}

impl<'a> Node<'a, Var> {
    #[inline(always)]
    pub fn name(&self) -> &'a Ident {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Ident>::from_packed(node) }
    }

    #[inline(always)]
    pub fn value(&self) -> &'a Expr {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_fixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Expr>::from_packed(node) }
    }
}

impl<'a> Node<'a, Loop> {
    #[inline]
    pub fn body(&self) -> &'a [Stmt] {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        unsafe { Stmt::from_packed_slice(nodes) }
    }
}

impl<'a> Node<'a, StmtExpr> {
    #[inline(always)]
    pub fn inner(&self) -> &'a Expr {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Expr>::from_packed(node) }
    }
}

impl<'a> Node<'a, FuncDecl> {
    #[inline(always)]
    pub fn name(&self) -> &'a Ident {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Ident>::from_packed(node) }
    }

    #[inline(always)]
    pub fn body(&self) -> &'a Block {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Block>::from_packed(node) }
    }

    #[inline]
    pub fn params(&self) -> &'a [Ident] {
        const OFFSET: usize = 2;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let length = repr.tail_length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        unsafe { Ident::from_packed_slice(nodes) }
    }
}

impl<'a> Node<'a, Return> {
    #[inline(always)]
    pub fn value(&self) -> &'a Opt<Expr> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Opt<Expr>>::from_packed(node) }
    }
}

impl<'a> Node<'a, IfSimple> {
    #[inline(always)]
    pub fn cond(&self) -> &'a Expr {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Expr>::from_packed(node) }
    }

    #[inline(always)]
    pub fn tail(&self) -> &'a Opt<Block> {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Opt<Block>>::from_packed(node) }
    }

    #[inline]
    pub fn body(&self) -> &'a [Stmt] {
        const OFFSET: usize = 2;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let length = repr.tail_length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        unsafe { Stmt::from_packed_slice(nodes) }
    }
}

impl<'a> Node<'a, IfMulti> {
    #[inline(always)]
    pub fn tail(&self) -> &'a Opt<Block> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Opt<Block>>::from_packed(node) }
    }

    #[inline]
    pub fn branches(&self) -> &'a [Branch] {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let length = repr.tail_length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        unsafe { Branch::from_packed_slice(nodes) }
    }
}

impl<'a> Node<'a, Block> {
    #[inline]
    pub fn body(&self) -> &'a [Stmt] {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        unsafe { Stmt::from_packed_slice(nodes) }
    }
}

impl<'a> Node<'a, FuncAnon> {
    #[inline(always)]
    pub fn name(&self) -> &'a Opt<Ident> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Opt<Ident>>::from_packed(node) }
    }

    #[inline(always)]
    pub fn body(&self) -> &'a Block {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Block>::from_packed(node) }
    }

    #[inline]
    pub fn params(&self) -> &'a [Ident] {
        const OFFSET: usize = 2;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let length = repr.tail_length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        unsafe { Ident::from_packed_slice(nodes) }
    }
}

impl<'a> Node<'a, GetVar> {
    #[inline(always)]
    pub fn name(&self) -> &'a Ident {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Ident>::from_packed(node) }
    }
}

impl<'a> Node<'a, SetVar> {
    #[inline(always)]
    pub fn base(&self) -> &'a GetVar {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <GetVar>::from_packed(node) }
    }

    #[inline(always)]
    pub fn value(&self) -> &'a Expr {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Expr>::from_packed(node) }
    }

    #[inline(always)]
    pub fn op(&self) -> AssignOp {
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        <AssignOp>::from_u24(repr.value)
    }
}

impl<'a> Node<'a, GetField> {
    #[inline(always)]
    pub fn parent(&self) -> &'a Expr {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Expr>::from_packed(node) }
    }

    #[inline(always)]
    pub fn key(&self) -> &'a Ident {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_fixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Ident>::from_packed(node) }
    }
}

impl<'a> Node<'a, SetField> {
    #[inline(always)]
    pub fn base(&self) -> &'a GetField {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <GetField>::from_packed(node) }
    }

    #[inline(always)]
    pub fn value(&self) -> &'a Expr {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Expr>::from_packed(node) }
    }

    #[inline(always)]
    pub fn op(&self) -> AssignOp {
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        <AssignOp>::from_u24(repr.value)
    }
}

impl<'a> Node<'a, GetIndex> {
    #[inline(always)]
    pub fn parent(&self) -> &'a Expr {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Expr>::from_packed(node) }
    }

    #[inline(always)]
    pub fn key(&self) -> &'a Expr {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_fixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Expr>::from_packed(node) }
    }
}

impl<'a> Node<'a, SetIndex> {
    #[inline(always)]
    pub fn base(&self) -> &'a GetIndex {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <GetIndex>::from_packed(node) }
    }

    #[inline(always)]
    pub fn value(&self) -> &'a Expr {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Expr>::from_packed(node) }
    }

    #[inline(always)]
    pub fn op(&self) -> AssignOp {
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        <AssignOp>::from_u24(repr.value)
    }
}

impl<'a> Node<'a, Call> {
    #[inline(always)]
    pub fn callee(&self) -> &'a Expr {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Expr>::from_packed(node) }
    }

    #[inline]
    pub fn args(&self) -> &'a [Expr] {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let length = repr.tail_length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        unsafe { Expr::from_packed_slice(nodes) }
    }
}

impl<'a> Node<'a, CallObject> {
    #[inline(always)]
    pub fn callee(&self) -> &'a Expr {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Expr>::from_packed(node) }
    }

    #[inline]
    pub fn args(&self) -> &'a [ObjectEntry] {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let length = repr.tail_length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        unsafe { ObjectEntry::from_packed_slice(nodes) }
    }
}

impl<'a> Node<'a, Infix> {
    #[inline(always)]
    pub fn lhs(&self) -> &'a Expr {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Expr>::from_packed(node) }
    }

    #[inline(always)]
    pub fn rhs(&self) -> &'a Expr {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Expr>::from_packed(node) }
    }

    #[inline(always)]
    pub fn op(&self) -> InfixOp {
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        <InfixOp>::from_u24(repr.value)
    }
}

impl<'a> Node<'a, Prefix> {
    #[inline(always)]
    pub fn rhs(&self) -> &'a Expr {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Expr>::from_packed(node) }
    }

    #[inline(always)]
    pub fn op(&self) -> PrefixOp {
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        <PrefixOp>::from_u24(repr.value)
    }
}

impl<'a> Node<'a, Array> {
    #[inline]
    pub fn items(&self) -> &'a [Expr] {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        unsafe { Expr::from_packed_slice(nodes) }
    }
}

impl<'a> Node<'a, Object> {
    #[inline]
    pub fn entries(&self) -> &'a [ObjectEntry] {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        unsafe { ObjectEntry::from_packed_slice(nodes) }
    }
}

impl<'a> Node<'a, Int> {
    #[inline(always)]
    pub fn value(&self) -> u56 {
        let repr = unsafe { self.node.0.as_inline() };
        <u56>::from_u56(repr.value)
    }
}

impl<'a> Node<'a, Float32> {
    #[inline(always)]
    pub fn value(&self) -> f32 {
        let repr = unsafe { self.node.0.as_inline() };
        <f32>::from_u56(repr.value)
    }
}

impl<'a> Node<'a, Float64> {
    #[inline(always)]
    pub fn value(&self) -> FloatId {
        let repr = unsafe { self.node.0.as_inline() };
        <FloatId>::from_u56(repr.value)
    }
}

impl<'a> Node<'a, Bool> {
    #[inline(always)]
    pub fn value(&self) -> bool {
        let repr = unsafe { self.node.0.as_inline() };
        <bool>::from_u56(repr.value)
    }
}

impl<'a> Node<'a, Str> {
    #[inline(always)]
    pub fn value(&self) -> StrId {
        let repr = unsafe { self.node.0.as_inline() };
        <StrId>::from_u56(repr.value)
    }
}

impl<'a> Node<'a, Branch> {
    #[inline(always)]
    pub fn cond(&self) -> &'a Expr {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Expr>::from_packed(node) }
    }

    #[inline]
    pub fn body(&self) -> &'a [Stmt] {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let length = repr.tail_length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        unsafe { Stmt::from_packed_slice(nodes) }
    }
}

impl<'a> Node<'a, ObjectEntry> {
    #[inline(always)]
    pub fn key(&self) -> &'a Str {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Str>::from_packed(node) }
    }

    #[inline(always)]
    pub fn value(&self) -> &'a Expr {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_fixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        unsafe { <Expr>::from_packed(node) }
    }
}

impl<'a> Node<'a, Ident> {
    #[inline(always)]
    pub fn id(&self) -> IdentId {
        let repr = unsafe { self.node.0.as_inline() };
        <IdentId>::from_u56(repr.value)
    }
}

impl Root {
    #[inline]
    pub fn body_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        &ast.spans[index..index + length]
    }
}

impl Var {
    #[inline]
    pub fn name_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn value_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 1]
    }
}

impl Loop {
    #[inline]
    pub fn body_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        &ast.spans[index..index + length]
    }
}

impl StmtExpr {
    #[inline]
    pub fn inner_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }
}

impl FuncDecl {
    #[inline]
    pub fn name_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn body_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 1]
    }

    #[inline]
    pub fn params_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = 2 + repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        &ast.spans[index..index + tail_length]
    }
}

impl Return {
    #[inline]
    pub fn value_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }
}

impl IfSimple {
    #[inline]
    pub fn cond_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn tail_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 1]
    }

    #[inline]
    pub fn body_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = 2 + repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        &ast.spans[index..index + tail_length]
    }
}

impl IfMulti {
    #[inline]
    pub fn tail_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn branches_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = 1 + repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        &ast.spans[index..index + tail_length]
    }
}

impl Block {
    #[inline]
    pub fn body_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        &ast.spans[index..index + length]
    }
}

impl FuncAnon {
    #[inline]
    pub fn name_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn body_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 1]
    }

    #[inline]
    pub fn params_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = 2 + repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        &ast.spans[index..index + tail_length]
    }
}

impl GetVar {
    #[inline]
    pub fn name_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }
}

impl SetVar {
    #[inline]
    pub fn base_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn value_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        ast.spans[index + 1]
    }
}

impl GetField {
    #[inline]
    pub fn parent_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn key_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 1]
    }
}

impl SetField {
    #[inline]
    pub fn base_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn value_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        ast.spans[index + 1]
    }
}

impl GetIndex {
    #[inline]
    pub fn parent_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn key_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 1]
    }
}

impl SetIndex {
    #[inline]
    pub fn base_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn value_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        ast.spans[index + 1]
    }
}

impl Call {
    #[inline]
    pub fn callee_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn args_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = 1 + repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        &ast.spans[index..index + tail_length]
    }
}

impl CallObject {
    #[inline]
    pub fn callee_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn args_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = 1 + repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        &ast.spans[index..index + tail_length]
    }
}

impl Infix {
    #[inline]
    pub fn lhs_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn rhs_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        ast.spans[index + 1]
    }
}

impl Prefix {
    #[inline]
    pub fn rhs_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }
}

impl Array {
    #[inline]
    pub fn items_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        &ast.spans[index..index + length]
    }
}

impl Object {
    #[inline]
    pub fn entries_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        &ast.spans[index..index + length]
    }
}

impl Branch {
    #[inline]
    pub fn cond_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn body_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = 1 + repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        &ast.spans[index..index + tail_length]
    }
}

impl ObjectEntry {
    #[inline]
    pub fn key_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn value_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 1]
    }
}

impl<'a> std::fmt::Debug for Node<'a, Stmt> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.node.kind() {
            StmtKind::Var(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            StmtKind::Loop(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            StmtKind::StmtExpr(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            StmtKind::FuncDecl(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
        }
    }
}

impl Stmt {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, Expr> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.node.kind() {
            ExprKind::Return(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::Break(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::Continue(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::IfSimple(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::IfMulti(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::Block(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::FuncAnon(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::GetVar(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::SetVar(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::GetField(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::SetField(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::GetIndex(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::SetIndex(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::Call(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::CallObject(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::Infix(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::Prefix(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::Array(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::Object(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::Int(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::Float32(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::Float64(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::Bool(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::Str(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
            ExprKind::Nil(node) => std::fmt::Debug::fmt(
                &Node {
                    ast: self.ast,
                    node,
                },
                f,
            ),
        }
    }
}

impl Expr {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, Root> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Root")
            .field(&DebugIter(self.body().iter().map(|v| v.debug(self.ast))))
            .finish()?;

        Ok(())
    }
}

impl Root {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, Var> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Var")
            .field(&self.name().debug(self.ast))
            .field(&self.value().debug(self.ast))
            .finish()?;

        Ok(())
    }
}

impl Var {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, Loop> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Loop")
            .field(&DebugIter(self.body().iter().map(|v| v.debug(self.ast))))
            .finish()?;

        Ok(())
    }
}

impl Loop {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, StmtExpr> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("StmtExpr")
            .field(&self.inner().debug(self.ast))
            .finish()?;

        Ok(())
    }
}

impl StmtExpr {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, FuncDecl> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("FuncDecl")
            .field(&self.name().debug(self.ast))
            .field(&self.body().debug(self.ast))
            .field(&DebugIter(self.params().iter().map(|v| v.debug(self.ast))))
            .finish()?;

        Ok(())
    }
}

impl FuncDecl {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, Return> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Return")
            .field(&self.value().as_option().map(|v| v.debug(self.ast)))
            .finish()?;

        Ok(())
    }
}

impl Return {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, Break> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Break")?;

        Ok(())
    }
}

impl Break {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, Continue> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Continue")?;

        Ok(())
    }
}

impl Continue {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, IfSimple> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("IfSimple")
            .field(&self.cond().debug(self.ast))
            .field(&self.tail().as_option().map(|v| v.debug(self.ast)))
            .field(&DebugIter(self.body().iter().map(|v| v.debug(self.ast))))
            .finish()?;

        Ok(())
    }
}

impl IfSimple {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, IfMulti> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("IfMulti")
            .field(&self.tail().as_option().map(|v| v.debug(self.ast)))
            .field(&DebugIter(
                self.branches().iter().map(|v| v.debug(self.ast)),
            ))
            .finish()?;

        Ok(())
    }
}

impl IfMulti {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, Block> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Block")
            .field(&DebugIter(self.body().iter().map(|v| v.debug(self.ast))))
            .finish()?;

        Ok(())
    }
}

impl Block {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, FuncAnon> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("FuncAnon")
            .field(&self.name().as_option().map(|v| v.debug(self.ast)))
            .field(&self.body().debug(self.ast))
            .field(&DebugIter(self.params().iter().map(|v| v.debug(self.ast))))
            .finish()?;

        Ok(())
    }
}

impl FuncAnon {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, GetVar> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("GetVar")
            .field(&self.name().debug(self.ast))
            .finish()?;

        Ok(())
    }
}

impl GetVar {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, SetVar> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("SetVar")
            .field(&self.op().debug(self.ast))
            .field(&self.base().debug(self.ast))
            .field(&self.value().debug(self.ast))
            .finish()?;

        Ok(())
    }
}

impl SetVar {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, GetField> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("GetField")
            .field(&self.parent().debug(self.ast))
            .field(&self.key().debug(self.ast))
            .finish()?;

        Ok(())
    }
}

impl GetField {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, SetField> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("SetField")
            .field(&self.op().debug(self.ast))
            .field(&self.base().debug(self.ast))
            .field(&self.value().debug(self.ast))
            .finish()?;

        Ok(())
    }
}

impl SetField {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, GetIndex> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("GetIndex")
            .field(&self.parent().debug(self.ast))
            .field(&self.key().debug(self.ast))
            .finish()?;

        Ok(())
    }
}

impl GetIndex {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, SetIndex> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("SetIndex")
            .field(&self.op().debug(self.ast))
            .field(&self.base().debug(self.ast))
            .field(&self.value().debug(self.ast))
            .finish()?;

        Ok(())
    }
}

impl SetIndex {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, Call> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Call")
            .field(&self.callee().debug(self.ast))
            .field(&DebugIter(self.args().iter().map(|v| v.debug(self.ast))))
            .finish()?;

        Ok(())
    }
}

impl Call {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, CallObject> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("CallObject")
            .field(&self.callee().debug(self.ast))
            .field(&DebugIter(self.args().iter().map(|v| v.debug(self.ast))))
            .finish()?;

        Ok(())
    }
}

impl CallObject {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, Infix> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Infix")
            .field(&self.op().debug(self.ast))
            .field(&self.lhs().debug(self.ast))
            .field(&self.rhs().debug(self.ast))
            .finish()?;

        Ok(())
    }
}

impl Infix {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, Prefix> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Prefix")
            .field(&self.op().debug(self.ast))
            .field(&self.rhs().debug(self.ast))
            .finish()?;

        Ok(())
    }
}

impl Prefix {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, Array> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Array")
            .field(&DebugIter(self.items().iter().map(|v| v.debug(self.ast))))
            .finish()?;

        Ok(())
    }
}

impl Array {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, Object> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Object")
            .field(&DebugIter(self.entries().iter().map(|v| v.debug(self.ast))))
            .finish()?;

        Ok(())
    }
}

impl Object {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, Int> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Int")
            .field(&self.value().debug(self.ast))
            .finish()?;

        Ok(())
    }
}

impl Int {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, Float32> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Float32")
            .field(&self.value().debug(self.ast))
            .finish()?;

        Ok(())
    }
}

impl Float32 {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, Float64> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Float64")
            .field(&self.value().debug(self.ast))
            .finish()?;

        Ok(())
    }
}

impl Float64 {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, Bool> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Bool")
            .field(&self.value().debug(self.ast))
            .finish()?;

        Ok(())
    }
}

impl Bool {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, Str> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Str")
            .field(&self.value().debug(self.ast))
            .finish()?;

        Ok(())
    }
}

impl Str {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, Nil> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Nil")?;

        Ok(())
    }
}

impl Nil {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, Branch> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Branch")
            .field(&self.cond().debug(self.ast))
            .field(&DebugIter(self.body().iter().map(|v| v.debug(self.ast))))
            .finish()?;

        Ok(())
    }
}

impl Branch {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, ObjectEntry> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("ObjectEntry")
            .field(&self.key().debug(self.ast))
            .field(&self.value().debug(self.ast))
            .finish()?;

        Ok(())
    }
}

impl ObjectEntry {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}

impl<'a> std::fmt::Debug for Node<'a, Ident> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Ident")
            .field(&self.id().debug(self.ast))
            .finish()?;

        Ok(())
    }
}

impl Ident {
    pub fn debug<'a>(&'a self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Node { ast, node: self }
    }
}
