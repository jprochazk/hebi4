// Generated by astgen at 2025-07-02T21:37:43.268009972+00:00[UTC]
//
// See `astgen/src/main.rs` and `astgen/src/runtime.rs`

use super::{AssignOp, Ast, FloatId, IdentId, InfixOp, PrefixOp, StrId};
use crate::span::{Span, Spanned};

mod private {
    pub trait Sealed {}
}
use private::Sealed;

use std::marker::PhantomData;

trait DebugWithAstExt {
    fn debug(self, ast: &Ast) -> impl std::fmt::Debug + '_;
}

impl DebugWithAstExt for f32 {
    fn debug(self, _: &Ast) -> impl std::fmt::Debug + '_ {
        self
    }
}

impl DebugWithAstExt for bool {
    fn debug(self, _: &Ast) -> impl std::fmt::Debug + '_ {
        self
    }
}

#[allow(non_camel_case_types)]
#[derive(Clone, Copy, Hash)]
#[repr(packed)]
pub struct u24([u8; 3]);

impl u24 {
    pub const MAX: u24 = u24([255; 3]);
    pub const MIN: u24 = u24([0; 3]);
    pub const ZERO: u24 = u24([0; 3]);

    #[inline]
    pub const fn new(v: u32) -> Self {
        if v > Self::MAX.get() {
            panic!("value is out of bounds for u24");
        }

        unsafe { Self::new_unchecked(v) }
    }

    #[inline]
    pub const unsafe fn new_unchecked(v: u32) -> Self {
        let [a, b, c, _] = v.to_le_bytes();
        Self([a, b, c])
    }

    #[inline]
    pub const fn get(self) -> u32 {
        let [a, b, c] = self.0;
        u32::from_le_bytes([a, b, c, 0])
    }
}

impl PartialEq for u24 {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        PartialEq::eq(&self.get(), &other.get())
    }
}

impl Eq for u24 {}

impl PartialOrd for u24 {
    #[inline]
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        PartialOrd::partial_cmp(&self.get(), &other.get())
    }
}

impl Ord for u24 {
    #[inline]
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        Ord::cmp(&self.get(), &other.get())
    }
}

impl std::fmt::Debug for u24 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        <u32 as std::fmt::Debug>::fmt(&self.get(), f)
    }
}

impl u24 {
    pub fn debug(self, _: &Ast) -> impl std::fmt::Debug + '_ {
        self
    }
}

#[allow(non_camel_case_types)]
#[derive(Clone, Copy, Hash)]
#[repr(packed)]
pub struct u56([u8; 7]);

impl u56 {
    pub const MAX: u56 = u56([255; 7]);
    pub const MIN: u56 = u56([0; 7]);
    pub const ZERO: u56 = u56([0; 7]);

    #[inline]
    pub const fn new(v: u64) -> Self {
        if v > Self::MAX.get() {
            panic!("value is out of bounds for u56");
        }

        unsafe { Self::new_unchecked(v) }
    }

    #[inline]
    pub const unsafe fn new_unchecked(v: u64) -> Self {
        let [a, b, c, d, e, f, g, _] = v.to_le_bytes();
        Self([a, b, c, d, e, f, g])
    }

    #[inline]
    pub const fn get(self) -> u64 {
        let [a, b, c, d, e, f, g] = self.0;
        u64::from_le_bytes([a, b, c, d, e, f, g, 0])
    }

    fn from_u56(v: u56) -> Self {
        v
    }

    fn into_u56(self) -> u56 {
        self
    }
}

impl PartialEq for u56 {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        PartialEq::eq(&self.get(), &other.get())
    }
}

impl Eq for u56 {}

impl PartialOrd for u56 {
    #[inline]
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        PartialOrd::partial_cmp(&self.get(), &other.get())
    }
}

impl Ord for u56 {
    #[inline]
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        Ord::cmp(&self.get(), &other.get())
    }
}

impl std::fmt::Debug for u56 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        <u64 as std::fmt::Debug>::fmt(&self.get(), f)
    }
}

impl u56 {
    pub fn debug(self, _: &Ast) -> impl std::fmt::Debug + '_ {
        self
    }
}

trait IntoU56 {
    fn into_u56(self) -> u56;
}

trait FromU56 {
    fn from_u56(v: u56) -> Self;
}

impl IntoU56 for bool {
    fn into_u56(self) -> u56 {
        unsafe { u56::new_unchecked(self as u64) }
    }
}

impl FromU56 for bool {
    #[allow(unnecessary_transmutes)]
    fn from_u56(v: u56) -> Self {
        unsafe { core::mem::transmute(v.get() as u8) }
    }
}

impl IntoU56 for f32 {
    fn into_u56(self) -> u56 {
        unsafe { u56::new_unchecked(self.to_bits() as u64) }
    }
}

impl FromU56 for f32 {
    fn from_u56(v: u56) -> Self {
        f32::from_bits(v.get() as u32)
    }
}

#[derive(Clone, Copy)]
#[repr(C)]
pub struct Packed {
    repr: PackedRepr,
    #[cfg(debug_assertions)]
    debug_tag: DebugPackedReprTag,
}

impl Packed {
    #[inline]
    pub fn kind(&self) -> NodeKind {
        // SAFETY: `kind` is present in every union variant
        let kind = unsafe { self.repr.kind_only.kind.get() };
        debug_assert!(NodeKind::all().iter().map(|(_, v)| *v).any(|v| v == kind));

        // SAFETY: All writes of `kind` are in this file, and we know
        // that what's written is always a valid bitpattern of `NodeKind`.
        unsafe { core::mem::transmute(kind) }
    }

    #[inline]
    fn kind_only(kind: NodeKind) -> Self {
        Self {
            repr: PackedRepr {
                kind_only: KindOnly {
                    kind: unsafe { core::num::NonZero::new_unchecked(kind as u8) },
                    _padding: u56::ZERO,
                },
            },
            debug_tag: DebugPackedReprTag::KindOnly,
        }
    }

    #[inline]
    fn fixed_arity(kind: NodeKind, index: u32) -> Self {
        Self {
            repr: PackedRepr {
                fixed_arity: FixedArity {
                    kind: unsafe { core::num::NonZero::new_unchecked(kind as u8) },
                    _padding: u24::ZERO,
                    index,
                },
            },
            debug_tag: DebugPackedReprTag::FixedArity,
        }
    }

    #[inline]
    fn fixed_arity_inline(kind: NodeKind, value: u24, index: u32) -> Self {
        Self {
            repr: PackedRepr {
                fixed_arity_inline: FixedArity_Inline {
                    kind: unsafe { core::num::NonZero::new_unchecked(kind as u8) },
                    value,
                    index,
                },
            },
            debug_tag: DebugPackedReprTag::FixedArity_Inline,
        }
    }

    #[inline]
    fn variable_arity(kind: NodeKind, length: u24, index: u32) -> Self {
        Self {
            repr: PackedRepr {
                variable_arity: VariableArity {
                    kind: unsafe { core::num::NonZero::new_unchecked(kind as u8) },
                    length,
                    index,
                },
            },
            debug_tag: DebugPackedReprTag::VariableArity,
        }
    }

    #[inline]
    fn mixed_arity(kind: NodeKind, length: u24, index: u32) -> Self {
        Self {
            repr: PackedRepr {
                mixed_arity: MixedArity {
                    kind: unsafe { core::num::NonZero::new_unchecked(kind as u8) },
                    tail_length: length,
                    index,
                },
            },
            debug_tag: DebugPackedReprTag::MixedArity,
        }
    }

    #[inline]
    fn inline(kind: NodeKind, value: u56) -> Self {
        Self {
            repr: PackedRepr {
                inline: Inline {
                    kind: unsafe { core::num::NonZero::new_unchecked(kind as u8) },
                    value,
                },
            },
            debug_tag: DebugPackedReprTag::Inline,
        }
    }

    #[inline]
    unsafe fn as_kind_only(&self) -> &KindOnly {
        debug_assert!(self.debug_tag == DebugPackedReprTag::KindOnly);
        unsafe { &self.repr.kind_only }
    }

    #[inline]
    unsafe fn as_fixed_arity(&self) -> &FixedArity {
        debug_assert!(self.debug_tag == DebugPackedReprTag::FixedArity);
        unsafe { &self.repr.fixed_arity }
    }

    #[inline]
    unsafe fn as_fixed_arity_inline(&self) -> &FixedArity_Inline {
        debug_assert!(self.debug_tag == DebugPackedReprTag::FixedArity_Inline);
        unsafe { &self.repr.fixed_arity_inline }
    }

    #[inline]
    unsafe fn as_variable_arity(&self) -> &VariableArity {
        debug_assert!(self.debug_tag == DebugPackedReprTag::VariableArity);
        unsafe { &self.repr.variable_arity }
    }

    #[inline]
    unsafe fn as_mixed_arity(&self) -> &MixedArity {
        debug_assert!(self.debug_tag == DebugPackedReprTag::MixedArity);
        unsafe { &self.repr.mixed_arity }
    }

    #[inline]
    unsafe fn as_inline(&self) -> &Inline {
        debug_assert!(self.debug_tag == DebugPackedReprTag::Inline);
        unsafe { &self.repr.inline }
    }
}

const _: () = {
    let _ = core::mem::transmute::<Option<Packed>, Packed>;
};

#[allow(non_camel_case_types)]
#[cfg(debug_assertions)]
#[derive(Debug, Clone, Copy, PartialEq)]
enum DebugPackedReprTag {
    KindOnly,
    FixedArity,
    FixedArity_Inline,
    VariableArity,
    MixedArity,
    Inline,
}

#[derive(Clone, Copy)]
union PackedRepr {
    kind_only: KindOnly,
    fixed_arity: FixedArity,
    fixed_arity_inline: FixedArity_Inline,
    variable_arity: VariableArity,
    mixed_arity: MixedArity,
    inline: Inline,
}

type RawKind = core::num::NonZero<u8>;

#[derive(Clone, Copy)]
#[repr(C)]
struct KindOnly {
    kind: RawKind,
    _padding: u56,
}

#[derive(Clone, Copy)]
#[repr(C)]
struct FixedArity {
    kind: RawKind,
    _padding: u24,
    index: u32,
}

#[allow(non_camel_case_types)]
#[derive(Clone, Copy)]
#[repr(C)]
struct FixedArity_Inline {
    kind: RawKind,
    value: u24,
    index: u32,
}

#[derive(Clone, Copy)]
#[repr(C)]
struct VariableArity {
    kind: RawKind,
    length: u24,
    index: u32,
}

#[derive(Clone, Copy)]
#[repr(C)]
struct MixedArity {
    kind: RawKind,
    tail_length: u24,
    index: u32,
}

#[derive(Clone, Copy)]
#[repr(C)]
struct Inline {
    kind: RawKind,
    value: u56,
}

/// Marker for types which are transparent wrappers over [`Packed`].
pub unsafe trait PackedAbi: Sealed + Sized + Copy {
    /// Check if `kind` matches `Self`'s kind.
    fn check_kind(kind: NodeKind) -> bool;
}

/// Conversion traits to/from [`Packed`].
pub trait PackedNode: PackedAbi {
    /// SAFETY:
    /// - `Self` must be a transparent wrapper over `Packed`.
    /// - `v` must have the same kind as `Self`.
    unsafe fn from_packed(v: Packed) -> Self;

    fn into_packed(v: Self) -> Packed;

    /// SAFETY:
    /// - All nodes in `v` must have the same kind as `Self`.
    /// - `Self` must be a transparent wrapper over `Packed`.
    unsafe fn from_packed_slice(v: &[Packed]) -> &[Self];

    fn into_packed_slice(v: &[Self]) -> &[Packed];

    /// SAFETY:
    /// - `Self` must be a transparent wrapper over `Packed`.
    /// - `Spanned` is a repr(C) struct, meaning it has the
    ///   same layout for the same `T`.
    unsafe fn from_spanned_packed(v: Spanned<Packed>) -> Spanned<Self>;

    fn into_spanned_packed(v: Spanned<Self>) -> Spanned<Packed>;

    /// SAFETY:
    /// - `Self` must be a transparent wrapper over `Packed`.
    /// - All nodes in `v` must have the same kind as `Self`.
    /// - `Spanned` is a repr(C) struct, meaning it has the
    ///   same layout for the same `T`.
    unsafe fn from_spanned_packed_slice(v: &[Spanned<Packed>]) -> &[Spanned<Self>];

    fn into_spanned_packed_slice(v: &[Spanned<Self>]) -> &[Spanned<Packed>];
}

impl<T: PackedAbi> PackedNode for T {
    unsafe fn from_packed(v: Packed) -> Self {
        debug_assert!(T::check_kind(v.kind()));
        unsafe { core::mem::transmute_copy(&v) }
    }

    fn into_packed(v: Self) -> Packed {
        unsafe { core::mem::transmute_copy(&v) }
    }

    unsafe fn from_packed_slice(v: &[Packed]) -> &[Self] {
        debug_assert!(v.iter().all(|v| T::check_kind(v.kind())));
        unsafe { core::mem::transmute(v) }
    }

    fn into_packed_slice(v: &[Self]) -> &[Packed] {
        unsafe { core::mem::transmute(v) }
    }

    unsafe fn from_spanned_packed(v: Spanned<Packed>) -> Spanned<Self> {
        debug_assert!(T::check_kind(v.kind()));
        unsafe { core::mem::transmute_copy(&v) }
    }

    fn into_spanned_packed(v: Spanned<Self>) -> Spanned<Packed> {
        unsafe { core::mem::transmute_copy(&v) }
    }

    unsafe fn from_spanned_packed_slice(v: &[Spanned<Packed>]) -> &[Spanned<Self>] {
        debug_assert!(v.iter().all(|v| T::check_kind(v.kind())));
        unsafe { core::mem::transmute(v) }
    }

    fn into_spanned_packed_slice(v: &[Spanned<Self>]) -> &[Spanned<Packed>] {
        unsafe { core::mem::transmute(v) }
    }
}

#[derive(Clone, Copy, Debug)]
pub struct NodeCastError;
impl std::fmt::Display for NodeCastError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "invalid cast between node types")
    }
}
impl std::error::Error for NodeCastError {}

pub trait Pack {
    type Node;

    fn pack(self, ast: &mut Ast) -> Self::Node;
}

pub trait Unpack {
    type Node<'a>;

    /// # Safety
    /// - The node and all its subnodes must exist within the given `ast`.
    ///
    /// The only way to ensure this is to use [`Pack`] with [`AstBuilder`],
    /// and then [`AstBuilder::build`].
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a>;
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Opt<T>(Packed, PhantomData<T>);

impl<T: Sealed> Sealed for Opt<T> {}
/// SAFETY: `Opt` is a transparent wrapper over `Packed`.
unsafe impl<T: PackedAbi> PackedAbi for Opt<T> {
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::None || T::check_kind(kind)
    }
}

impl<T: PackedAbi> Opt<T> {
    #[inline]
    pub fn some(v: T) -> Self {
        Self(T::into_packed(v), PhantomData)
    }

    #[inline]
    pub fn none() -> Self {
        Self(Packed::kind_only(NodeKind::None), PhantomData)
    }

    #[inline]
    pub fn is_some(&self) -> bool {
        !self.is_none()
    }

    #[inline]
    pub fn is_none(&self) -> bool {
        matches!(self.0.kind(), NodeKind::None)
    }

    #[inline]
    pub fn unwrap(&self) -> T {
        if self.is_none() {
            panic!("unwrapped an Opt::None value");
        }
        unsafe { T::from_packed(self.0) }
    }

    #[inline]
    pub unsafe fn unwrap_unchecked(&self) -> T {
        debug_assert!(self.is_some());
        unsafe { T::from_packed(self.0) }
    }

    #[inline]
    pub fn into_option(self) -> Option<T> {
        self.into()
    }
}

impl<T: PackedAbi> From<Opt<T>> for Option<T> {
    fn from(value: Opt<T>) -> Self {
        if value.is_some() {
            Some(unsafe { value.unwrap_unchecked() })
        } else {
            None
        }
    }
}

impl<T: PackedAbi> From<Option<T>> for Opt<T> {
    fn from(value: Option<T>) -> Self {
        match value {
            Some(value) => Self::some(value),
            None => Self::none(),
        }
    }
}

struct DebugIter<T>(T);

impl<T: Clone + Iterator<Item = I>, I: std::fmt::Debug> std::fmt::Debug for DebugIter<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_list().entries(self.0.clone()).finish()
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u8)]
pub enum NodeKind {
    Root = 1,
    Var = 2,
    Loop = 3,
    StmtExpr = 4,
    FuncDecl = 5,
    Return = 6,
    Break = 7,
    Continue = 8,
    IfSimple = 9,
    IfMulti = 10,
    Block = 11,
    FuncAnon = 12,
    GetVar = 13,
    SetVar = 14,
    GetField = 15,
    SetField = 16,
    GetIndex = 17,
    SetIndex = 18,
    Call = 19,
    CallObject = 20,
    Infix = 21,
    Prefix = 22,
    Array = 23,
    Object = 24,
    Int = 25,
    Float32 = 26,
    Float64 = 27,
    Bool = 28,
    Str = 29,
    Nil = 30,
    Branch = 31,
    ObjectEntry = 32,
    Ident = 33,
    None = 255,
}

impl NodeKind {
    const fn all() -> &'static [(&'static str, u8)] {
        &[
            ("Root", 1),
            ("Var", 2),
            ("Loop", 3),
            ("StmtExpr", 4),
            ("FuncDecl", 5),
            ("Return", 6),
            ("Break", 7),
            ("Continue", 8),
            ("IfSimple", 9),
            ("IfMulti", 10),
            ("Block", 11),
            ("FuncAnon", 12),
            ("GetVar", 13),
            ("SetVar", 14),
            ("GetField", 15),
            ("SetField", 16),
            ("GetIndex", 17),
            ("SetIndex", 18),
            ("Call", 19),
            ("CallObject", 20),
            ("Infix", 21),
            ("Prefix", 22),
            ("Array", 23),
            ("Object", 24),
            ("Int", 25),
            ("Float32", 26),
            ("Float64", 27),
            ("Bool", 28),
            ("Str", 29),
            ("Nil", 30),
            ("Branch", 31),
            ("ObjectEntry", 32),
            ("Ident", 33),
            ("None", 255),
        ]
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u8)]
pub enum StmtKind {
    Var = NodeKind::Var as u8,
    Loop = NodeKind::Loop as u8,
    StmtExpr = NodeKind::StmtExpr as u8,
    FuncDecl = NodeKind::FuncDecl as u8,
}

impl Stmt {
    #[inline]
    pub fn kind(&self) -> StmtKind {
        // SAFETY: `self` is a valid Stmt
        unsafe { core::mem::transmute(self.0.kind()) }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u8)]
pub enum ExprKind {
    Return = NodeKind::Return as u8,
    Break = NodeKind::Break as u8,
    Continue = NodeKind::Continue as u8,
    IfSimple = NodeKind::IfSimple as u8,
    IfMulti = NodeKind::IfMulti as u8,
    Block = NodeKind::Block as u8,
    FuncAnon = NodeKind::FuncAnon as u8,
    GetVar = NodeKind::GetVar as u8,
    SetVar = NodeKind::SetVar as u8,
    GetField = NodeKind::GetField as u8,
    SetField = NodeKind::SetField as u8,
    GetIndex = NodeKind::GetIndex as u8,
    SetIndex = NodeKind::SetIndex as u8,
    Call = NodeKind::Call as u8,
    CallObject = NodeKind::CallObject as u8,
    Infix = NodeKind::Infix as u8,
    Prefix = NodeKind::Prefix as u8,
    Array = NodeKind::Array as u8,
    Object = NodeKind::Object as u8,
    Int = NodeKind::Int as u8,
    Float32 = NodeKind::Float32 as u8,
    Float64 = NodeKind::Float64 as u8,
    Bool = NodeKind::Bool as u8,
    Str = NodeKind::Str as u8,
    Nil = NodeKind::Nil as u8,
}

impl Expr {
    #[inline]
    pub fn kind(&self) -> ExprKind {
        // SAFETY: `self` is a valid Stmt
        unsafe { core::mem::transmute(self.0.kind()) }
    }
}
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Stmt(Packed);

impl Sealed for Stmt {}

impl From<Stmt> for Packed {
    #[inline]
    fn from(v: Stmt) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Expr(Packed);

impl Sealed for Expr {}

impl From<Expr> for Packed {
    #[inline]
    fn from(v: Expr) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Root(Packed);

impl Sealed for Root {}

impl From<Root> for Packed {
    #[inline]
    fn from(v: Root) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Var(Packed);

impl Sealed for Var {}

impl From<Var> for Packed {
    #[inline]
    fn from(v: Var) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Loop(Packed);

impl Sealed for Loop {}

impl From<Loop> for Packed {
    #[inline]
    fn from(v: Loop) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct StmtExpr(Packed);

impl Sealed for StmtExpr {}

impl From<StmtExpr> for Packed {
    #[inline]
    fn from(v: StmtExpr) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct FuncDecl(Packed);

impl Sealed for FuncDecl {}

impl From<FuncDecl> for Packed {
    #[inline]
    fn from(v: FuncDecl) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Return(Packed);

impl Sealed for Return {}

impl From<Return> for Packed {
    #[inline]
    fn from(v: Return) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Break(Packed);

impl Sealed for Break {}

impl From<Break> for Packed {
    #[inline]
    fn from(v: Break) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Continue(Packed);

impl Sealed for Continue {}

impl From<Continue> for Packed {
    #[inline]
    fn from(v: Continue) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct IfSimple(Packed);

impl Sealed for IfSimple {}

impl From<IfSimple> for Packed {
    #[inline]
    fn from(v: IfSimple) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct IfMulti(Packed);

impl Sealed for IfMulti {}

impl From<IfMulti> for Packed {
    #[inline]
    fn from(v: IfMulti) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Block(Packed);

impl Sealed for Block {}

impl From<Block> for Packed {
    #[inline]
    fn from(v: Block) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct FuncAnon(Packed);

impl Sealed for FuncAnon {}

impl From<FuncAnon> for Packed {
    #[inline]
    fn from(v: FuncAnon) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct GetVar(Packed);

impl Sealed for GetVar {}

impl From<GetVar> for Packed {
    #[inline]
    fn from(v: GetVar) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct SetVar(Packed);

impl Sealed for SetVar {}

impl From<SetVar> for Packed {
    #[inline]
    fn from(v: SetVar) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct GetField(Packed);

impl Sealed for GetField {}

impl From<GetField> for Packed {
    #[inline]
    fn from(v: GetField) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct SetField(Packed);

impl Sealed for SetField {}

impl From<SetField> for Packed {
    #[inline]
    fn from(v: SetField) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct GetIndex(Packed);

impl Sealed for GetIndex {}

impl From<GetIndex> for Packed {
    #[inline]
    fn from(v: GetIndex) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct SetIndex(Packed);

impl Sealed for SetIndex {}

impl From<SetIndex> for Packed {
    #[inline]
    fn from(v: SetIndex) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Call(Packed);

impl Sealed for Call {}

impl From<Call> for Packed {
    #[inline]
    fn from(v: Call) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct CallObject(Packed);

impl Sealed for CallObject {}

impl From<CallObject> for Packed {
    #[inline]
    fn from(v: CallObject) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Infix(Packed);

impl Sealed for Infix {}

impl From<Infix> for Packed {
    #[inline]
    fn from(v: Infix) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Prefix(Packed);

impl Sealed for Prefix {}

impl From<Prefix> for Packed {
    #[inline]
    fn from(v: Prefix) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Array(Packed);

impl Sealed for Array {}

impl From<Array> for Packed {
    #[inline]
    fn from(v: Array) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Object(Packed);

impl Sealed for Object {}

impl From<Object> for Packed {
    #[inline]
    fn from(v: Object) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Int(Packed);

impl Sealed for Int {}

impl From<Int> for Packed {
    #[inline]
    fn from(v: Int) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Float32(Packed);

impl Sealed for Float32 {}

impl From<Float32> for Packed {
    #[inline]
    fn from(v: Float32) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Float64(Packed);

impl Sealed for Float64 {}

impl From<Float64> for Packed {
    #[inline]
    fn from(v: Float64) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Bool(Packed);

impl Sealed for Bool {}

impl From<Bool> for Packed {
    #[inline]
    fn from(v: Bool) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Str(Packed);

impl Sealed for Str {}

impl From<Str> for Packed {
    #[inline]
    fn from(v: Str) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Nil(Packed);

impl Sealed for Nil {}

impl From<Nil> for Packed {
    #[inline]
    fn from(v: Nil) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Branch(Packed);

impl Sealed for Branch {}

impl From<Branch> for Packed {
    #[inline]
    fn from(v: Branch) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct ObjectEntry(Packed);

impl Sealed for ObjectEntry {}

impl From<ObjectEntry> for Packed {
    #[inline]
    fn from(v: ObjectEntry) -> Self {
        PackedNode::into_packed(v)
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Ident(Packed);

impl Sealed for Ident {}

impl From<Ident> for Packed {
    #[inline]
    fn from(v: Ident) -> Self {
        PackedNode::into_packed(v)
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Stmt {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind >= NodeKind::Var && kind <= NodeKind::FuncDecl
    }
}

impl TryFrom<Packed> for Stmt {
    type Error = ();

    #[inline]
    fn try_from(v: Packed) -> Result<Self, Self::Error> {
        if <Self as PackedAbi>::check_kind(v.kind()) {
            Ok(unsafe { PackedNode::from_packed(v) })
        } else {
            Err(())
        }
    }
}
/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Expr {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind >= NodeKind::Return && kind <= NodeKind::Nil
    }
}

impl TryFrom<Packed> for Expr {
    type Error = ();

    #[inline]
    fn try_from(v: Packed) -> Result<Self, Self::Error> {
        if <Self as PackedAbi>::check_kind(v.kind()) {
            Ok(unsafe { PackedNode::from_packed(v) })
        } else {
            Err(())
        }
    }
}
impl TryFrom<Packed> for Root {
    type Error = ();

    #[inline]
    fn try_from(v: Packed) -> Result<Self, Self::Error> {
        if <Self as PackedAbi>::check_kind(v.kind()) {
            Ok(unsafe { PackedNode::from_packed(v) })
        } else {
            Err(())
        }
    }
}
/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Root {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Root
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Var {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Var
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Loop {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Loop
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for StmtExpr {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::StmtExpr
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for FuncDecl {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::FuncDecl
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Return {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Return
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Break {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Break
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Continue {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Continue
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for IfSimple {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::IfSimple
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for IfMulti {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::IfMulti
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Block {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Block
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for FuncAnon {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::FuncAnon
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for GetVar {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::GetVar
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for SetVar {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::SetVar
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for GetField {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::GetField
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for SetField {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::SetField
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for GetIndex {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::GetIndex
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for SetIndex {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::SetIndex
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Call {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Call
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for CallObject {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::CallObject
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Infix {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Infix
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Prefix {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Prefix
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Array {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Array
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Object {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Object
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Int {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Int
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Float32 {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Float32
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Float64 {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Float64
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Bool {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Bool
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Str {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Str
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Nil {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Nil
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Branch {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Branch
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for ObjectEntry {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::ObjectEntry
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Ident {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Ident
    }
}

impl From<Var> for Stmt {
    #[inline]
    fn from(v: Var) -> Self {
        Stmt(PackedNode::into_packed(v))
    }
}

impl TryFrom<Stmt> for Var {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Stmt) -> Result<Self, Self::Error> {
        if v.kind() != StmtKind::Var {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Loop> for Stmt {
    #[inline]
    fn from(v: Loop) -> Self {
        Stmt(PackedNode::into_packed(v))
    }
}

impl TryFrom<Stmt> for Loop {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Stmt) -> Result<Self, Self::Error> {
        if v.kind() != StmtKind::Loop {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<StmtExpr> for Stmt {
    #[inline]
    fn from(v: StmtExpr) -> Self {
        Stmt(PackedNode::into_packed(v))
    }
}

impl TryFrom<Stmt> for StmtExpr {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Stmt) -> Result<Self, Self::Error> {
        if v.kind() != StmtKind::StmtExpr {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<FuncDecl> for Stmt {
    #[inline]
    fn from(v: FuncDecl) -> Self {
        Stmt(PackedNode::into_packed(v))
    }
}

impl TryFrom<Stmt> for FuncDecl {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Stmt) -> Result<Self, Self::Error> {
        if v.kind() != StmtKind::FuncDecl {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Return> for Expr {
    #[inline]
    fn from(v: Return) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for Return {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::Return {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Break> for Expr {
    #[inline]
    fn from(v: Break) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for Break {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::Break {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Continue> for Expr {
    #[inline]
    fn from(v: Continue) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for Continue {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::Continue {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<IfSimple> for Expr {
    #[inline]
    fn from(v: IfSimple) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for IfSimple {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::IfSimple {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<IfMulti> for Expr {
    #[inline]
    fn from(v: IfMulti) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for IfMulti {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::IfMulti {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Block> for Expr {
    #[inline]
    fn from(v: Block) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for Block {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::Block {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<FuncAnon> for Expr {
    #[inline]
    fn from(v: FuncAnon) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for FuncAnon {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::FuncAnon {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<GetVar> for Expr {
    #[inline]
    fn from(v: GetVar) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for GetVar {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::GetVar {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<SetVar> for Expr {
    #[inline]
    fn from(v: SetVar) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for SetVar {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::SetVar {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<GetField> for Expr {
    #[inline]
    fn from(v: GetField) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for GetField {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::GetField {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<SetField> for Expr {
    #[inline]
    fn from(v: SetField) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for SetField {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::SetField {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<GetIndex> for Expr {
    #[inline]
    fn from(v: GetIndex) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for GetIndex {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::GetIndex {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<SetIndex> for Expr {
    #[inline]
    fn from(v: SetIndex) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for SetIndex {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::SetIndex {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Call> for Expr {
    #[inline]
    fn from(v: Call) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for Call {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::Call {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<CallObject> for Expr {
    #[inline]
    fn from(v: CallObject) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for CallObject {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::CallObject {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Infix> for Expr {
    #[inline]
    fn from(v: Infix) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for Infix {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::Infix {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Prefix> for Expr {
    #[inline]
    fn from(v: Prefix) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for Prefix {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::Prefix {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Array> for Expr {
    #[inline]
    fn from(v: Array) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for Array {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::Array {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Object> for Expr {
    #[inline]
    fn from(v: Object) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for Object {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::Object {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Int> for Expr {
    #[inline]
    fn from(v: Int) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for Int {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::Int {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Float32> for Expr {
    #[inline]
    fn from(v: Float32) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for Float32 {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::Float32 {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Float64> for Expr {
    #[inline]
    fn from(v: Float64) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for Float64 {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::Float64 {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Bool> for Expr {
    #[inline]
    fn from(v: Bool) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for Bool {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::Bool {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Str> for Expr {
    #[inline]
    fn from(v: Str) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for Str {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::Str {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Nil> for Expr {
    #[inline]
    fn from(v: Nil) -> Self {
        Expr(PackedNode::into_packed(v))
    }
}

impl TryFrom<Expr> for Nil {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if v.kind() != ExprKind::Nil {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

pub mod parts {
    use super::Opt;
    pub enum Stmt {
        Var(super::Var),
        Loop(super::Loop),
        StmtExpr(super::StmtExpr),
        FuncDecl(super::FuncDecl),
    }
    pub enum Expr {
        Return(super::Return),
        Break(super::Break),
        Continue(super::Continue),
        IfSimple(super::IfSimple),
        IfMulti(super::IfMulti),
        Block(super::Block),
        FuncAnon(super::FuncAnon),
        GetVar(super::GetVar),
        SetVar(super::SetVar),
        GetField(super::GetField),
        SetField(super::SetField),
        GetIndex(super::GetIndex),
        SetIndex(super::SetIndex),
        Call(super::Call),
        CallObject(super::CallObject),
        Infix(super::Infix),
        Prefix(super::Prefix),
        Array(super::Array),
        Object(super::Object),
        Int(super::Int),
        Float32(super::Float32),
        Float64(super::Float64),
        Bool(super::Bool),
        Str(super::Str),
        Nil(super::Nil),
    }
    pub struct Root<'a> {
        pub body: &'a [super::Stmt],
    }
    pub struct Var {
        pub name: super::Ident,
        pub value: super::Expr,
    }
    pub struct Loop<'a> {
        pub body: &'a [super::Stmt],
    }
    pub struct StmtExpr {
        pub inner: super::Expr,
    }
    pub struct FuncDecl<'a> {
        pub name: super::Ident,
        pub body: super::Block,
        pub params: &'a [super::Ident],
    }
    pub struct Return {
        pub value: Opt<super::Expr>,
    }
    pub struct Break {}
    pub struct Continue {}
    pub struct IfSimple<'a> {
        pub cond: super::Expr,
        pub tail: Opt<super::Block>,
        pub body: &'a [super::Stmt],
    }
    pub struct IfMulti<'a> {
        pub tail: Opt<super::Block>,
        pub branches: &'a [super::Branch],
    }
    pub struct Block<'a> {
        pub body: &'a [super::Stmt],
    }
    pub struct FuncAnon<'a> {
        pub name: Opt<super::Ident>,
        pub body: super::Block,
        pub params: &'a [super::Ident],
    }
    pub struct GetVar {
        pub name: super::Ident,
    }
    pub struct SetVar {
        pub base: super::GetVar,
        pub value: super::Expr,
        pub op: super::AssignOp,
    }
    pub struct GetField {
        pub parent: super::Expr,
        pub key: super::Ident,
    }
    pub struct SetField {
        pub base: super::GetField,
        pub value: super::Expr,
        pub op: super::AssignOp,
    }
    pub struct GetIndex {
        pub parent: super::Expr,
        pub key: super::Expr,
    }
    pub struct SetIndex {
        pub base: super::GetIndex,
        pub value: super::Expr,
        pub op: super::AssignOp,
    }
    pub struct Call<'a> {
        pub callee: super::Expr,
        pub args: &'a [super::Expr],
    }
    pub struct CallObject<'a> {
        pub callee: super::Expr,
        pub args: &'a [super::ObjectEntry],
    }
    pub struct Infix {
        pub lhs: super::Expr,
        pub rhs: super::Expr,
        pub op: super::InfixOp,
    }
    pub struct Prefix {
        pub rhs: super::Expr,
        pub op: super::PrefixOp,
    }
    pub struct Array<'a> {
        pub items: &'a [super::Expr],
    }
    pub struct Object<'a> {
        pub entries: &'a [super::ObjectEntry],
    }
    pub struct Int {
        pub value: super::u56,
    }
    pub struct Float32 {
        pub value: f32,
    }
    pub struct Float64 {
        pub value: super::FloatId,
    }
    pub struct Bool {
        pub value: bool,
    }
    pub struct Str {
        pub value: super::StrId,
    }
    pub struct Nil {}
    pub struct Branch<'a> {
        pub cond: super::Expr,
        pub body: &'a [super::Stmt],
    }
    pub struct ObjectEntry {
        pub key: super::Str,
        pub value: super::Expr,
    }
    pub struct Ident {
        pub id: super::IdentId,
    }
}

pub mod spanned {
    use super::{Opt, Spanned};
    pub struct Root<'a> {
        pub body: &'a [Spanned<super::Stmt>],
    }
    pub struct Var {
        pub name: Spanned<super::Ident>,
        pub value: Spanned<super::Expr>,
    }
    pub struct Loop<'a> {
        pub body: &'a [Spanned<super::Stmt>],
    }
    pub struct StmtExpr {
        pub inner: Spanned<super::Expr>,
    }
    pub struct FuncDecl<'a> {
        pub name: Spanned<super::Ident>,
        pub body: Spanned<super::Block>,
        pub params: &'a [Spanned<super::Ident>],
    }
    pub struct Return {
        pub value: Spanned<Opt<super::Expr>>,
    }
    pub struct Break {}
    pub struct Continue {}
    pub struct IfSimple<'a> {
        pub cond: Spanned<super::Expr>,
        pub tail: Spanned<Opt<super::Block>>,
        pub body: &'a [Spanned<super::Stmt>],
    }
    pub struct IfMulti<'a> {
        pub tail: Spanned<Opt<super::Block>>,
        pub branches: &'a [Spanned<super::Branch>],
    }
    pub struct Block<'a> {
        pub body: &'a [Spanned<super::Stmt>],
    }
    pub struct FuncAnon<'a> {
        pub name: Spanned<Opt<super::Ident>>,
        pub body: Spanned<super::Block>,
        pub params: &'a [Spanned<super::Ident>],
    }
    pub struct GetVar {
        pub name: Spanned<super::Ident>,
    }
    pub struct SetVar {
        pub base: Spanned<super::GetVar>,
        pub value: Spanned<super::Expr>,
        pub op: super::AssignOp,
    }
    pub struct GetField {
        pub parent: Spanned<super::Expr>,
        pub key: Spanned<super::Ident>,
    }
    pub struct SetField {
        pub base: Spanned<super::GetField>,
        pub value: Spanned<super::Expr>,
        pub op: super::AssignOp,
    }
    pub struct GetIndex {
        pub parent: Spanned<super::Expr>,
        pub key: Spanned<super::Expr>,
    }
    pub struct SetIndex {
        pub base: Spanned<super::GetIndex>,
        pub value: Spanned<super::Expr>,
        pub op: super::AssignOp,
    }
    pub struct Call<'a> {
        pub callee: Spanned<super::Expr>,
        pub args: &'a [Spanned<super::Expr>],
    }
    pub struct CallObject<'a> {
        pub callee: Spanned<super::Expr>,
        pub args: &'a [Spanned<super::ObjectEntry>],
    }
    pub struct Infix {
        pub lhs: Spanned<super::Expr>,
        pub rhs: Spanned<super::Expr>,
        pub op: super::InfixOp,
    }
    pub struct Prefix {
        pub rhs: Spanned<super::Expr>,
        pub op: super::PrefixOp,
    }
    pub struct Array<'a> {
        pub items: &'a [Spanned<super::Expr>],
    }
    pub struct Object<'a> {
        pub entries: &'a [Spanned<super::ObjectEntry>],
    }
    pub struct Int {
        pub value: super::u56,
    }
    pub struct Float32 {
        pub value: f32,
    }
    pub struct Float64 {
        pub value: super::FloatId,
    }
    pub struct Bool {
        pub value: bool,
    }
    pub struct Str {
        pub value: super::StrId,
    }
    pub struct Nil {}
    pub struct Branch<'a> {
        pub cond: Spanned<super::Expr>,
        pub body: &'a [Spanned<super::Stmt>],
    }
    pub struct ObjectEntry {
        pub key: Spanned<super::Str>,
        pub value: Spanned<super::Expr>,
    }
    pub struct Ident {
        pub id: super::IdentId,
    }
}

impl<'a> Pack for spanned::Root<'a> {
    type Node = Root;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { body } = self;
        let length = body.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let body = <_>::into_spanned_packed_slice(body);
        let index = ast.append(body);
        unsafe { Self::Node::from_packed(Packed::variable_arity(NodeKind::Root, length, index)) }
    }
}

impl Pack for spanned::Var {
    type Node = Var;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { name, value } = self;
        let name = <_>::into_spanned_packed(name);
        let value = <_>::into_spanned_packed(value);
        let index = ast.append(&[name, value]);
        unsafe { Self::Node::from_packed(Packed::fixed_arity(NodeKind::Var, index)) }
    }
}

impl<'a> Pack for spanned::Loop<'a> {
    type Node = Loop;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { body } = self;
        let length = body.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let body = <_>::into_spanned_packed_slice(body);
        let index = ast.append(body);
        unsafe { Self::Node::from_packed(Packed::variable_arity(NodeKind::Loop, length, index)) }
    }
}

impl Pack for spanned::StmtExpr {
    type Node = StmtExpr;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { inner } = self;
        let inner = <_>::into_spanned_packed(inner);
        let index = ast.append(&[inner]);
        unsafe { Self::Node::from_packed(Packed::fixed_arity(NodeKind::StmtExpr, index)) }
    }
}

impl<'a> Pack for spanned::FuncDecl<'a> {
    type Node = FuncDecl;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { name, body, params } = self;
        let name = <_>::into_spanned_packed(name);
        let body = <_>::into_spanned_packed(body);
        let index = ast.append(&[name, body]);

        let length = params.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let params = <_>::into_spanned_packed_slice(params);
        let _ = ast.append(params);

        unsafe { Self::Node::from_packed(Packed::mixed_arity(NodeKind::FuncDecl, length, index)) }
    }
}

impl Pack for spanned::Return {
    type Node = Return;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { value } = self;
        let value = <_>::into_spanned_packed(value);
        let index = ast.append(&[value]);
        unsafe { Self::Node::from_packed(Packed::fixed_arity(NodeKind::Return, index)) }
    }
}

impl Pack for spanned::Break {
    type Node = Break;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = (self, ast);
        unsafe { Self::Node::from_packed(Packed::kind_only(NodeKind::Break)) }
    }
}

impl Pack for spanned::Continue {
    type Node = Continue;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = (self, ast);
        unsafe { Self::Node::from_packed(Packed::kind_only(NodeKind::Continue)) }
    }
}

impl<'a> Pack for spanned::IfSimple<'a> {
    type Node = IfSimple;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { cond, tail, body } = self;
        let cond = <_>::into_spanned_packed(cond);
        let tail = <_>::into_spanned_packed(tail);
        let index = ast.append(&[cond, tail]);

        let length = body.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let body = <_>::into_spanned_packed_slice(body);
        let _ = ast.append(body);

        unsafe { Self::Node::from_packed(Packed::mixed_arity(NodeKind::IfSimple, length, index)) }
    }
}

impl<'a> Pack for spanned::IfMulti<'a> {
    type Node = IfMulti;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { tail, branches } = self;
        let tail = <_>::into_spanned_packed(tail);
        let index = ast.append(&[tail]);

        let length = branches.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let branches = <_>::into_spanned_packed_slice(branches);
        let _ = ast.append(branches);

        unsafe { Self::Node::from_packed(Packed::mixed_arity(NodeKind::IfMulti, length, index)) }
    }
}

impl<'a> Pack for spanned::Block<'a> {
    type Node = Block;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { body } = self;
        let length = body.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let body = <_>::into_spanned_packed_slice(body);
        let index = ast.append(body);
        unsafe { Self::Node::from_packed(Packed::variable_arity(NodeKind::Block, length, index)) }
    }
}

impl<'a> Pack for spanned::FuncAnon<'a> {
    type Node = FuncAnon;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { name, body, params } = self;
        let name = <_>::into_spanned_packed(name);
        let body = <_>::into_spanned_packed(body);
        let index = ast.append(&[name, body]);

        let length = params.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let params = <_>::into_spanned_packed_slice(params);
        let _ = ast.append(params);

        unsafe { Self::Node::from_packed(Packed::mixed_arity(NodeKind::FuncAnon, length, index)) }
    }
}

impl Pack for spanned::GetVar {
    type Node = GetVar;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { name } = self;
        let name = <_>::into_spanned_packed(name);
        let index = ast.append(&[name]);
        unsafe { Self::Node::from_packed(Packed::fixed_arity(NodeKind::GetVar, index)) }
    }
}

impl Pack for spanned::SetVar {
    type Node = SetVar;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { op, base, value } = self;
        let base = <_>::into_spanned_packed(base);
        let value = <_>::into_spanned_packed(value);
        let index = ast.append(&[base, value]);
        let op: u24 = op.into_u24();
        unsafe { Self::Node::from_packed(Packed::fixed_arity_inline(NodeKind::SetVar, op, index)) }
    }
}

impl Pack for spanned::GetField {
    type Node = GetField;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { parent, key } = self;
        let parent = <_>::into_spanned_packed(parent);
        let key = <_>::into_spanned_packed(key);
        let index = ast.append(&[parent, key]);
        unsafe { Self::Node::from_packed(Packed::fixed_arity(NodeKind::GetField, index)) }
    }
}

impl Pack for spanned::SetField {
    type Node = SetField;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { op, base, value } = self;
        let base = <_>::into_spanned_packed(base);
        let value = <_>::into_spanned_packed(value);
        let index = ast.append(&[base, value]);
        let op: u24 = op.into_u24();
        unsafe {
            Self::Node::from_packed(Packed::fixed_arity_inline(NodeKind::SetField, op, index))
        }
    }
}

impl Pack for spanned::GetIndex {
    type Node = GetIndex;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { parent, key } = self;
        let parent = <_>::into_spanned_packed(parent);
        let key = <_>::into_spanned_packed(key);
        let index = ast.append(&[parent, key]);
        unsafe { Self::Node::from_packed(Packed::fixed_arity(NodeKind::GetIndex, index)) }
    }
}

impl Pack for spanned::SetIndex {
    type Node = SetIndex;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { op, base, value } = self;
        let base = <_>::into_spanned_packed(base);
        let value = <_>::into_spanned_packed(value);
        let index = ast.append(&[base, value]);
        let op: u24 = op.into_u24();
        unsafe {
            Self::Node::from_packed(Packed::fixed_arity_inline(NodeKind::SetIndex, op, index))
        }
    }
}

impl<'a> Pack for spanned::Call<'a> {
    type Node = Call;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { callee, args } = self;
        let callee = <_>::into_spanned_packed(callee);
        let index = ast.append(&[callee]);

        let length = args.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let args = <_>::into_spanned_packed_slice(args);
        let _ = ast.append(args);

        unsafe { Self::Node::from_packed(Packed::mixed_arity(NodeKind::Call, length, index)) }
    }
}

impl<'a> Pack for spanned::CallObject<'a> {
    type Node = CallObject;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { callee, args } = self;
        let callee = <_>::into_spanned_packed(callee);
        let index = ast.append(&[callee]);

        let length = args.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let args = <_>::into_spanned_packed_slice(args);
        let _ = ast.append(args);

        unsafe { Self::Node::from_packed(Packed::mixed_arity(NodeKind::CallObject, length, index)) }
    }
}

impl Pack for spanned::Infix {
    type Node = Infix;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { op, lhs, rhs } = self;
        let lhs = <_>::into_spanned_packed(lhs);
        let rhs = <_>::into_spanned_packed(rhs);
        let index = ast.append(&[lhs, rhs]);
        let op: u24 = op.into_u24();
        unsafe { Self::Node::from_packed(Packed::fixed_arity_inline(NodeKind::Infix, op, index)) }
    }
}

impl Pack for spanned::Prefix {
    type Node = Prefix;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { op, rhs } = self;
        let rhs = <_>::into_spanned_packed(rhs);
        let index = ast.append(&[rhs]);
        let op: u24 = op.into_u24();
        unsafe { Self::Node::from_packed(Packed::fixed_arity_inline(NodeKind::Prefix, op, index)) }
    }
}

impl<'a> Pack for spanned::Array<'a> {
    type Node = Array;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { items } = self;
        let length = items.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let items = <_>::into_spanned_packed_slice(items);
        let index = ast.append(items);
        unsafe { Self::Node::from_packed(Packed::variable_arity(NodeKind::Array, length, index)) }
    }
}

impl<'a> Pack for spanned::Object<'a> {
    type Node = Object;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { entries } = self;
        let length = entries.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let entries = <_>::into_spanned_packed_slice(entries);
        let index = ast.append(entries);
        unsafe { Self::Node::from_packed(Packed::variable_arity(NodeKind::Object, length, index)) }
    }
}

impl Pack for spanned::Int {
    type Node = Int;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = ast;
        let Self { value } = self;
        let value: u56 = value.into_u56();
        unsafe { Self::Node::from_packed(Packed::inline(NodeKind::Int, value)) }
    }
}

impl Pack for spanned::Float32 {
    type Node = Float32;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = ast;
        let Self { value } = self;
        let value: u56 = value.into_u56();
        unsafe { Self::Node::from_packed(Packed::inline(NodeKind::Float32, value)) }
    }
}

impl Pack for spanned::Float64 {
    type Node = Float64;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = ast;
        let Self { value } = self;
        let value: u56 = value.into_u56();
        unsafe { Self::Node::from_packed(Packed::inline(NodeKind::Float64, value)) }
    }
}

impl Pack for spanned::Bool {
    type Node = Bool;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = ast;
        let Self { value } = self;
        let value: u56 = value.into_u56();
        unsafe { Self::Node::from_packed(Packed::inline(NodeKind::Bool, value)) }
    }
}

impl Pack for spanned::Str {
    type Node = Str;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = ast;
        let Self { value } = self;
        let value: u56 = value.into_u56();
        unsafe { Self::Node::from_packed(Packed::inline(NodeKind::Str, value)) }
    }
}

impl Pack for spanned::Nil {
    type Node = Nil;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = (self, ast);
        unsafe { Self::Node::from_packed(Packed::kind_only(NodeKind::Nil)) }
    }
}

impl<'a> Pack for spanned::Branch<'a> {
    type Node = Branch;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { cond, body } = self;
        let cond = <_>::into_spanned_packed(cond);
        let index = ast.append(&[cond]);

        let length = body.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let body = <_>::into_spanned_packed_slice(body);
        let _ = ast.append(body);

        unsafe { Self::Node::from_packed(Packed::mixed_arity(NodeKind::Branch, length, index)) }
    }
}

impl Pack for spanned::ObjectEntry {
    type Node = ObjectEntry;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { key, value } = self;
        let key = <_>::into_spanned_packed(key);
        let value = <_>::into_spanned_packed(value);
        let index = ast.append(&[key, value]);
        unsafe { Self::Node::from_packed(Packed::fixed_arity(NodeKind::ObjectEntry, index)) }
    }
}

impl Pack for spanned::Ident {
    type Node = Ident;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = ast;
        let Self { id } = self;
        let id: u56 = id.into_u56();
        unsafe { Self::Node::from_packed(Packed::inline(NodeKind::Ident, id)) }
    }
}

impl Unpack for Stmt {
    type Node<'a> = parts::Stmt;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        match self.kind() {
            StmtKind::Var => parts::Stmt::Var(unsafe { PackedNode::from_packed(self.0) }),
            StmtKind::Loop => parts::Stmt::Loop(unsafe { PackedNode::from_packed(self.0) }),
            StmtKind::StmtExpr => parts::Stmt::StmtExpr(unsafe { PackedNode::from_packed(self.0) }),
            StmtKind::FuncDecl => parts::Stmt::FuncDecl(unsafe { PackedNode::from_packed(self.0) }),
        }
    }
}
impl Unpack for Expr {
    type Node<'a> = parts::Expr;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        match self.kind() {
            ExprKind::Return => parts::Expr::Return(unsafe { PackedNode::from_packed(self.0) }),
            ExprKind::Break => parts::Expr::Break(unsafe { PackedNode::from_packed(self.0) }),
            ExprKind::Continue => parts::Expr::Continue(unsafe { PackedNode::from_packed(self.0) }),
            ExprKind::IfSimple => parts::Expr::IfSimple(unsafe { PackedNode::from_packed(self.0) }),
            ExprKind::IfMulti => parts::Expr::IfMulti(unsafe { PackedNode::from_packed(self.0) }),
            ExprKind::Block => parts::Expr::Block(unsafe { PackedNode::from_packed(self.0) }),
            ExprKind::FuncAnon => parts::Expr::FuncAnon(unsafe { PackedNode::from_packed(self.0) }),
            ExprKind::GetVar => parts::Expr::GetVar(unsafe { PackedNode::from_packed(self.0) }),
            ExprKind::SetVar => parts::Expr::SetVar(unsafe { PackedNode::from_packed(self.0) }),
            ExprKind::GetField => parts::Expr::GetField(unsafe { PackedNode::from_packed(self.0) }),
            ExprKind::SetField => parts::Expr::SetField(unsafe { PackedNode::from_packed(self.0) }),
            ExprKind::GetIndex => parts::Expr::GetIndex(unsafe { PackedNode::from_packed(self.0) }),
            ExprKind::SetIndex => parts::Expr::SetIndex(unsafe { PackedNode::from_packed(self.0) }),
            ExprKind::Call => parts::Expr::Call(unsafe { PackedNode::from_packed(self.0) }),
            ExprKind::CallObject => {
                parts::Expr::CallObject(unsafe { PackedNode::from_packed(self.0) })
            }
            ExprKind::Infix => parts::Expr::Infix(unsafe { PackedNode::from_packed(self.0) }),
            ExprKind::Prefix => parts::Expr::Prefix(unsafe { PackedNode::from_packed(self.0) }),
            ExprKind::Array => parts::Expr::Array(unsafe { PackedNode::from_packed(self.0) }),
            ExprKind::Object => parts::Expr::Object(unsafe { PackedNode::from_packed(self.0) }),
            ExprKind::Int => parts::Expr::Int(unsafe { PackedNode::from_packed(self.0) }),
            ExprKind::Float32 => parts::Expr::Float32(unsafe { PackedNode::from_packed(self.0) }),
            ExprKind::Float64 => parts::Expr::Float64(unsafe { PackedNode::from_packed(self.0) }),
            ExprKind::Bool => parts::Expr::Bool(unsafe { PackedNode::from_packed(self.0) }),
            ExprKind::Str => parts::Expr::Str(unsafe { PackedNode::from_packed(self.0) }),
            ExprKind::Nil => parts::Expr::Nil(unsafe { PackedNode::from_packed(self.0) }),
        }
    }
}
impl Unpack for Root {
    type Node<'a> = parts::Root<'a>;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        let repr = unsafe { self.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + length) };
        let body: &[_] = unsafe { <_>::from_packed_slice(raw) };
        Self::Node { body }
    }
}

impl Unpack for Var {
    type Node<'a> = parts::Var;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        const N: usize = 2;
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + N) };
        let name = unsafe { <_>::from_packed(*raw.get_unchecked(0)) };
        let value = unsafe { <_>::from_packed(*raw.get_unchecked(1)) };
        Self::Node { name, value }
    }
}

impl Unpack for Loop {
    type Node<'a> = parts::Loop<'a>;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        let repr = unsafe { self.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + length) };
        let body: &[_] = unsafe { <_>::from_packed_slice(raw) };
        Self::Node { body }
    }
}

impl Unpack for StmtExpr {
    type Node<'a> = parts::StmtExpr;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        const N: usize = 1;
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + N) };
        let inner = unsafe { <_>::from_packed(*raw.get_unchecked(0)) };
        Self::Node { inner }
    }
}

impl Unpack for FuncDecl {
    type Node<'a> = parts::FuncDecl<'a>;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        const N: usize = 2;
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + N + tail_length) };
        let name = unsafe { <_>::from_packed(*raw.get_unchecked(0)) };
        let body = unsafe { <_>::from_packed(*raw.get_unchecked(1)) };
        let params: &[_] = unsafe { <_>::from_packed_slice(raw.get_unchecked(N..)) };
        Self::Node { name, body, params }
    }
}

impl Unpack for Return {
    type Node<'a> = parts::Return;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        const N: usize = 1;
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + N) };
        let value = unsafe { <_>::from_packed(*raw.get_unchecked(0)) };
        Self::Node { value }
    }
}

impl Unpack for Break {
    type Node<'a> = parts::Break;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        let _ = unsafe { self.0.as_kind_only() };
        let _ = ast;
        Self::Node {}
    }
}

impl Unpack for Continue {
    type Node<'a> = parts::Continue;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        let _ = unsafe { self.0.as_kind_only() };
        let _ = ast;
        Self::Node {}
    }
}

impl Unpack for IfSimple {
    type Node<'a> = parts::IfSimple<'a>;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        const N: usize = 2;
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + N + tail_length) };
        let cond = unsafe { <_>::from_packed(*raw.get_unchecked(0)) };
        let tail = unsafe { <_>::from_packed(*raw.get_unchecked(1)) };
        let body: &[_] = unsafe { <_>::from_packed_slice(raw.get_unchecked(N..)) };
        Self::Node { cond, tail, body }
    }
}

impl Unpack for IfMulti {
    type Node<'a> = parts::IfMulti<'a>;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        const N: usize = 1;
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + N + tail_length) };
        let tail = unsafe { <_>::from_packed(*raw.get_unchecked(0)) };
        let branches: &[_] = unsafe { <_>::from_packed_slice(raw.get_unchecked(N..)) };
        Self::Node { tail, branches }
    }
}

impl Unpack for Block {
    type Node<'a> = parts::Block<'a>;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        let repr = unsafe { self.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + length) };
        let body: &[_] = unsafe { <_>::from_packed_slice(raw) };
        Self::Node { body }
    }
}

impl Unpack for FuncAnon {
    type Node<'a> = parts::FuncAnon<'a>;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        const N: usize = 2;
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + N + tail_length) };
        let name = unsafe { <_>::from_packed(*raw.get_unchecked(0)) };
        let body = unsafe { <_>::from_packed(*raw.get_unchecked(1)) };
        let params: &[_] = unsafe { <_>::from_packed_slice(raw.get_unchecked(N..)) };
        Self::Node { name, body, params }
    }
}

impl Unpack for GetVar {
    type Node<'a> = parts::GetVar;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        const N: usize = 1;
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + N) };
        let name = unsafe { <_>::from_packed(*raw.get_unchecked(0)) };
        Self::Node { name }
    }
}

impl Unpack for SetVar {
    type Node<'a> = parts::SetVar;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        const N: usize = 2;
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + N) };
        let base = unsafe { <_>::from_packed(*raw.get_unchecked(0)) };
        let value = unsafe { <_>::from_packed(*raw.get_unchecked(1)) };
        let op = <AssignOp>::from_u24(repr.value);
        Self::Node { base, value, op }
    }
}

impl Unpack for GetField {
    type Node<'a> = parts::GetField;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        const N: usize = 2;
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + N) };
        let parent = unsafe { <_>::from_packed(*raw.get_unchecked(0)) };
        let key = unsafe { <_>::from_packed(*raw.get_unchecked(1)) };
        Self::Node { parent, key }
    }
}

impl Unpack for SetField {
    type Node<'a> = parts::SetField;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        const N: usize = 2;
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + N) };
        let base = unsafe { <_>::from_packed(*raw.get_unchecked(0)) };
        let value = unsafe { <_>::from_packed(*raw.get_unchecked(1)) };
        let op = <AssignOp>::from_u24(repr.value);
        Self::Node { base, value, op }
    }
}

impl Unpack for GetIndex {
    type Node<'a> = parts::GetIndex;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        const N: usize = 2;
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + N) };
        let parent = unsafe { <_>::from_packed(*raw.get_unchecked(0)) };
        let key = unsafe { <_>::from_packed(*raw.get_unchecked(1)) };
        Self::Node { parent, key }
    }
}

impl Unpack for SetIndex {
    type Node<'a> = parts::SetIndex;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        const N: usize = 2;
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + N) };
        let base = unsafe { <_>::from_packed(*raw.get_unchecked(0)) };
        let value = unsafe { <_>::from_packed(*raw.get_unchecked(1)) };
        let op = <AssignOp>::from_u24(repr.value);
        Self::Node { base, value, op }
    }
}

impl Unpack for Call {
    type Node<'a> = parts::Call<'a>;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        const N: usize = 1;
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + N + tail_length) };
        let callee = unsafe { <_>::from_packed(*raw.get_unchecked(0)) };
        let args: &[_] = unsafe { <_>::from_packed_slice(raw.get_unchecked(N..)) };
        Self::Node { callee, args }
    }
}

impl Unpack for CallObject {
    type Node<'a> = parts::CallObject<'a>;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        const N: usize = 1;
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + N + tail_length) };
        let callee = unsafe { <_>::from_packed(*raw.get_unchecked(0)) };
        let args: &[_] = unsafe { <_>::from_packed_slice(raw.get_unchecked(N..)) };
        Self::Node { callee, args }
    }
}

impl Unpack for Infix {
    type Node<'a> = parts::Infix;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        const N: usize = 2;
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + N) };
        let lhs = unsafe { <_>::from_packed(*raw.get_unchecked(0)) };
        let rhs = unsafe { <_>::from_packed(*raw.get_unchecked(1)) };
        let op = <InfixOp>::from_u24(repr.value);
        Self::Node { lhs, rhs, op }
    }
}

impl Unpack for Prefix {
    type Node<'a> = parts::Prefix;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        const N: usize = 1;
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + N) };
        let rhs = unsafe { <_>::from_packed(*raw.get_unchecked(0)) };
        let op = <PrefixOp>::from_u24(repr.value);
        Self::Node { rhs, op }
    }
}

impl Unpack for Array {
    type Node<'a> = parts::Array<'a>;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        let repr = unsafe { self.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + length) };
        let items: &[_] = unsafe { <_>::from_packed_slice(raw) };
        Self::Node { items }
    }
}

impl Unpack for Object {
    type Node<'a> = parts::Object<'a>;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        let repr = unsafe { self.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + length) };
        let entries: &[_] = unsafe { <_>::from_packed_slice(raw) };
        Self::Node { entries }
    }
}

impl Unpack for Int {
    type Node<'a> = parts::Int;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        let _ = ast;
        let repr = unsafe { self.0.as_inline() };
        let value = <u56>::from_u56(repr.value);
        Self::Node { value }
    }
}

impl Unpack for Float32 {
    type Node<'a> = parts::Float32;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        let _ = ast;
        let repr = unsafe { self.0.as_inline() };
        let value = <f32>::from_u56(repr.value);
        Self::Node { value }
    }
}

impl Unpack for Float64 {
    type Node<'a> = parts::Float64;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        let _ = ast;
        let repr = unsafe { self.0.as_inline() };
        let value = <FloatId>::from_u56(repr.value);
        Self::Node { value }
    }
}

impl Unpack for Bool {
    type Node<'a> = parts::Bool;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        let _ = ast;
        let repr = unsafe { self.0.as_inline() };
        let value = <bool>::from_u56(repr.value);
        Self::Node { value }
    }
}

impl Unpack for Str {
    type Node<'a> = parts::Str;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        let _ = ast;
        let repr = unsafe { self.0.as_inline() };
        let value = <StrId>::from_u56(repr.value);
        Self::Node { value }
    }
}

impl Unpack for Nil {
    type Node<'a> = parts::Nil;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        let _ = unsafe { self.0.as_kind_only() };
        let _ = ast;
        Self::Node {}
    }
}

impl Unpack for Branch {
    type Node<'a> = parts::Branch<'a>;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        const N: usize = 1;
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + N + tail_length) };
        let cond = unsafe { <_>::from_packed(*raw.get_unchecked(0)) };
        let body: &[_] = unsafe { <_>::from_packed_slice(raw.get_unchecked(N..)) };
        Self::Node { cond, body }
    }
}

impl Unpack for ObjectEntry {
    type Node<'a> = parts::ObjectEntry;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        const N: usize = 2;
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        let raw: &[Packed] = unsafe { ast.nodes.get_unchecked(index..index + N) };
        let key = unsafe { <_>::from_packed(*raw.get_unchecked(0)) };
        let value = unsafe { <_>::from_packed(*raw.get_unchecked(1)) };
        Self::Node { key, value }
    }
}

impl Unpack for Ident {
    type Node<'a> = parts::Ident;

    #[inline]
    unsafe fn unpack<'a>(self, ast: &'a Ast) -> Self::Node<'a> {
        let _ = ast;
        let repr = unsafe { self.0.as_inline() };
        let id = <IdentId>::from_u56(repr.value);
        Self::Node { id }
    }
}

impl Root {
    #[inline]
    pub fn body_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        &ast.spans[index..index + length]
    }
}

impl Var {
    #[inline]
    pub fn name_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn value_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 1]
    }
}

impl Loop {
    #[inline]
    pub fn body_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        &ast.spans[index..index + length]
    }
}

impl StmtExpr {
    #[inline]
    pub fn inner_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }
}

impl FuncDecl {
    #[inline]
    pub fn name_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn body_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 1]
    }

    #[inline]
    pub fn params_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = 2 + repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        &ast.spans[index..index + tail_length]
    }
}

impl Return {
    #[inline]
    pub fn value_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }
}

impl IfSimple {
    #[inline]
    pub fn cond_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn tail_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 1]
    }

    #[inline]
    pub fn body_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = 2 + repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        &ast.spans[index..index + tail_length]
    }
}

impl IfMulti {
    #[inline]
    pub fn tail_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn branches_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = 1 + repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        &ast.spans[index..index + tail_length]
    }
}

impl Block {
    #[inline]
    pub fn body_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        &ast.spans[index..index + length]
    }
}

impl FuncAnon {
    #[inline]
    pub fn name_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn body_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 1]
    }

    #[inline]
    pub fn params_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = 2 + repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        &ast.spans[index..index + tail_length]
    }
}

impl GetVar {
    #[inline]
    pub fn name_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }
}

impl SetVar {
    #[inline]
    pub fn base_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn value_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        ast.spans[index + 1]
    }
}

impl GetField {
    #[inline]
    pub fn parent_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn key_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 1]
    }
}

impl SetField {
    #[inline]
    pub fn base_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn value_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        ast.spans[index + 1]
    }
}

impl GetIndex {
    #[inline]
    pub fn parent_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn key_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 1]
    }
}

impl SetIndex {
    #[inline]
    pub fn base_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn value_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        ast.spans[index + 1]
    }
}

impl Call {
    #[inline]
    pub fn callee_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn args_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = 1 + repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        &ast.spans[index..index + tail_length]
    }
}

impl CallObject {
    #[inline]
    pub fn callee_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn args_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = 1 + repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        &ast.spans[index..index + tail_length]
    }
}

impl Infix {
    #[inline]
    pub fn lhs_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn rhs_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        ast.spans[index + 1]
    }
}

impl Prefix {
    #[inline]
    pub fn rhs_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }
}

impl Array {
    #[inline]
    pub fn items_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        &ast.spans[index..index + length]
    }
}

impl Object {
    #[inline]
    pub fn entries_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        &ast.spans[index..index + length]
    }
}

impl Branch {
    #[inline]
    pub fn cond_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn body_spans<'a>(&self, ast: &'a Ast) -> &'a [Span] {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = 1 + repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        &ast.spans[index..index + tail_length]
    }
}

impl ObjectEntry {
    #[inline]
    pub fn key_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 0]
    }

    #[inline]
    pub fn value_span(&self, ast: &Ast) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        ast.spans[index + 1]
    }
}

pub fn walk_stmt<V: ?Sized + Visitor>(
    visitor: &mut V,
    ast: &Ast,
    node: Stmt,
) -> Result<(), V::Error> {
    match node.kind() {
        StmtKind::Var => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_var(ast, node, unsafe { node.unpack(ast) })
        }

        StmtKind::Loop => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_loop(ast, node, unsafe { node.unpack(ast) })
        }

        StmtKind::StmtExpr => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_stmt_expr(ast, node, unsafe { node.unpack(ast) })
        }

        StmtKind::FuncDecl => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_func_decl(ast, node, unsafe { node.unpack(ast) })
        }
    }
}

pub fn walk_expr<V: ?Sized + Visitor>(
    visitor: &mut V,
    ast: &Ast,
    node: Expr,
) -> Result<(), V::Error> {
    match node.kind() {
        ExprKind::Return => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_return(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::Break => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_break(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::Continue => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_continue(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::IfSimple => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_if_simple(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::IfMulti => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_if_multi(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::Block => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_block(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::FuncAnon => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_func_anon(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::GetVar => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_get_var(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::SetVar => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_set_var(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::GetField => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_get_field(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::SetField => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_set_field(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::GetIndex => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_get_index(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::SetIndex => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_set_index(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::Call => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_call(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::CallObject => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_call_object(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::Infix => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_infix(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::Prefix => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_prefix(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::Array => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_array(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::Object => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_object(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::Int => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_int(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::Float32 => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_float32(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::Float64 => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_float64(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::Bool => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_bool(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::Str => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_str(ast, node, unsafe { node.unpack(ast) })
        }

        ExprKind::Nil => {
            let node = unsafe { <_>::from_packed(node.0) };
            visitor.visit_nil(ast, node, unsafe { node.unpack(ast) })
        }
    }
}

pub trait Visitor {
    type Error;

    fn visit_root(&mut self, ast: &Ast, node: Root) -> std::result::Result<(), Self::Error> {
        let parts = unsafe { node.unpack(ast) };
        for node in parts.body {
            self.visit_stmt(ast, *node)?;
        }

        Ok(())
    }

    fn visit_stmt(&mut self, ast: &Ast, node: Stmt) -> std::result::Result<(), Self::Error> {
        walk_stmt(self, ast, node)
    }

    #[allow(unused_variables)]
    fn visit_var(
        &mut self,
        ast: &Ast,
        node: Var,
        parts: parts::Var,
    ) -> std::result::Result<(), Self::Error> {
        let node = parts.value;
        self.visit_expr(ast, node)?;

        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_loop(
        &mut self,
        ast: &Ast,
        node: Loop,
        parts: parts::Loop<'_>,
    ) -> std::result::Result<(), Self::Error> {
        for node in parts.body {
            self.visit_stmt(ast, *node)?;
        }

        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_stmt_expr(
        &mut self,
        ast: &Ast,
        node: StmtExpr,
        parts: parts::StmtExpr,
    ) -> std::result::Result<(), Self::Error> {
        let node = parts.inner;
        self.visit_expr(ast, node)?;

        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_func_decl(
        &mut self,
        ast: &Ast,
        node: FuncDecl,
        parts: parts::FuncDecl<'_>,
    ) -> std::result::Result<(), Self::Error> {
        let node = parts.body;
        self.visit_block(ast, node, unsafe { node.unpack(ast) })?;

        Ok(())
    }

    fn visit_expr(&mut self, ast: &Ast, node: Expr) -> std::result::Result<(), Self::Error> {
        walk_expr(self, ast, node)
    }

    #[allow(unused_variables)]
    fn visit_return(
        &mut self,
        ast: &Ast,
        node: Return,
        parts: parts::Return,
    ) -> std::result::Result<(), Self::Error> {
        if let Some(node) = parts.value.into() {
            self.visit_expr(ast, node)?;
        }

        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_break(
        &mut self,
        ast: &Ast,
        node: Break,
        parts: parts::Break,
    ) -> std::result::Result<(), Self::Error> {
        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_continue(
        &mut self,
        ast: &Ast,
        node: Continue,
        parts: parts::Continue,
    ) -> std::result::Result<(), Self::Error> {
        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_if_simple(
        &mut self,
        ast: &Ast,
        node: IfSimple,
        parts: parts::IfSimple<'_>,
    ) -> std::result::Result<(), Self::Error> {
        let node = parts.cond;
        self.visit_expr(ast, node)?;
        if let Some(node) = parts.tail.into() {
            self.visit_block(ast, node, unsafe { node.unpack(ast) })?;
        }
        for node in parts.body {
            self.visit_stmt(ast, *node)?;
        }

        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_if_multi(
        &mut self,
        ast: &Ast,
        node: IfMulti,
        parts: parts::IfMulti<'_>,
    ) -> std::result::Result<(), Self::Error> {
        if let Some(node) = parts.tail.into() {
            self.visit_block(ast, node, unsafe { node.unpack(ast) })?;
        }

        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_block(
        &mut self,
        ast: &Ast,
        node: Block,
        parts: parts::Block<'_>,
    ) -> std::result::Result<(), Self::Error> {
        for node in parts.body {
            self.visit_stmt(ast, *node)?;
        }

        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_func_anon(
        &mut self,
        ast: &Ast,
        node: FuncAnon,
        parts: parts::FuncAnon<'_>,
    ) -> std::result::Result<(), Self::Error> {
        let node = parts.body;
        self.visit_block(ast, node, unsafe { node.unpack(ast) })?;

        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_get_var(
        &mut self,
        ast: &Ast,
        node: GetVar,
        parts: parts::GetVar,
    ) -> std::result::Result<(), Self::Error> {
        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_set_var(
        &mut self,
        ast: &Ast,
        node: SetVar,
        parts: parts::SetVar,
    ) -> std::result::Result<(), Self::Error> {
        let node = parts.base;
        self.visit_get_var(ast, node, unsafe { node.unpack(ast) })?;
        let node = parts.value;
        self.visit_expr(ast, node)?;

        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_get_field(
        &mut self,
        ast: &Ast,
        node: GetField,
        parts: parts::GetField,
    ) -> std::result::Result<(), Self::Error> {
        let node = parts.parent;
        self.visit_expr(ast, node)?;

        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_set_field(
        &mut self,
        ast: &Ast,
        node: SetField,
        parts: parts::SetField,
    ) -> std::result::Result<(), Self::Error> {
        let node = parts.base;
        self.visit_get_field(ast, node, unsafe { node.unpack(ast) })?;
        let node = parts.value;
        self.visit_expr(ast, node)?;

        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_get_index(
        &mut self,
        ast: &Ast,
        node: GetIndex,
        parts: parts::GetIndex,
    ) -> std::result::Result<(), Self::Error> {
        let node = parts.parent;
        self.visit_expr(ast, node)?;
        let node = parts.key;
        self.visit_expr(ast, node)?;

        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_set_index(
        &mut self,
        ast: &Ast,
        node: SetIndex,
        parts: parts::SetIndex,
    ) -> std::result::Result<(), Self::Error> {
        let node = parts.base;
        self.visit_get_index(ast, node, unsafe { node.unpack(ast) })?;
        let node = parts.value;
        self.visit_expr(ast, node)?;

        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_call(
        &mut self,
        ast: &Ast,
        node: Call,
        parts: parts::Call<'_>,
    ) -> std::result::Result<(), Self::Error> {
        let node = parts.callee;
        self.visit_expr(ast, node)?;
        for node in parts.args {
            self.visit_expr(ast, *node)?;
        }

        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_call_object(
        &mut self,
        ast: &Ast,
        node: CallObject,
        parts: parts::CallObject<'_>,
    ) -> std::result::Result<(), Self::Error> {
        let node = parts.callee;
        self.visit_expr(ast, node)?;

        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_infix(
        &mut self,
        ast: &Ast,
        node: Infix,
        parts: parts::Infix,
    ) -> std::result::Result<(), Self::Error> {
        let node = parts.lhs;
        self.visit_expr(ast, node)?;
        let node = parts.rhs;
        self.visit_expr(ast, node)?;

        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_prefix(
        &mut self,
        ast: &Ast,
        node: Prefix,
        parts: parts::Prefix,
    ) -> std::result::Result<(), Self::Error> {
        let node = parts.rhs;
        self.visit_expr(ast, node)?;

        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_array(
        &mut self,
        ast: &Ast,
        node: Array,
        parts: parts::Array<'_>,
    ) -> std::result::Result<(), Self::Error> {
        for node in parts.items {
            self.visit_expr(ast, *node)?;
        }

        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_object(
        &mut self,
        ast: &Ast,
        node: Object,
        parts: parts::Object<'_>,
    ) -> std::result::Result<(), Self::Error> {
        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_int(
        &mut self,
        ast: &Ast,
        node: Int,
        parts: parts::Int,
    ) -> std::result::Result<(), Self::Error> {
        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_float32(
        &mut self,
        ast: &Ast,
        node: Float32,
        parts: parts::Float32,
    ) -> std::result::Result<(), Self::Error> {
        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_float64(
        &mut self,
        ast: &Ast,
        node: Float64,
        parts: parts::Float64,
    ) -> std::result::Result<(), Self::Error> {
        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_bool(
        &mut self,
        ast: &Ast,
        node: Bool,
        parts: parts::Bool,
    ) -> std::result::Result<(), Self::Error> {
        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_str(
        &mut self,
        ast: &Ast,
        node: Str,
        parts: parts::Str,
    ) -> std::result::Result<(), Self::Error> {
        Ok(())
    }

    #[allow(unused_variables)]
    fn visit_nil(
        &mut self,
        ast: &Ast,
        node: Nil,
        parts: parts::Nil,
    ) -> std::result::Result<(), Self::Error> {
        Ok(())
    }
}

struct StmtWithAst<'a>(&'a Ast, Stmt);

impl std::fmt::Debug for StmtWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;

        match node.kind() {
            StmtKind::Var => VarWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            StmtKind::Loop => LoopWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            StmtKind::StmtExpr => StmtExprWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            StmtKind::FuncDecl => FuncDeclWithAst(ast, node.try_into().unwrap()).fmt(f)?,
        }

        Ok(())
    }
}

impl Stmt {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        StmtWithAst(ast, self)
    }
}

struct ExprWithAst<'a>(&'a Ast, Expr);

impl std::fmt::Debug for ExprWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;

        match node.kind() {
            ExprKind::Return => ReturnWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::Break => BreakWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::Continue => ContinueWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::IfSimple => IfSimpleWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::IfMulti => IfMultiWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::Block => BlockWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::FuncAnon => FuncAnonWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::GetVar => GetVarWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::SetVar => SetVarWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::GetField => GetFieldWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::SetField => SetFieldWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::GetIndex => GetIndexWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::SetIndex => SetIndexWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::Call => CallWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::CallObject => CallObjectWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::Infix => InfixWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::Prefix => PrefixWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::Array => ArrayWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::Object => ObjectWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::Int => IntWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::Float32 => Float32WithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::Float64 => Float64WithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::Bool => BoolWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::Str => StrWithAst(ast, node.try_into().unwrap()).fmt(f)?,
            ExprKind::Nil => NilWithAst(ast, node.try_into().unwrap()).fmt(f)?,
        }

        Ok(())
    }
}

impl Expr {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        ExprWithAst(ast, self)
    }
}

struct RootWithAst<'a>(&'a Ast, Root);

impl std::fmt::Debug for RootWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("Root")
            .field(&DebugIter(parts.body.iter().map(|v| v.debug(ast))))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl Root {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        RootWithAst(ast, self)
    }
}

struct VarWithAst<'a>(&'a Ast, Var);

impl std::fmt::Debug for VarWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("Var")
            .field(&parts.name.debug(ast))
            .field(&parts.value.debug(ast))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl Var {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        VarWithAst(ast, self)
    }
}

struct LoopWithAst<'a>(&'a Ast, Loop);

impl std::fmt::Debug for LoopWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("Loop")
            .field(&DebugIter(parts.body.iter().map(|v| v.debug(ast))))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl Loop {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        LoopWithAst(ast, self)
    }
}

struct StmtExprWithAst<'a>(&'a Ast, StmtExpr);

impl std::fmt::Debug for StmtExprWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("StmtExpr")
            .field(&parts.inner.debug(ast))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl StmtExpr {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        StmtExprWithAst(ast, self)
    }
}

struct FuncDeclWithAst<'a>(&'a Ast, FuncDecl);

impl std::fmt::Debug for FuncDeclWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("FuncDecl")
            .field(&parts.name.debug(ast))
            .field(&parts.body.debug(ast))
            .field(&DebugIter(parts.params.iter().map(|v| v.debug(ast))))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl FuncDecl {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        FuncDeclWithAst(ast, self)
    }
}

struct ReturnWithAst<'a>(&'a Ast, Return);

impl std::fmt::Debug for ReturnWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("Return")
            .field(&parts.value.into_option().map(|v| v.debug(ast)))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl Return {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        ReturnWithAst(ast, self)
    }
}

struct BreakWithAst<'a>(&'a Ast, Break);

impl std::fmt::Debug for BreakWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        write!(f, "Break")?;

        let _ = parts;

        Ok(())
    }
}

impl Break {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        BreakWithAst(ast, self)
    }
}

struct ContinueWithAst<'a>(&'a Ast, Continue);

impl std::fmt::Debug for ContinueWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        write!(f, "Continue")?;

        let _ = parts;

        Ok(())
    }
}

impl Continue {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        ContinueWithAst(ast, self)
    }
}

struct IfSimpleWithAst<'a>(&'a Ast, IfSimple);

impl std::fmt::Debug for IfSimpleWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("IfSimple")
            .field(&parts.cond.debug(ast))
            .field(&parts.tail.into_option().map(|v| v.debug(ast)))
            .field(&DebugIter(parts.body.iter().map(|v| v.debug(ast))))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl IfSimple {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        IfSimpleWithAst(ast, self)
    }
}

struct IfMultiWithAst<'a>(&'a Ast, IfMulti);

impl std::fmt::Debug for IfMultiWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("IfMulti")
            .field(&parts.tail.into_option().map(|v| v.debug(ast)))
            .field(&DebugIter(parts.branches.iter().map(|v| v.debug(ast))))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl IfMulti {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        IfMultiWithAst(ast, self)
    }
}

struct BlockWithAst<'a>(&'a Ast, Block);

impl std::fmt::Debug for BlockWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("Block")
            .field(&DebugIter(parts.body.iter().map(|v| v.debug(ast))))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl Block {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        BlockWithAst(ast, self)
    }
}

struct FuncAnonWithAst<'a>(&'a Ast, FuncAnon);

impl std::fmt::Debug for FuncAnonWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("FuncAnon")
            .field(&parts.name.into_option().map(|v| v.debug(ast)))
            .field(&parts.body.debug(ast))
            .field(&DebugIter(parts.params.iter().map(|v| v.debug(ast))))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl FuncAnon {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        FuncAnonWithAst(ast, self)
    }
}

struct GetVarWithAst<'a>(&'a Ast, GetVar);

impl std::fmt::Debug for GetVarWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("GetVar")
            .field(&parts.name.debug(ast))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl GetVar {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        GetVarWithAst(ast, self)
    }
}

struct SetVarWithAst<'a>(&'a Ast, SetVar);

impl std::fmt::Debug for SetVarWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("SetVar")
            .field(&parts.op.debug(ast))
            .field(&parts.base.debug(ast))
            .field(&parts.value.debug(ast))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl SetVar {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        SetVarWithAst(ast, self)
    }
}

struct GetFieldWithAst<'a>(&'a Ast, GetField);

impl std::fmt::Debug for GetFieldWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("GetField")
            .field(&parts.parent.debug(ast))
            .field(&parts.key.debug(ast))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl GetField {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        GetFieldWithAst(ast, self)
    }
}

struct SetFieldWithAst<'a>(&'a Ast, SetField);

impl std::fmt::Debug for SetFieldWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("SetField")
            .field(&parts.op.debug(ast))
            .field(&parts.base.debug(ast))
            .field(&parts.value.debug(ast))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl SetField {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        SetFieldWithAst(ast, self)
    }
}

struct GetIndexWithAst<'a>(&'a Ast, GetIndex);

impl std::fmt::Debug for GetIndexWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("GetIndex")
            .field(&parts.parent.debug(ast))
            .field(&parts.key.debug(ast))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl GetIndex {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        GetIndexWithAst(ast, self)
    }
}

struct SetIndexWithAst<'a>(&'a Ast, SetIndex);

impl std::fmt::Debug for SetIndexWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("SetIndex")
            .field(&parts.op.debug(ast))
            .field(&parts.base.debug(ast))
            .field(&parts.value.debug(ast))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl SetIndex {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        SetIndexWithAst(ast, self)
    }
}

struct CallWithAst<'a>(&'a Ast, Call);

impl std::fmt::Debug for CallWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("Call")
            .field(&parts.callee.debug(ast))
            .field(&DebugIter(parts.args.iter().map(|v| v.debug(ast))))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl Call {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        CallWithAst(ast, self)
    }
}

struct CallObjectWithAst<'a>(&'a Ast, CallObject);

impl std::fmt::Debug for CallObjectWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("CallObject")
            .field(&parts.callee.debug(ast))
            .field(&DebugIter(parts.args.iter().map(|v| v.debug(ast))))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl CallObject {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        CallObjectWithAst(ast, self)
    }
}

struct InfixWithAst<'a>(&'a Ast, Infix);

impl std::fmt::Debug for InfixWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("Infix")
            .field(&parts.op.debug(ast))
            .field(&parts.lhs.debug(ast))
            .field(&parts.rhs.debug(ast))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl Infix {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        InfixWithAst(ast, self)
    }
}

struct PrefixWithAst<'a>(&'a Ast, Prefix);

impl std::fmt::Debug for PrefixWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("Prefix")
            .field(&parts.op.debug(ast))
            .field(&parts.rhs.debug(ast))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl Prefix {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        PrefixWithAst(ast, self)
    }
}

struct ArrayWithAst<'a>(&'a Ast, Array);

impl std::fmt::Debug for ArrayWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("Array")
            .field(&DebugIter(parts.items.iter().map(|v| v.debug(ast))))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl Array {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        ArrayWithAst(ast, self)
    }
}

struct ObjectWithAst<'a>(&'a Ast, Object);

impl std::fmt::Debug for ObjectWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("Object")
            .field(&DebugIter(parts.entries.iter().map(|v| v.debug(ast))))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl Object {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        ObjectWithAst(ast, self)
    }
}

struct IntWithAst<'a>(&'a Ast, Int);

impl std::fmt::Debug for IntWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("Int")
            .field(&parts.value.debug(ast))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl Int {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        IntWithAst(ast, self)
    }
}

struct Float32WithAst<'a>(&'a Ast, Float32);

impl std::fmt::Debug for Float32WithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("Float32")
            .field(&parts.value.debug(ast))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl Float32 {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Float32WithAst(ast, self)
    }
}

struct Float64WithAst<'a>(&'a Ast, Float64);

impl std::fmt::Debug for Float64WithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("Float64")
            .field(&parts.value.debug(ast))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl Float64 {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        Float64WithAst(ast, self)
    }
}

struct BoolWithAst<'a>(&'a Ast, Bool);

impl std::fmt::Debug for BoolWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("Bool")
            .field(&parts.value.debug(ast))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl Bool {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        BoolWithAst(ast, self)
    }
}

struct StrWithAst<'a>(&'a Ast, Str);

impl std::fmt::Debug for StrWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("Str")
            .field(&parts.value.debug(ast))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl Str {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        StrWithAst(ast, self)
    }
}

struct NilWithAst<'a>(&'a Ast, Nil);

impl std::fmt::Debug for NilWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        write!(f, "Nil")?;

        let _ = parts;

        Ok(())
    }
}

impl Nil {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        NilWithAst(ast, self)
    }
}

struct BranchWithAst<'a>(&'a Ast, Branch);

impl std::fmt::Debug for BranchWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("Branch")
            .field(&parts.cond.debug(ast))
            .field(&DebugIter(parts.body.iter().map(|v| v.debug(ast))))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl Branch {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        BranchWithAst(ast, self)
    }
}

struct ObjectEntryWithAst<'a>(&'a Ast, ObjectEntry);

impl std::fmt::Debug for ObjectEntryWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("ObjectEntry")
            .field(&parts.key.debug(ast))
            .field(&parts.value.debug(ast))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl ObjectEntry {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        ObjectEntryWithAst(ast, self)
    }
}

struct IdentWithAst<'a>(&'a Ast, Ident);

impl std::fmt::Debug for IdentWithAst<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let ast = self.0;
        let node = self.1;
        let parts = unsafe { node.unpack(ast) };

        f.debug_tuple("Ident")
            .field(&parts.id.debug(ast))
            .finish()?;

        let _ = parts;

        Ok(())
    }
}

impl Ident {
    pub fn debug<'a>(self, ast: &'a Ast) -> impl std::fmt::Debug + 'a {
        IdentWithAst(ast, self)
    }
}
