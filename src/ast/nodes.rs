// Generated by astgen at 2025-10-11T20:20:27.612130649+00:00[UTC]
//
// See `astgen/src/main.rs` and `astgen/src/runtime.rs`

use super::{AssignOp, Ast, FloatId, IdentId, InfixOp, IntId, PrefixOp, StrId};
use crate::span::{Span, Spanned};

mod private {
    pub trait Sealed {}
}
use private::Sealed;

use std::marker::PhantomData;

#[allow(non_camel_case_types)]
#[derive(Clone, Copy, Hash)]
#[repr(packed)]
pub struct u24([u8; 3]);

impl u24 {
    pub const MAX: u24 = u24([255; 3]);
    pub const MIN: u24 = u24([0; 3]);
    pub const ZERO: u24 = u24([0; 3]);

    #[inline]
    pub const fn new(v: u32) -> Self {
        if v > Self::MAX.get() {
            panic!("value is out of bounds for u24");
        }

        unsafe { Self::new_unchecked(v) }
    }

    #[inline]
    pub const unsafe fn new_unchecked(v: u32) -> Self {
        let [a, b, c, _] = v.to_le_bytes();
        Self([a, b, c])
    }

    #[inline]
    pub const fn get(self) -> u32 {
        let [a, b, c] = self.0;
        u32::from_le_bytes([a, b, c, 0])
    }
}

impl PartialEq for u24 {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        PartialEq::eq(&self.get(), &other.get())
    }
}

impl Eq for u24 {}

impl PartialOrd for u24 {
    #[inline]
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        PartialOrd::partial_cmp(&self.get(), &other.get())
    }
}

impl Ord for u24 {
    #[inline]
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        Ord::cmp(&self.get(), &other.get())
    }
}

impl std::fmt::Debug for u24 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        <u32 as std::fmt::Debug>::fmt(&self.get(), f)
    }
}

#[allow(non_camel_case_types)]
#[derive(Clone, Copy, Hash)]
#[repr(packed)]
pub struct u56([u8; 7]);

impl u56 {
    pub const MAX: u56 = u56([255; 7]);
    pub const MIN: u56 = u56([0; 7]);
    pub const ZERO: u56 = u56([0; 7]);

    #[inline]
    pub const fn new(v: u64) -> Self {
        if v > Self::MAX.get() {
            panic!("value is out of bounds for u56");
        }

        unsafe { Self::new_unchecked(v) }
    }

    #[inline]
    pub const unsafe fn new_unchecked(v: u64) -> Self {
        let [a, b, c, d, e, f, g, _] = v.to_le_bytes();
        Self([a, b, c, d, e, f, g])
    }

    #[inline]
    pub const fn get(self) -> u64 {
        let [a, b, c, d, e, f, g] = self.0;
        u64::from_le_bytes([a, b, c, d, e, f, g, 0])
    }

    fn from_u56(v: u56) -> Self {
        v
    }

    fn into_u56(self) -> u56 {
        self
    }
}

impl PartialEq for u56 {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        PartialEq::eq(&self.get(), &other.get())
    }
}

impl Eq for u56 {}

impl PartialOrd for u56 {
    #[inline]
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        PartialOrd::partial_cmp(&self.get(), &other.get())
    }
}

impl Ord for u56 {
    #[inline]
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        Ord::cmp(&self.get(), &other.get())
    }
}

impl std::fmt::Debug for u56 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        <u64 as std::fmt::Debug>::fmt(&self.get(), f)
    }
}

trait IntoU56 {
    fn into_u56(self) -> u56;
}

trait FromU56 {
    fn from_u56(v: u56) -> Self;
}

impl IntoU56 for bool {
    fn into_u56(self) -> u56 {
        unsafe { u56::new_unchecked(self as u64) }
    }
}

impl FromU56 for bool {
    #[allow(unnecessary_transmutes)]
    fn from_u56(v: u56) -> Self {
        unsafe { core::mem::transmute(v.get() as u8) }
    }
}

impl IntoU56 for f32 {
    fn into_u56(self) -> u56 {
        unsafe { u56::new_unchecked(self.to_bits() as u64) }
    }
}

impl FromU56 for f32 {
    fn from_u56(v: u56) -> Self {
        f32::from_bits(v.get() as u32)
    }
}

impl IntoU56 for u32 {
    fn into_u56(self) -> u56 {
        unsafe { u56::new_unchecked(self as u64) }
    }
}

impl FromU56 for u32 {
    fn from_u56(v: u56) -> Self {
        v.get() as u32
    }
}

impl IntoU56 for i32 {
    fn into_u56(self) -> u56 {
        unsafe { u56::new_unchecked(self as u64) }
    }
}

impl FromU56 for i32 {
    fn from_u56(v: u56) -> Self {
        v.get() as i32
    }
}

#[derive(Clone, Copy)]
#[repr(C)]
pub struct Packed {
    kind: RawKind,
    repr: PackedRepr,
    #[cfg(debug_assertions)]
    debug_tag: DebugPackedReprTag,
}

impl Packed {
    fn copy(&self) -> Self {
        unsafe { (self as *const Self).read() }
    }

    #[inline]
    pub fn kind(&self) -> NodeKind {
        let kind = self.kind.get();
        debug_assert!(NodeKind::all().iter().map(|(_, v)| *v).any(|v| v == kind));

        // SAFETY: All writes of `kind` are in this file, and we know
        // that what's written is always a valid bitpattern of `NodeKind`.
        unsafe { core::mem::transmute(kind) }
    }

    #[inline]
    fn kind_only(kind: NodeKind) -> Self {
        Self {
            kind: unsafe { core::num::NonZero::new_unchecked(kind as u8) },
            repr: PackedRepr {
                kind_only: KindOnly {
                    _padding: u56::ZERO,
                },
            },
            #[cfg(debug_assertions)]
            debug_tag: DebugPackedReprTag::KindOnly,
        }
    }

    #[inline]
    fn fixed_arity(kind: NodeKind, index: u32) -> Self {
        Self {
            kind: unsafe { core::num::NonZero::new_unchecked(kind as u8) },
            repr: PackedRepr {
                fixed_arity: FixedArity {
                    _padding: u24::ZERO,
                    index,
                },
            },
            #[cfg(debug_assertions)]
            debug_tag: DebugPackedReprTag::FixedArity,
        }
    }

    #[inline]
    fn fixed_arity_inline(kind: NodeKind, value: u24, index: u32) -> Self {
        Self {
            kind: unsafe { core::num::NonZero::new_unchecked(kind as u8) },
            repr: PackedRepr {
                fixed_arity_inline: FixedArity_Inline { value, index },
            },
            #[cfg(debug_assertions)]
            debug_tag: DebugPackedReprTag::FixedArity_Inline,
        }
    }

    #[inline]
    fn variable_arity(kind: NodeKind, length: u24, index: u32) -> Self {
        Self {
            kind: unsafe { core::num::NonZero::new_unchecked(kind as u8) },
            repr: PackedRepr {
                variable_arity: VariableArity { length, index },
            },
            #[cfg(debug_assertions)]
            debug_tag: DebugPackedReprTag::VariableArity,
        }
    }

    #[inline]
    fn mixed_arity(kind: NodeKind, length: u24, index: u32) -> Self {
        Self {
            kind: unsafe { core::num::NonZero::new_unchecked(kind as u8) },
            repr: PackedRepr {
                mixed_arity: MixedArity {
                    tail_length: length,
                    index,
                },
            },
            #[cfg(debug_assertions)]
            debug_tag: DebugPackedReprTag::MixedArity,
        }
    }

    #[inline]
    fn inline(kind: NodeKind, value: u56) -> Self {
        Self {
            kind: unsafe { core::num::NonZero::new_unchecked(kind as u8) },
            repr: PackedRepr {
                inline: Inline { value },
            },
            #[cfg(debug_assertions)]
            debug_tag: DebugPackedReprTag::Inline,
        }
    }

    #[inline]
    unsafe fn as_kind_only(&self) -> &KindOnly {
        #[cfg(debug_assertions)]
        debug_assert!(self.debug_tag == DebugPackedReprTag::KindOnly);
        unsafe { &self.repr.kind_only }
    }

    #[inline]
    unsafe fn as_fixed_arity(&self) -> &FixedArity {
        #[cfg(debug_assertions)]
        debug_assert!(self.debug_tag == DebugPackedReprTag::FixedArity);
        unsafe { &self.repr.fixed_arity }
    }

    #[inline]
    unsafe fn as_fixed_arity_inline(&self) -> &FixedArity_Inline {
        #[cfg(debug_assertions)]
        debug_assert!(self.debug_tag == DebugPackedReprTag::FixedArity_Inline);
        unsafe { &self.repr.fixed_arity_inline }
    }

    #[inline]
    unsafe fn as_variable_arity(&self) -> &VariableArity {
        #[cfg(debug_assertions)]
        debug_assert!(self.debug_tag == DebugPackedReprTag::VariableArity);
        unsafe { &self.repr.variable_arity }
    }

    #[inline]
    unsafe fn as_mixed_arity(&self) -> &MixedArity {
        #[cfg(debug_assertions)]
        debug_assert!(self.debug_tag == DebugPackedReprTag::MixedArity);
        unsafe { &self.repr.mixed_arity }
    }

    #[inline]
    unsafe fn as_inline(&self) -> &Inline {
        #[cfg(debug_assertions)]
        debug_assert!(self.debug_tag == DebugPackedReprTag::Inline);
        unsafe { &self.repr.inline }
    }
}

const _: () = {
    let _ = core::mem::transmute::<Option<Packed>, Packed>;
};

#[allow(non_camel_case_types)]
#[cfg(debug_assertions)]
#[derive(Debug, Clone, Copy, PartialEq)]
enum DebugPackedReprTag {
    KindOnly,
    FixedArity,
    FixedArity_Inline,
    VariableArity,
    MixedArity,
    Inline,
}

#[derive(Clone, Copy)]
union PackedRepr {
    kind_only: KindOnly,
    fixed_arity: FixedArity,
    fixed_arity_inline: FixedArity_Inline,
    variable_arity: VariableArity,
    mixed_arity: MixedArity,
    inline: Inline,
}

type RawKind = core::num::NonZero<u8>;

#[derive(Clone, Copy)]
#[repr(C, packed)]
struct KindOnly {
    _padding: u56,
}

#[derive(Clone, Copy)]
#[repr(C, packed)]
struct FixedArity {
    _padding: u24,
    index: u32,
}

#[allow(non_camel_case_types)]
#[derive(Clone, Copy)]
#[repr(C, packed)]
struct FixedArity_Inline {
    value: u24,
    index: u32,
}

#[derive(Clone, Copy)]
#[repr(C, packed)]
struct VariableArity {
    length: u24,
    index: u32,
}

#[derive(Clone, Copy)]
#[repr(C, packed)]
struct MixedArity {
    tail_length: u24,
    index: u32,
}

#[derive(Clone, Copy)]
#[repr(C, packed)]
struct Inline {
    value: u56,
}

/// Marker for types which are transparent wrappers over [`Packed`].
pub unsafe trait PackedAbi: Sealed + Sized {
    /// Check if `kind` matches `Self`'s kind.
    fn check_kind(kind: NodeKind) -> bool;
}

/// Conversion traits to/from [`Packed`].
pub trait PackedNode: PackedAbi {
    /// SAFETY:
    /// - `Self` must be a transparent wrapper over `Packed`.
    /// - `v` must have the same kind as `Self`.
    unsafe fn from_packed(v: &Packed) -> &Self;

    fn into_packed(v: &Self) -> &Packed;

    /// SAFETY:
    /// - All nodes in `v` must have the same kind as `Self`.
    /// - `Self` must be a transparent wrapper over `Packed`.
    unsafe fn from_packed_slice(v: &[Packed]) -> &[Self];

    fn into_packed_slice(v: &[Self]) -> &[Packed];

    /// SAFETY:
    /// - `Self` must be a transparent wrapper over `Packed`.
    /// - `Spanned` is a repr(C) struct, meaning it has the
    ///   same layout for the same `T`.
    unsafe fn from_spanned_packed(v: Spanned<Packed>) -> Spanned<Self>;

    fn into_spanned_packed(v: Spanned<Self>) -> Spanned<Packed>;

    /// SAFETY:
    /// - `Self` must be a transparent wrapper over `Packed`.
    /// - All nodes in `v` must have the same kind as `Self`.
    /// - `Spanned` is a repr(C) struct, meaning it has the
    ///   same layout for the same `T`.
    unsafe fn from_spanned_packed_slice(v: &[Spanned<Packed>]) -> &[Spanned<Self>];

    fn into_spanned_packed_slice(v: &[Spanned<Self>]) -> &[Spanned<Packed>];
}

impl<T: PackedAbi> PackedNode for T {
    unsafe fn from_packed(v: &Packed) -> &Self {
        debug_assert!(T::check_kind(v.kind()));
        unsafe { core::mem::transmute(v) }
    }

    fn into_packed(v: &Self) -> &Packed {
        unsafe { core::mem::transmute(v) }
    }

    unsafe fn from_packed_slice(v: &[Packed]) -> &[Self] {
        debug_assert!(v.iter().all(|v| T::check_kind(v.kind())));
        unsafe { core::mem::transmute(v) }
    }

    fn into_packed_slice(v: &[Self]) -> &[Packed] {
        unsafe { core::mem::transmute(v) }
    }

    unsafe fn from_spanned_packed(v: Spanned<Packed>) -> Spanned<Self> {
        debug_assert!(T::check_kind(v.kind()));
        unsafe { core::mem::transmute_copy(&v) }
    }

    fn into_spanned_packed(v: Spanned<Self>) -> Spanned<Packed> {
        unsafe { core::mem::transmute_copy(&v) }
    }

    unsafe fn from_spanned_packed_slice(v: &[Spanned<Packed>]) -> &[Spanned<Self>] {
        debug_assert!(v.iter().all(|v| T::check_kind(v.kind())));
        unsafe { core::mem::transmute(v) }
    }

    fn into_spanned_packed_slice(v: &[Spanned<Self>]) -> &[Spanned<Packed>] {
        unsafe { core::mem::transmute(v) }
    }
}

#[derive(Clone, Copy, Debug)]
pub struct NodeCastError;
impl std::fmt::Display for NodeCastError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "invalid cast between node types")
    }
}
impl std::error::Error for NodeCastError {}

pub trait Pack {
    type Node;

    fn pack(self, ast: &mut Ast) -> Self::Node;
}

pub struct Node<'a, T: PackedAbi> {
    pub(super) ast: &'a Ast,
    pub(super) node: &'a T,
}

impl<'a, T: PackedAbi> Clone for Node<'a, T> {
    fn clone(&self) -> Self {
        Node {
            ast: self.ast,
            node: self.node,
        }
    }
}

impl<'a, T: PackedAbi> Copy for Node<'a, T> {}

impl<'a, T: PackedAbi> std::ops::Deref for Node<'a, T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        self.node
    }
}

#[derive(Clone, Copy)]
pub struct ValueNode<'a, T> {
    pub(super) ast: &'a Ast,
    pub(super) value: T,
}

impl<'a, T> std::ops::Deref for ValueNode<'a, T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.value
    }
}

pub struct NodeList<'a, T> {
    pub(super) ast: &'a Ast,
    pub(super) nodes: &'a [T],
}

impl<'a, T: PackedAbi> NodeList<'a, T> {
    #[inline]
    pub fn empty(ast: &'a Ast) -> Self {
        NodeList { ast, nodes: &[] }
    }

    #[inline]
    pub fn len(&self) -> usize {
        self.nodes.len()
    }

    #[inline]
    pub fn is_empty(&self) -> bool {
        self.nodes.is_empty()
    }

    #[inline]
    pub unsafe fn get_unchecked(&self, index: usize) -> Node<'a, T> {
        Node {
            ast: self.ast,
            node: unsafe { self.nodes.get_unchecked(index) },
        }
    }

    #[inline]
    pub fn get(&self, index: usize) -> Option<Node<'a, T>> {
        if index >= self.nodes.len() {
            return None;
        }

        Some(unsafe { self.get_unchecked(index) })
    }

    #[inline]
    pub fn slice<I>(&self, range: I) -> Option<NodeList<'a, T>>
    where
        I: std::slice::SliceIndex<[T], Output = [T]>,
    {
        self.nodes.get(range).map(|nodes| NodeList {
            ast: self.ast,
            nodes,
        })
    }

    #[inline]
    pub fn last(&self) -> Option<Node<'a, T>> {
        if self.is_empty() {
            return None;
        }

        Some(unsafe { self.get_unchecked(self.len() - 1) })
    }

    #[inline]
    pub fn iter(&self) -> NodeListIter<'a, T> {
        NodeListIter {
            list: self.clone(),
            front: 0,
            back: self.nodes.len().wrapping_sub(1),
        }
    }
}

impl<'a, T: PackedAbi> Clone for NodeList<'a, T> {
    fn clone(&self) -> Self {
        Self {
            ast: self.ast,
            nodes: self.nodes,
        }
    }
}

impl<'a, T: PackedAbi> Copy for NodeList<'a, T> {}

impl<'a, T: PackedAbi> IntoIterator for NodeList<'a, T> {
    type Item = Node<'a, T>;

    type IntoIter = NodeListIter<'a, T>;

    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}

pub struct NodeListIter<'a, T> {
    list: NodeList<'a, T>,
    front: usize,
    back: usize,
}

impl<'a, T: PackedAbi> Iterator for NodeListIter<'a, T> {
    type Item = Node<'a, T>;

    #[inline]
    fn next(&mut self) -> Option<Self::Item> {
        let Some(node) = self.list.get(self.front) else {
            return None;
        };
        self.front = self.front.wrapping_add(1);
        Some(node)
    }
}

impl<'a, T: PackedAbi> DoubleEndedIterator for NodeListIter<'a, T> {
    #[inline]
    fn next_back(&mut self) -> Option<Self::Item> {
        let Some(node) = self.list.get(self.back) else {
            return None;
        };
        self.back = self.back.wrapping_sub(1);
        Some(node)
    }
}

impl<'a, T: PackedAbi> std::iter::FusedIterator for NodeListIter<'a, T> {}

impl<'a, T: PackedAbi> Clone for NodeListIter<'a, T> {
    fn clone(&self) -> Self {
        NodeListIter {
            list: self.list.clone(),
            front: self.front,
            back: self.back,
        }
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Opt<T>(Packed, PhantomData<T>);

impl<T: Sealed> Sealed for Opt<T> {}
/// SAFETY: `Opt` is a transparent wrapper over `Packed`.
unsafe impl<T: PackedAbi> PackedAbi for Opt<T> {
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::None || T::check_kind(kind)
    }
}

impl<T: PackedAbi> Opt<T> {
    #[inline]
    pub fn some(v: T) -> Self {
        Self(unsafe { core::mem::transmute_copy(&v) }, PhantomData)
    }

    #[inline]
    pub fn none() -> Self {
        Self(Packed::kind_only(NodeKind::None), PhantomData)
    }

    #[inline]
    pub fn is_some(&self) -> bool {
        !self.is_none()
    }

    #[inline]
    pub fn is_none(&self) -> bool {
        matches!(self.0.kind(), NodeKind::None)
    }

    #[inline]
    pub fn unwrap(&self) -> &T {
        if self.is_none() {
            panic!("unwrapped an Opt::None value");
        }
        unsafe { T::from_packed(&self.0) }
    }

    #[inline]
    pub unsafe fn unwrap_unchecked(&self) -> &T {
        debug_assert!(self.is_some());
        unsafe { T::from_packed(&self.0) }
    }

    #[inline]
    pub fn as_option(&self) -> Option<&T> {
        match self.is_some() {
            true => Some(unsafe { self.unwrap_unchecked() }),
            false => None,
        }
    }
}

impl<'a, T: PackedAbi> Node<'a, Opt<T>> {
    #[inline]
    pub fn as_option(&self) -> Option<Node<'a, T>> {
        self.node.as_option().map(|node| Node {
            ast: self.ast,
            node,
        })
    }
}

impl<'a, T: PackedAbi> std::fmt::Debug for Node<'a, Opt<T>>
where
    Node<'a, T>: std::fmt::Debug,
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Debug::fmt(&self.as_option(), f)
    }
}

struct DebugIter<T>(T);

impl<T: Clone + Iterator<Item = I>, I: std::fmt::Debug> std::fmt::Debug for DebugIter<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_list().entries(self.0.clone()).finish()
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u8)]
pub enum NodeKind {
    Root = 1,
    Var = 2,
    Loop = 3,
    FuncDecl = 4,
    StmtExpr = 5,
    Return = 6,
    Break = 7,
    Continue = 8,
    IfSimple = 9,
    IfMulti = 10,
    Block = 11,
    FuncAnon = 12,
    GetVar = 13,
    SetVar = 14,
    GetField = 15,
    SetField = 16,
    GetIndex = 17,
    SetIndex = 18,
    Call = 19,
    CallTable = 20,
    Infix = 21,
    Prefix = 22,
    List = 23,
    Table = 24,
    Int32 = 25,
    Int64 = 26,
    Float32 = 27,
    Float64 = 28,
    Bool = 29,
    Str = 30,
    Nil = 31,
    Branch = 32,
    TableEntry = 33,
    Ident = 34,
    None = 255,
}

impl NodeKind {
    const fn all() -> &'static [(&'static str, u8)] {
        &[
            ("Root", 1),
            ("Var", 2),
            ("Loop", 3),
            ("FuncDecl", 4),
            ("StmtExpr", 5),
            ("Return", 6),
            ("Break", 7),
            ("Continue", 8),
            ("IfSimple", 9),
            ("IfMulti", 10),
            ("Block", 11),
            ("FuncAnon", 12),
            ("GetVar", 13),
            ("SetVar", 14),
            ("GetField", 15),
            ("SetField", 16),
            ("GetIndex", 17),
            ("SetIndex", 18),
            ("Call", 19),
            ("CallTable", 20),
            ("Infix", 21),
            ("Prefix", 22),
            ("List", 23),
            ("Table", 24),
            ("Int32", 25),
            ("Int64", 26),
            ("Float32", 27),
            ("Float64", 28),
            ("Bool", 29),
            ("Str", 30),
            ("Nil", 31),
            ("Branch", 32),
            ("TableEntry", 33),
            ("Ident", 34),
            ("None", 255),
        ]
    }
}

#[repr(u8)]
pub enum StmtKind<'a> {
    Var(Node<'a, Var>) = NodeKind::Var as u8,
    Loop(Node<'a, Loop>) = NodeKind::Loop as u8,
    FuncDecl(Node<'a, FuncDecl>) = NodeKind::FuncDecl as u8,
    StmtExpr(Node<'a, StmtExpr>) = NodeKind::StmtExpr as u8,
}

impl<'a> Node<'a, Stmt> {
    #[inline]
    pub fn kind(&self) -> StmtKind<'a> {
        let node: &'a Stmt = &*self.node;
        match node.0.kind() {
            NodeKind::Var => StmtKind::Var(Node {
                ast: self.ast,
                node: unsafe { Var::from_packed(&node.0) },
            }),
            NodeKind::Loop => StmtKind::Loop(Node {
                ast: self.ast,
                node: unsafe { Loop::from_packed(&node.0) },
            }),
            NodeKind::FuncDecl => StmtKind::FuncDecl(Node {
                ast: self.ast,
                node: unsafe { FuncDecl::from_packed(&node.0) },
            }),
            NodeKind::StmtExpr => StmtKind::StmtExpr(Node {
                ast: self.ast,
                node: unsafe { StmtExpr::from_packed(&node.0) },
            }),
            // SAFETY: guaranteed to be a valid `Stmt`
            _ => unsafe { std::hint::unreachable_unchecked() },
        }
    }
}
#[repr(u8)]
pub enum ExprKind<'a> {
    Return(Node<'a, Return>) = NodeKind::Return as u8,
    Break(Node<'a, Break>) = NodeKind::Break as u8,
    Continue(Node<'a, Continue>) = NodeKind::Continue as u8,
    IfSimple(Node<'a, IfSimple>) = NodeKind::IfSimple as u8,
    IfMulti(Node<'a, IfMulti>) = NodeKind::IfMulti as u8,
    Block(Node<'a, Block>) = NodeKind::Block as u8,
    FuncAnon(Node<'a, FuncAnon>) = NodeKind::FuncAnon as u8,
    GetVar(Node<'a, GetVar>) = NodeKind::GetVar as u8,
    SetVar(Node<'a, SetVar>) = NodeKind::SetVar as u8,
    GetField(Node<'a, GetField>) = NodeKind::GetField as u8,
    SetField(Node<'a, SetField>) = NodeKind::SetField as u8,
    GetIndex(Node<'a, GetIndex>) = NodeKind::GetIndex as u8,
    SetIndex(Node<'a, SetIndex>) = NodeKind::SetIndex as u8,
    Call(Node<'a, Call>) = NodeKind::Call as u8,
    CallTable(Node<'a, CallTable>) = NodeKind::CallTable as u8,
    Infix(Node<'a, Infix>) = NodeKind::Infix as u8,
    Prefix(Node<'a, Prefix>) = NodeKind::Prefix as u8,
    List(Node<'a, List>) = NodeKind::List as u8,
    Table(Node<'a, Table>) = NodeKind::Table as u8,
    Int32(Node<'a, Int32>) = NodeKind::Int32 as u8,
    Int64(Node<'a, Int64>) = NodeKind::Int64 as u8,
    Float32(Node<'a, Float32>) = NodeKind::Float32 as u8,
    Float64(Node<'a, Float64>) = NodeKind::Float64 as u8,
    Bool(Node<'a, Bool>) = NodeKind::Bool as u8,
    Str(Node<'a, Str>) = NodeKind::Str as u8,
    Nil(Node<'a, Nil>) = NodeKind::Nil as u8,
}

impl<'a> Node<'a, Expr> {
    #[inline]
    pub fn kind(&self) -> ExprKind<'a> {
        let node: &'a Expr = &*self.node;
        match node.0.kind() {
            NodeKind::Return => ExprKind::Return(Node {
                ast: self.ast,
                node: unsafe { Return::from_packed(&node.0) },
            }),
            NodeKind::Break => ExprKind::Break(Node {
                ast: self.ast,
                node: unsafe { Break::from_packed(&node.0) },
            }),
            NodeKind::Continue => ExprKind::Continue(Node {
                ast: self.ast,
                node: unsafe { Continue::from_packed(&node.0) },
            }),
            NodeKind::IfSimple => ExprKind::IfSimple(Node {
                ast: self.ast,
                node: unsafe { IfSimple::from_packed(&node.0) },
            }),
            NodeKind::IfMulti => ExprKind::IfMulti(Node {
                ast: self.ast,
                node: unsafe { IfMulti::from_packed(&node.0) },
            }),
            NodeKind::Block => ExprKind::Block(Node {
                ast: self.ast,
                node: unsafe { Block::from_packed(&node.0) },
            }),
            NodeKind::FuncAnon => ExprKind::FuncAnon(Node {
                ast: self.ast,
                node: unsafe { FuncAnon::from_packed(&node.0) },
            }),
            NodeKind::GetVar => ExprKind::GetVar(Node {
                ast: self.ast,
                node: unsafe { GetVar::from_packed(&node.0) },
            }),
            NodeKind::SetVar => ExprKind::SetVar(Node {
                ast: self.ast,
                node: unsafe { SetVar::from_packed(&node.0) },
            }),
            NodeKind::GetField => ExprKind::GetField(Node {
                ast: self.ast,
                node: unsafe { GetField::from_packed(&node.0) },
            }),
            NodeKind::SetField => ExprKind::SetField(Node {
                ast: self.ast,
                node: unsafe { SetField::from_packed(&node.0) },
            }),
            NodeKind::GetIndex => ExprKind::GetIndex(Node {
                ast: self.ast,
                node: unsafe { GetIndex::from_packed(&node.0) },
            }),
            NodeKind::SetIndex => ExprKind::SetIndex(Node {
                ast: self.ast,
                node: unsafe { SetIndex::from_packed(&node.0) },
            }),
            NodeKind::Call => ExprKind::Call(Node {
                ast: self.ast,
                node: unsafe { Call::from_packed(&node.0) },
            }),
            NodeKind::CallTable => ExprKind::CallTable(Node {
                ast: self.ast,
                node: unsafe { CallTable::from_packed(&node.0) },
            }),
            NodeKind::Infix => ExprKind::Infix(Node {
                ast: self.ast,
                node: unsafe { Infix::from_packed(&node.0) },
            }),
            NodeKind::Prefix => ExprKind::Prefix(Node {
                ast: self.ast,
                node: unsafe { Prefix::from_packed(&node.0) },
            }),
            NodeKind::List => ExprKind::List(Node {
                ast: self.ast,
                node: unsafe { List::from_packed(&node.0) },
            }),
            NodeKind::Table => ExprKind::Table(Node {
                ast: self.ast,
                node: unsafe { Table::from_packed(&node.0) },
            }),
            NodeKind::Int32 => ExprKind::Int32(Node {
                ast: self.ast,
                node: unsafe { Int32::from_packed(&node.0) },
            }),
            NodeKind::Int64 => ExprKind::Int64(Node {
                ast: self.ast,
                node: unsafe { Int64::from_packed(&node.0) },
            }),
            NodeKind::Float32 => ExprKind::Float32(Node {
                ast: self.ast,
                node: unsafe { Float32::from_packed(&node.0) },
            }),
            NodeKind::Float64 => ExprKind::Float64(Node {
                ast: self.ast,
                node: unsafe { Float64::from_packed(&node.0) },
            }),
            NodeKind::Bool => ExprKind::Bool(Node {
                ast: self.ast,
                node: unsafe { Bool::from_packed(&node.0) },
            }),
            NodeKind::Str => ExprKind::Str(Node {
                ast: self.ast,
                node: unsafe { Str::from_packed(&node.0) },
            }),
            NodeKind::Nil => ExprKind::Nil(Node {
                ast: self.ast,
                node: unsafe { Nil::from_packed(&node.0) },
            }),
            // SAFETY: guaranteed to be a valid `Stmt`
            _ => unsafe { std::hint::unreachable_unchecked() },
        }
    }
}
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Stmt(Packed);

impl Sealed for Stmt {}

impl From<Stmt> for Packed {
    #[inline]
    fn from(v: Stmt) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Expr(Packed);

impl Sealed for Expr {}

impl From<Expr> for Packed {
    #[inline]
    fn from(v: Expr) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Root(Packed);

impl Sealed for Root {}

impl From<Root> for Packed {
    #[inline]
    fn from(v: Root) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Var(Packed);

impl Sealed for Var {}

impl From<Var> for Packed {
    #[inline]
    fn from(v: Var) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Loop(Packed);

impl Sealed for Loop {}

impl From<Loop> for Packed {
    #[inline]
    fn from(v: Loop) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct FuncDecl(Packed);

impl Sealed for FuncDecl {}

impl From<FuncDecl> for Packed {
    #[inline]
    fn from(v: FuncDecl) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct StmtExpr(Packed);

impl Sealed for StmtExpr {}

impl From<StmtExpr> for Packed {
    #[inline]
    fn from(v: StmtExpr) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Return(Packed);

impl Sealed for Return {}

impl From<Return> for Packed {
    #[inline]
    fn from(v: Return) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Break(Packed);

impl Sealed for Break {}

impl From<Break> for Packed {
    #[inline]
    fn from(v: Break) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Continue(Packed);

impl Sealed for Continue {}

impl From<Continue> for Packed {
    #[inline]
    fn from(v: Continue) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct IfSimple(Packed);

impl Sealed for IfSimple {}

impl From<IfSimple> for Packed {
    #[inline]
    fn from(v: IfSimple) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct IfMulti(Packed);

impl Sealed for IfMulti {}

impl From<IfMulti> for Packed {
    #[inline]
    fn from(v: IfMulti) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Block(Packed);

impl Sealed for Block {}

impl From<Block> for Packed {
    #[inline]
    fn from(v: Block) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct FuncAnon(Packed);

impl Sealed for FuncAnon {}

impl From<FuncAnon> for Packed {
    #[inline]
    fn from(v: FuncAnon) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct GetVar(Packed);

impl Sealed for GetVar {}

impl From<GetVar> for Packed {
    #[inline]
    fn from(v: GetVar) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct SetVar(Packed);

impl Sealed for SetVar {}

impl From<SetVar> for Packed {
    #[inline]
    fn from(v: SetVar) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct GetField(Packed);

impl Sealed for GetField {}

impl From<GetField> for Packed {
    #[inline]
    fn from(v: GetField) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct SetField(Packed);

impl Sealed for SetField {}

impl From<SetField> for Packed {
    #[inline]
    fn from(v: SetField) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct GetIndex(Packed);

impl Sealed for GetIndex {}

impl From<GetIndex> for Packed {
    #[inline]
    fn from(v: GetIndex) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct SetIndex(Packed);

impl Sealed for SetIndex {}

impl From<SetIndex> for Packed {
    #[inline]
    fn from(v: SetIndex) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Call(Packed);

impl Sealed for Call {}

impl From<Call> for Packed {
    #[inline]
    fn from(v: Call) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct CallTable(Packed);

impl Sealed for CallTable {}

impl From<CallTable> for Packed {
    #[inline]
    fn from(v: CallTable) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Infix(Packed);

impl Sealed for Infix {}

impl From<Infix> for Packed {
    #[inline]
    fn from(v: Infix) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Prefix(Packed);

impl Sealed for Prefix {}

impl From<Prefix> for Packed {
    #[inline]
    fn from(v: Prefix) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct List(Packed);

impl Sealed for List {}

impl From<List> for Packed {
    #[inline]
    fn from(v: List) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Table(Packed);

impl Sealed for Table {}

impl From<Table> for Packed {
    #[inline]
    fn from(v: Table) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Int32(Packed);

impl Sealed for Int32 {}

impl From<Int32> for Packed {
    #[inline]
    fn from(v: Int32) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Int64(Packed);

impl Sealed for Int64 {}

impl From<Int64> for Packed {
    #[inline]
    fn from(v: Int64) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Float32(Packed);

impl Sealed for Float32 {}

impl From<Float32> for Packed {
    #[inline]
    fn from(v: Float32) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Float64(Packed);

impl Sealed for Float64 {}

impl From<Float64> for Packed {
    #[inline]
    fn from(v: Float64) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Bool(Packed);

impl Sealed for Bool {}

impl From<Bool> for Packed {
    #[inline]
    fn from(v: Bool) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Str(Packed);

impl Sealed for Str {}

impl From<Str> for Packed {
    #[inline]
    fn from(v: Str) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Nil(Packed);

impl Sealed for Nil {}

impl From<Nil> for Packed {
    #[inline]
    fn from(v: Nil) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Branch(Packed);

impl Sealed for Branch {}

impl From<Branch> for Packed {
    #[inline]
    fn from(v: Branch) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct TableEntry(Packed);

impl Sealed for TableEntry {}

impl From<TableEntry> for Packed {
    #[inline]
    fn from(v: TableEntry) -> Self {
        v.0
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Ident(Packed);

impl Sealed for Ident {}

impl From<Ident> for Packed {
    #[inline]
    fn from(v: Ident) -> Self {
        v.0
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Stmt {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind >= NodeKind::Var && kind <= NodeKind::StmtExpr
    }
}

impl TryFrom<Packed> for Stmt {
    type Error = ();

    #[inline]
    fn try_from(v: Packed) -> Result<Self, Self::Error> {
        if <Self as PackedAbi>::check_kind(v.kind()) {
            Ok(Self(v))
        } else {
            Err(())
        }
    }
}
/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Expr {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind >= NodeKind::Return && kind <= NodeKind::Nil
    }
}

impl TryFrom<Packed> for Expr {
    type Error = ();

    #[inline]
    fn try_from(v: Packed) -> Result<Self, Self::Error> {
        if <Self as PackedAbi>::check_kind(v.kind()) {
            Ok(Self(v))
        } else {
            Err(())
        }
    }
}
impl TryFrom<Packed> for Root {
    type Error = ();

    #[inline]
    fn try_from(v: Packed) -> Result<Self, Self::Error> {
        if <Self as PackedAbi>::check_kind(v.kind()) {
            Ok(Self(v))
        } else {
            Err(())
        }
    }
}
/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Root {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Root
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Var {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Var
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Loop {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Loop
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for FuncDecl {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::FuncDecl
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for StmtExpr {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::StmtExpr
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Return {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Return
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Break {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Break
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Continue {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Continue
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for IfSimple {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::IfSimple
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for IfMulti {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::IfMulti
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Block {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Block
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for FuncAnon {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::FuncAnon
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for GetVar {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::GetVar
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for SetVar {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::SetVar
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for GetField {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::GetField
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for SetField {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::SetField
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for GetIndex {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::GetIndex
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for SetIndex {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::SetIndex
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Call {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Call
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for CallTable {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::CallTable
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Infix {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Infix
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Prefix {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Prefix
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for List {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::List
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Table {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Table
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Int32 {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Int32
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Int64 {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Int64
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Float32 {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Float32
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Float64 {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Float64
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Bool {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Bool
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Str {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Str
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Nil {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Nil
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Branch {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Branch
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for TableEntry {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::TableEntry
    }
}

/// SAFETY: `self` is a transparent wrapper over `Packed`.
unsafe impl PackedAbi for Ident {
    #[inline]
    fn check_kind(kind: NodeKind) -> bool {
        kind == NodeKind::Ident
    }
}

impl From<Var> for Stmt {
    #[inline]
    fn from(v: Var) -> Self {
        Stmt(v.0)
    }
}

impl TryFrom<Stmt> for Var {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Stmt) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::Var) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Loop> for Stmt {
    #[inline]
    fn from(v: Loop) -> Self {
        Stmt(v.0)
    }
}

impl TryFrom<Stmt> for Loop {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Stmt) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::Loop) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<FuncDecl> for Stmt {
    #[inline]
    fn from(v: FuncDecl) -> Self {
        Stmt(v.0)
    }
}

impl TryFrom<Stmt> for FuncDecl {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Stmt) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::FuncDecl) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<StmtExpr> for Stmt {
    #[inline]
    fn from(v: StmtExpr) -> Self {
        Stmt(v.0)
    }
}

impl TryFrom<Stmt> for StmtExpr {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Stmt) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::StmtExpr) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Return> for Expr {
    #[inline]
    fn from(v: Return) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Return {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::Return) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Break> for Expr {
    #[inline]
    fn from(v: Break) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Break {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::Break) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Continue> for Expr {
    #[inline]
    fn from(v: Continue) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Continue {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::Continue) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<IfSimple> for Expr {
    #[inline]
    fn from(v: IfSimple) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for IfSimple {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::IfSimple) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<IfMulti> for Expr {
    #[inline]
    fn from(v: IfMulti) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for IfMulti {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::IfMulti) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Block> for Expr {
    #[inline]
    fn from(v: Block) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Block {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::Block) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<FuncAnon> for Expr {
    #[inline]
    fn from(v: FuncAnon) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for FuncAnon {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::FuncAnon) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<GetVar> for Expr {
    #[inline]
    fn from(v: GetVar) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for GetVar {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::GetVar) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<SetVar> for Expr {
    #[inline]
    fn from(v: SetVar) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for SetVar {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::SetVar) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<GetField> for Expr {
    #[inline]
    fn from(v: GetField) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for GetField {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::GetField) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<SetField> for Expr {
    #[inline]
    fn from(v: SetField) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for SetField {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::SetField) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<GetIndex> for Expr {
    #[inline]
    fn from(v: GetIndex) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for GetIndex {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::GetIndex) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<SetIndex> for Expr {
    #[inline]
    fn from(v: SetIndex) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for SetIndex {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::SetIndex) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Call> for Expr {
    #[inline]
    fn from(v: Call) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Call {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::Call) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<CallTable> for Expr {
    #[inline]
    fn from(v: CallTable) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for CallTable {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::CallTable) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Infix> for Expr {
    #[inline]
    fn from(v: Infix) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Infix {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::Infix) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Prefix> for Expr {
    #[inline]
    fn from(v: Prefix) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Prefix {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::Prefix) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<List> for Expr {
    #[inline]
    fn from(v: List) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for List {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::List) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Table> for Expr {
    #[inline]
    fn from(v: Table) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Table {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::Table) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Int32> for Expr {
    #[inline]
    fn from(v: Int32) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Int32 {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::Int32) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Int64> for Expr {
    #[inline]
    fn from(v: Int64) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Int64 {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::Int64) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Float32> for Expr {
    #[inline]
    fn from(v: Float32) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Float32 {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::Float32) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Float64> for Expr {
    #[inline]
    fn from(v: Float64) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Float64 {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::Float64) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Bool> for Expr {
    #[inline]
    fn from(v: Bool) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Bool {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::Bool) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Str> for Expr {
    #[inline]
    fn from(v: Str) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Str {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::Str) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

impl From<Nil> for Expr {
    #[inline]
    fn from(v: Nil) -> Self {
        Expr(v.0)
    }
}

impl TryFrom<Expr> for Nil {
    type Error = NodeCastError;
    #[inline]
    fn try_from(v: Expr) -> Result<Self, Self::Error> {
        if !matches!(v.0.kind(), NodeKind::Nil) {
            return Err(NodeCastError);
        }

        Ok(Self(v.0))
    }
}

pub mod spanned {
    use super::{Opt, Spanned};
    pub struct Root<'a> {
        pub body: &'a [Spanned<super::Stmt>],
    }
    pub struct Var {
        pub name: Spanned<super::Ident>,
        pub value: Spanned<super::Expr>,
    }
    pub struct Loop<'a> {
        pub body: &'a [Spanned<super::Stmt>],
    }
    pub struct FuncDecl<'a> {
        pub name: Spanned<super::Ident>,
        pub body: Spanned<super::Block>,
        pub params: &'a [Spanned<super::Ident>],
    }
    pub struct StmtExpr {
        pub inner: Spanned<super::Expr>,
    }
    pub struct Return {
        pub value: Spanned<Opt<super::Expr>>,
    }
    pub struct Break {}
    pub struct Continue {}
    pub struct IfSimple<'a> {
        pub cond: Spanned<super::Expr>,
        pub tail: Spanned<Opt<super::Block>>,
        pub body: &'a [Spanned<super::Stmt>],
    }
    pub struct IfMulti<'a> {
        pub tail: Spanned<Opt<super::Block>>,
        pub branches: &'a [Spanned<super::Branch>],
    }
    pub struct Block<'a> {
        pub body: &'a [Spanned<super::Stmt>],
    }
    pub struct FuncAnon<'a> {
        pub name: Spanned<Opt<super::Ident>>,
        pub body: Spanned<super::Block>,
        pub params: &'a [Spanned<super::Ident>],
    }
    pub struct GetVar {
        pub name: Spanned<super::Ident>,
    }
    pub struct SetVar {
        pub base: Spanned<super::GetVar>,
        pub value: Spanned<super::Expr>,
        pub op: super::AssignOp,
    }
    pub struct GetField {
        pub parent: Spanned<super::Expr>,
        pub key: Spanned<super::Ident>,
    }
    pub struct SetField {
        pub base: Spanned<super::GetField>,
        pub value: Spanned<super::Expr>,
        pub op: super::AssignOp,
    }
    pub struct GetIndex {
        pub parent: Spanned<super::Expr>,
        pub key: Spanned<super::Expr>,
    }
    pub struct SetIndex {
        pub base: Spanned<super::GetIndex>,
        pub value: Spanned<super::Expr>,
        pub op: super::AssignOp,
    }
    pub struct Call<'a> {
        pub callee: Spanned<super::Expr>,
        pub args: &'a [Spanned<super::Expr>],
    }
    pub struct CallTable<'a> {
        pub callee: Spanned<super::Expr>,
        pub args: &'a [Spanned<super::TableEntry>],
    }
    pub struct Infix {
        pub lhs: Spanned<super::Expr>,
        pub rhs: Spanned<super::Expr>,
        pub op: super::InfixOp,
    }
    pub struct Prefix {
        pub rhs: Spanned<super::Expr>,
        pub op: super::PrefixOp,
    }
    pub struct List<'a> {
        pub items: &'a [Spanned<super::Expr>],
    }
    pub struct Table<'a> {
        pub entries: &'a [Spanned<super::TableEntry>],
    }
    pub struct Int32 {
        pub value: i32,
    }
    pub struct Int64 {
        pub id: super::IntId,
    }
    pub struct Float32 {
        pub value: f32,
    }
    pub struct Float64 {
        pub id: super::FloatId,
    }
    pub struct Bool {
        pub value: bool,
    }
    pub struct Str {
        pub id: super::StrId,
    }
    pub struct Nil {}
    pub struct Branch<'a> {
        pub cond: Spanned<super::Expr>,
        pub body: &'a [Spanned<super::Stmt>],
    }
    pub struct TableEntry {
        pub key: Spanned<super::Str>,
        pub value: Spanned<super::Expr>,
    }
    pub struct Ident {
        pub id: super::IdentId,
    }
}

impl<'a> Pack for spanned::Root<'a> {
    type Node = Root;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { body } = self;
        let length = body.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let body = <_>::into_spanned_packed_slice(body);
        let index = ast.append(body);
        let node = Packed::variable_arity(NodeKind::Root, length, index);
        Root(node)
    }
}

impl Pack for spanned::Var {
    type Node = Var;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { name, value } = self;
        let name = name.map(|v| v.0);
        let value = value.map(|v| v.0);
        let index = ast.append(&[name, value]);
        let node = Packed::fixed_arity(NodeKind::Var, index);
        Var(node)
    }
}

impl<'a> Pack for spanned::Loop<'a> {
    type Node = Loop;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { body } = self;
        let length = body.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let body = <_>::into_spanned_packed_slice(body);
        let index = ast.append(body);
        let node = Packed::variable_arity(NodeKind::Loop, length, index);
        Loop(node)
    }
}

impl<'a> Pack for spanned::FuncDecl<'a> {
    type Node = FuncDecl;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { name, body, params } = self;
        let name = name.map(|v| v.0);
        let body = body.map(|v| v.0);
        let index = ast.append(&[name, body]);

        let length = params.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let params = <_>::into_spanned_packed_slice(params);
        let _ = ast.append(params);
        let node = Packed::mixed_arity(NodeKind::FuncDecl, length, index);
        FuncDecl(node)
    }
}

impl Pack for spanned::StmtExpr {
    type Node = StmtExpr;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { inner } = self;
        let inner = inner.map(|v| v.0);
        let index = ast.append(&[inner]);
        let node = Packed::fixed_arity(NodeKind::StmtExpr, index);
        StmtExpr(node)
    }
}

impl Pack for spanned::Return {
    type Node = Return;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { value } = self;
        let value = value.map(|v| v.0);
        let index = ast.append(&[value]);
        let node = Packed::fixed_arity(NodeKind::Return, index);
        Return(node)
    }
}

impl Pack for spanned::Break {
    type Node = Break;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = (self, ast);
        let node = Packed::kind_only(NodeKind::Break);
        Break(node)
    }
}

impl Pack for spanned::Continue {
    type Node = Continue;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = (self, ast);
        let node = Packed::kind_only(NodeKind::Continue);
        Continue(node)
    }
}

impl<'a> Pack for spanned::IfSimple<'a> {
    type Node = IfSimple;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { cond, tail, body } = self;
        let cond = cond.map(|v| v.0);
        let tail = tail.map(|v| v.0);
        let index = ast.append(&[cond, tail]);

        let length = body.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let body = <_>::into_spanned_packed_slice(body);
        let _ = ast.append(body);
        let node = Packed::mixed_arity(NodeKind::IfSimple, length, index);
        IfSimple(node)
    }
}

impl<'a> Pack for spanned::IfMulti<'a> {
    type Node = IfMulti;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { tail, branches } = self;
        let tail = tail.map(|v| v.0);
        let index = ast.append(&[tail]);

        let length = branches.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let branches = <_>::into_spanned_packed_slice(branches);
        let _ = ast.append(branches);
        let node = Packed::mixed_arity(NodeKind::IfMulti, length, index);
        IfMulti(node)
    }
}

impl<'a> Pack for spanned::Block<'a> {
    type Node = Block;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { body } = self;
        let length = body.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let body = <_>::into_spanned_packed_slice(body);
        let index = ast.append(body);
        let node = Packed::variable_arity(NodeKind::Block, length, index);
        Block(node)
    }
}

impl<'a> Pack for spanned::FuncAnon<'a> {
    type Node = FuncAnon;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { name, body, params } = self;
        let name = name.map(|v| v.0);
        let body = body.map(|v| v.0);
        let index = ast.append(&[name, body]);

        let length = params.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let params = <_>::into_spanned_packed_slice(params);
        let _ = ast.append(params);
        let node = Packed::mixed_arity(NodeKind::FuncAnon, length, index);
        FuncAnon(node)
    }
}

impl Pack for spanned::GetVar {
    type Node = GetVar;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { name } = self;
        let name = name.map(|v| v.0);
        let index = ast.append(&[name]);
        let node = Packed::fixed_arity(NodeKind::GetVar, index);
        GetVar(node)
    }
}

impl Pack for spanned::SetVar {
    type Node = SetVar;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { op, base, value } = self;
        let base = base.map(|v| v.0);
        let value = value.map(|v| v.0);
        let index = ast.append(&[base, value]);
        let op: u24 = op.into_u24();
        let node = Packed::fixed_arity_inline(NodeKind::SetVar, op, index);
        SetVar(node)
    }
}

impl Pack for spanned::GetField {
    type Node = GetField;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { parent, key } = self;
        let parent = parent.map(|v| v.0);
        let key = key.map(|v| v.0);
        let index = ast.append(&[parent, key]);
        let node = Packed::fixed_arity(NodeKind::GetField, index);
        GetField(node)
    }
}

impl Pack for spanned::SetField {
    type Node = SetField;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { op, base, value } = self;
        let base = base.map(|v| v.0);
        let value = value.map(|v| v.0);
        let index = ast.append(&[base, value]);
        let op: u24 = op.into_u24();
        let node = Packed::fixed_arity_inline(NodeKind::SetField, op, index);
        SetField(node)
    }
}

impl Pack for spanned::GetIndex {
    type Node = GetIndex;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { parent, key } = self;
        let parent = parent.map(|v| v.0);
        let key = key.map(|v| v.0);
        let index = ast.append(&[parent, key]);
        let node = Packed::fixed_arity(NodeKind::GetIndex, index);
        GetIndex(node)
    }
}

impl Pack for spanned::SetIndex {
    type Node = SetIndex;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { op, base, value } = self;
        let base = base.map(|v| v.0);
        let value = value.map(|v| v.0);
        let index = ast.append(&[base, value]);
        let op: u24 = op.into_u24();
        let node = Packed::fixed_arity_inline(NodeKind::SetIndex, op, index);
        SetIndex(node)
    }
}

impl<'a> Pack for spanned::Call<'a> {
    type Node = Call;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { callee, args } = self;
        let callee = callee.map(|v| v.0);
        let index = ast.append(&[callee]);

        let length = args.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let args = <_>::into_spanned_packed_slice(args);
        let _ = ast.append(args);
        let node = Packed::mixed_arity(NodeKind::Call, length, index);
        Call(node)
    }
}

impl<'a> Pack for spanned::CallTable<'a> {
    type Node = CallTable;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { callee, args } = self;
        let callee = callee.map(|v| v.0);
        let index = ast.append(&[callee]);

        let length = args.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let args = <_>::into_spanned_packed_slice(args);
        let _ = ast.append(args);
        let node = Packed::mixed_arity(NodeKind::CallTable, length, index);
        CallTable(node)
    }
}

impl Pack for spanned::Infix {
    type Node = Infix;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { op, lhs, rhs } = self;
        let lhs = lhs.map(|v| v.0);
        let rhs = rhs.map(|v| v.0);
        let index = ast.append(&[lhs, rhs]);
        let op: u24 = op.into_u24();
        let node = Packed::fixed_arity_inline(NodeKind::Infix, op, index);
        Infix(node)
    }
}

impl Pack for spanned::Prefix {
    type Node = Prefix;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { op, rhs } = self;
        let rhs = rhs.map(|v| v.0);
        let index = ast.append(&[rhs]);
        let op: u24 = op.into_u24();
        let node = Packed::fixed_arity_inline(NodeKind::Prefix, op, index);
        Prefix(node)
    }
}

impl<'a> Pack for spanned::List<'a> {
    type Node = List;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { items } = self;
        let length = items.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let items = <_>::into_spanned_packed_slice(items);
        let index = ast.append(items);
        let node = Packed::variable_arity(NodeKind::List, length, index);
        List(node)
    }
}

impl<'a> Pack for spanned::Table<'a> {
    type Node = Table;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { entries } = self;
        let length = entries.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let entries = <_>::into_spanned_packed_slice(entries);
        let index = ast.append(entries);
        let node = Packed::variable_arity(NodeKind::Table, length, index);
        Table(node)
    }
}

impl Pack for spanned::Int32 {
    type Node = Int32;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = ast;
        let Self { value } = self;
        let value: u56 = value.into_u56();
        let node = Packed::inline(NodeKind::Int32, value);
        Int32(node)
    }
}

impl Pack for spanned::Int64 {
    type Node = Int64;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = ast;
        let Self { id } = self;
        let id: u56 = id.into_u56();
        let node = Packed::inline(NodeKind::Int64, id);
        Int64(node)
    }
}

impl Pack for spanned::Float32 {
    type Node = Float32;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = ast;
        let Self { value } = self;
        let value: u56 = value.into_u56();
        let node = Packed::inline(NodeKind::Float32, value);
        Float32(node)
    }
}

impl Pack for spanned::Float64 {
    type Node = Float64;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = ast;
        let Self { id } = self;
        let id: u56 = id.into_u56();
        let node = Packed::inline(NodeKind::Float64, id);
        Float64(node)
    }
}

impl Pack for spanned::Bool {
    type Node = Bool;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = ast;
        let Self { value } = self;
        let value: u56 = value.into_u56();
        let node = Packed::inline(NodeKind::Bool, value);
        Bool(node)
    }
}

impl Pack for spanned::Str {
    type Node = Str;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = ast;
        let Self { id } = self;
        let id: u56 = id.into_u56();
        let node = Packed::inline(NodeKind::Str, id);
        Str(node)
    }
}

impl Pack for spanned::Nil {
    type Node = Nil;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = (self, ast);
        let node = Packed::kind_only(NodeKind::Nil);
        Nil(node)
    }
}

impl<'a> Pack for spanned::Branch<'a> {
    type Node = Branch;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { cond, body } = self;
        let cond = cond.map(|v| v.0);
        let index = ast.append(&[cond]);

        let length = body.len();
        if length > u24::MAX.get() as usize {
            panic!("length is out of bounds for u24");
        }
        let length = u24::new(length as u32);
        let body = <_>::into_spanned_packed_slice(body);
        let _ = ast.append(body);
        let node = Packed::mixed_arity(NodeKind::Branch, length, index);
        Branch(node)
    }
}

impl Pack for spanned::TableEntry {
    type Node = TableEntry;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let Self { key, value } = self;
        let key = key.map(|v| v.0);
        let value = value.map(|v| v.0);
        let index = ast.append(&[key, value]);
        let node = Packed::fixed_arity(NodeKind::TableEntry, index);
        TableEntry(node)
    }
}

impl Pack for spanned::Ident {
    type Node = Ident;

    #[inline]
    fn pack(self, ast: &mut Ast) -> Self::Node {
        let _ = ast;
        let Self { id } = self;
        let id: u56 = id.into_u56();
        let node = Packed::inline(NodeKind::Ident, id);
        Ident(node)
    }
}

impl<'a> Node<'a, Root> {
    #[inline]
    pub fn body(&self) -> NodeList<'a, Stmt> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        NodeList {
            ast: self.ast,
            nodes: unsafe { Stmt::from_packed_slice(nodes) },
        }
    }
}

impl<'a> Node<'a, Var> {
    #[inline(always)]
    pub fn name(&self) -> Node<'a, Ident> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Ident>::from_packed(node) },
        }
    }

    #[inline(always)]
    pub fn value(&self) -> Node<'a, Expr> {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_fixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Expr>::from_packed(node) },
        }
    }
}

impl<'a> Node<'a, Loop> {
    #[inline]
    pub fn body(&self) -> NodeList<'a, Stmt> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        NodeList {
            ast: self.ast,
            nodes: unsafe { Stmt::from_packed_slice(nodes) },
        }
    }
}

impl<'a> Node<'a, FuncDecl> {
    #[inline(always)]
    pub fn name(&self) -> Node<'a, Ident> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Ident>::from_packed(node) },
        }
    }

    #[inline(always)]
    pub fn body(&self) -> Node<'a, Block> {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Block>::from_packed(node) },
        }
    }

    #[inline]
    pub fn params(&self) -> NodeList<'a, Ident> {
        const OFFSET: usize = 2;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let length = repr.tail_length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        NodeList {
            ast: self.ast,
            nodes: unsafe { Ident::from_packed_slice(nodes) },
        }
    }
}

impl<'a> Node<'a, StmtExpr> {
    #[inline(always)]
    pub fn inner(&self) -> Node<'a, Expr> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Expr>::from_packed(node) },
        }
    }
}

impl<'a> Node<'a, Return> {
    #[inline(always)]
    pub fn value(&self) -> Node<'a, Opt<Expr>> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Opt<Expr>>::from_packed(node) },
        }
    }
}

impl<'a> Node<'a, IfSimple> {
    #[inline(always)]
    pub fn cond(&self) -> Node<'a, Expr> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Expr>::from_packed(node) },
        }
    }

    #[inline(always)]
    pub fn tail(&self) -> Node<'a, Opt<Block>> {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Opt<Block>>::from_packed(node) },
        }
    }

    #[inline]
    pub fn body(&self) -> NodeList<'a, Stmt> {
        const OFFSET: usize = 2;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let length = repr.tail_length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        NodeList {
            ast: self.ast,
            nodes: unsafe { Stmt::from_packed_slice(nodes) },
        }
    }
}

impl<'a> Node<'a, IfMulti> {
    #[inline(always)]
    pub fn tail(&self) -> Node<'a, Opt<Block>> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Opt<Block>>::from_packed(node) },
        }
    }

    #[inline]
    pub fn branches(&self) -> NodeList<'a, Branch> {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let length = repr.tail_length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        NodeList {
            ast: self.ast,
            nodes: unsafe { Branch::from_packed_slice(nodes) },
        }
    }
}

impl<'a> Node<'a, Block> {
    #[inline]
    pub fn body(&self) -> NodeList<'a, Stmt> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        NodeList {
            ast: self.ast,
            nodes: unsafe { Stmt::from_packed_slice(nodes) },
        }
    }
}

impl<'a> Node<'a, FuncAnon> {
    #[inline(always)]
    pub fn name(&self) -> Node<'a, Opt<Ident>> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Opt<Ident>>::from_packed(node) },
        }
    }

    #[inline(always)]
    pub fn body(&self) -> Node<'a, Block> {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Block>::from_packed(node) },
        }
    }

    #[inline]
    pub fn params(&self) -> NodeList<'a, Ident> {
        const OFFSET: usize = 2;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let length = repr.tail_length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        NodeList {
            ast: self.ast,
            nodes: unsafe { Ident::from_packed_slice(nodes) },
        }
    }
}

impl<'a> Node<'a, GetVar> {
    #[inline(always)]
    pub fn name(&self) -> Node<'a, Ident> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Ident>::from_packed(node) },
        }
    }
}

impl<'a> Node<'a, SetVar> {
    #[inline(always)]
    pub fn base(&self) -> Node<'a, GetVar> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <GetVar>::from_packed(node) },
        }
    }

    #[inline(always)]
    pub fn value(&self) -> Node<'a, Expr> {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Expr>::from_packed(node) },
        }
    }

    #[inline(always)]
    pub fn op(&self) -> ValueNode<'a, AssignOp> {
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        ValueNode {
            ast: self.ast,
            value: <AssignOp>::from_u24(repr.value),
        }
    }
}

impl<'a> Node<'a, GetField> {
    #[inline(always)]
    pub fn parent(&self) -> Node<'a, Expr> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Expr>::from_packed(node) },
        }
    }

    #[inline(always)]
    pub fn key(&self) -> Node<'a, Ident> {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_fixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Ident>::from_packed(node) },
        }
    }
}

impl<'a> Node<'a, SetField> {
    #[inline(always)]
    pub fn base(&self) -> Node<'a, GetField> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <GetField>::from_packed(node) },
        }
    }

    #[inline(always)]
    pub fn value(&self) -> Node<'a, Expr> {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Expr>::from_packed(node) },
        }
    }

    #[inline(always)]
    pub fn op(&self) -> ValueNode<'a, AssignOp> {
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        ValueNode {
            ast: self.ast,
            value: <AssignOp>::from_u24(repr.value),
        }
    }
}

impl<'a> Node<'a, GetIndex> {
    #[inline(always)]
    pub fn parent(&self) -> Node<'a, Expr> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Expr>::from_packed(node) },
        }
    }

    #[inline(always)]
    pub fn key(&self) -> Node<'a, Expr> {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_fixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Expr>::from_packed(node) },
        }
    }
}

impl<'a> Node<'a, SetIndex> {
    #[inline(always)]
    pub fn base(&self) -> Node<'a, GetIndex> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <GetIndex>::from_packed(node) },
        }
    }

    #[inline(always)]
    pub fn value(&self) -> Node<'a, Expr> {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Expr>::from_packed(node) },
        }
    }

    #[inline(always)]
    pub fn op(&self) -> ValueNode<'a, AssignOp> {
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        ValueNode {
            ast: self.ast,
            value: <AssignOp>::from_u24(repr.value),
        }
    }
}

impl<'a> Node<'a, Call> {
    #[inline(always)]
    pub fn callee(&self) -> Node<'a, Expr> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Expr>::from_packed(node) },
        }
    }

    #[inline]
    pub fn args(&self) -> NodeList<'a, Expr> {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let length = repr.tail_length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        NodeList {
            ast: self.ast,
            nodes: unsafe { Expr::from_packed_slice(nodes) },
        }
    }
}

impl<'a> Node<'a, CallTable> {
    #[inline(always)]
    pub fn callee(&self) -> Node<'a, Expr> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Expr>::from_packed(node) },
        }
    }

    #[inline]
    pub fn args(&self) -> NodeList<'a, TableEntry> {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let length = repr.tail_length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        NodeList {
            ast: self.ast,
            nodes: unsafe { TableEntry::from_packed_slice(nodes) },
        }
    }
}

impl<'a> Node<'a, Infix> {
    #[inline(always)]
    pub fn lhs(&self) -> Node<'a, Expr> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Expr>::from_packed(node) },
        }
    }

    #[inline(always)]
    pub fn rhs(&self) -> Node<'a, Expr> {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Expr>::from_packed(node) },
        }
    }

    #[inline(always)]
    pub fn op(&self) -> ValueNode<'a, InfixOp> {
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        ValueNode {
            ast: self.ast,
            value: <InfixOp>::from_u24(repr.value),
        }
    }
}

impl<'a> Node<'a, Prefix> {
    #[inline(always)]
    pub fn rhs(&self) -> Node<'a, Expr> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Expr>::from_packed(node) },
        }
    }

    #[inline(always)]
    pub fn op(&self) -> ValueNode<'a, PrefixOp> {
        let repr = unsafe { self.node.0.as_fixed_arity_inline() };
        ValueNode {
            ast: self.ast,
            value: <PrefixOp>::from_u24(repr.value),
        }
    }
}

impl<'a> Node<'a, List> {
    #[inline]
    pub fn items(&self) -> NodeList<'a, Expr> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        NodeList {
            ast: self.ast,
            nodes: unsafe { Expr::from_packed_slice(nodes) },
        }
    }
}

impl<'a> Node<'a, Table> {
    #[inline]
    pub fn entries(&self) -> NodeList<'a, TableEntry> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        NodeList {
            ast: self.ast,
            nodes: unsafe { TableEntry::from_packed_slice(nodes) },
        }
    }
}

impl<'a> Node<'a, Int32> {
    #[inline(always)]
    pub fn value(&self) -> ValueNode<'a, i32> {
        let repr = unsafe { self.node.0.as_inline() };
        ValueNode {
            ast: self.ast,
            value: <i32>::from_u56(repr.value),
        }
    }
}

impl<'a> Node<'a, Int64> {
    #[inline(always)]
    pub fn id(&self) -> ValueNode<'a, IntId> {
        let repr = unsafe { self.node.0.as_inline() };
        ValueNode {
            ast: self.ast,
            value: <IntId>::from_u56(repr.value),
        }
    }
}

impl<'a> Node<'a, Float32> {
    #[inline(always)]
    pub fn value(&self) -> ValueNode<'a, f32> {
        let repr = unsafe { self.node.0.as_inline() };
        ValueNode {
            ast: self.ast,
            value: <f32>::from_u56(repr.value),
        }
    }
}

impl<'a> Node<'a, Float64> {
    #[inline(always)]
    pub fn id(&self) -> ValueNode<'a, FloatId> {
        let repr = unsafe { self.node.0.as_inline() };
        ValueNode {
            ast: self.ast,
            value: <FloatId>::from_u56(repr.value),
        }
    }
}

impl<'a> Node<'a, Bool> {
    #[inline(always)]
    pub fn value(&self) -> ValueNode<'a, bool> {
        let repr = unsafe { self.node.0.as_inline() };
        ValueNode {
            ast: self.ast,
            value: <bool>::from_u56(repr.value),
        }
    }
}

impl<'a> Node<'a, Str> {
    #[inline(always)]
    pub fn id(&self) -> ValueNode<'a, StrId> {
        let repr = unsafe { self.node.0.as_inline() };
        ValueNode {
            ast: self.ast,
            value: <StrId>::from_u56(repr.value),
        }
    }
}

impl<'a> Node<'a, Branch> {
    #[inline(always)]
    pub fn cond(&self) -> Node<'a, Expr> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Expr>::from_packed(node) },
        }
    }

    #[inline]
    pub fn body(&self) -> NodeList<'a, Stmt> {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_mixed_arity() };
        let index = repr.index as usize;
        let length = repr.tail_length.get() as usize;
        let nodes = unsafe {
            self.ast
                .nodes
                .get_unchecked(index + OFFSET..index + OFFSET + length)
        };
        NodeList {
            ast: self.ast,
            nodes: unsafe { Stmt::from_packed_slice(nodes) },
        }
    }
}

impl<'a> Node<'a, TableEntry> {
    #[inline(always)]
    pub fn key(&self) -> Node<'a, Str> {
        const OFFSET: usize = 0;
        let repr = unsafe { self.node.0.as_fixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Str>::from_packed(node) },
        }
    }

    #[inline(always)]
    pub fn value(&self) -> Node<'a, Expr> {
        const OFFSET: usize = 1;
        let repr = unsafe { self.node.0.as_fixed_arity() };
        let index = repr.index as usize;
        let node = unsafe { self.ast.nodes.get_unchecked(index + OFFSET) };
        Node {
            ast: self.ast,
            node: unsafe { <Expr>::from_packed(node) },
        }
    }
}

impl<'a> Node<'a, Ident> {
    #[inline(always)]
    pub fn id(&self) -> ValueNode<'a, IdentId> {
        let repr = unsafe { self.node.0.as_inline() };
        ValueNode {
            ast: self.ast,
            value: <IdentId>::from_u56(repr.value),
        }
    }
}

impl<'a> Node<'a, Root> {
    #[inline]
    pub fn body_spans(&self) -> &'a [Span] {
        let repr = unsafe { self.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        &self.ast.spans[index..index + length]
    }
}

impl<'a> Node<'a, Var> {
    #[inline]
    pub fn name_span(&self) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        self.ast.spans[index + 0]
    }

    #[inline]
    pub fn value_span(&self) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        self.ast.spans[index + 1]
    }
}

impl<'a> Node<'a, Loop> {
    #[inline]
    pub fn body_spans(&self) -> &'a [Span] {
        let repr = unsafe { self.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        &self.ast.spans[index..index + length]
    }
}

impl<'a> Node<'a, FuncDecl> {
    #[inline]
    pub fn name_span(&self) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        self.ast.spans[index + 0]
    }

    #[inline]
    pub fn body_span(&self) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        self.ast.spans[index + 1]
    }

    #[inline]
    pub fn params_spans(&self) -> &'a [Span] {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = 2 + repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        &self.ast.spans[index..index + tail_length]
    }
}

impl<'a> Node<'a, StmtExpr> {
    #[inline]
    pub fn inner_span(&self) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        self.ast.spans[index + 0]
    }
}

impl<'a> Node<'a, Return> {
    #[inline]
    pub fn value_span(&self) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        self.ast.spans[index + 0]
    }
}

impl<'a> Node<'a, IfSimple> {
    #[inline]
    pub fn cond_span(&self) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        self.ast.spans[index + 0]
    }

    #[inline]
    pub fn tail_span(&self) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        self.ast.spans[index + 1]
    }

    #[inline]
    pub fn body_spans(&self) -> &'a [Span] {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = 2 + repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        &self.ast.spans[index..index + tail_length]
    }
}

impl<'a> Node<'a, IfMulti> {
    #[inline]
    pub fn tail_span(&self) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        self.ast.spans[index + 0]
    }

    #[inline]
    pub fn branches_spans(&self) -> &'a [Span] {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = 1 + repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        &self.ast.spans[index..index + tail_length]
    }
}

impl<'a> Node<'a, Block> {
    #[inline]
    pub fn body_spans(&self) -> &'a [Span] {
        let repr = unsafe { self.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        &self.ast.spans[index..index + length]
    }
}

impl<'a> Node<'a, FuncAnon> {
    #[inline]
    pub fn name_span(&self) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        self.ast.spans[index + 0]
    }

    #[inline]
    pub fn body_span(&self) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        self.ast.spans[index + 1]
    }

    #[inline]
    pub fn params_spans(&self) -> &'a [Span] {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = 2 + repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        &self.ast.spans[index..index + tail_length]
    }
}

impl<'a> Node<'a, GetVar> {
    #[inline]
    pub fn name_span(&self) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        self.ast.spans[index + 0]
    }
}

impl<'a> Node<'a, SetVar> {
    #[inline]
    pub fn base_span(&self) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        self.ast.spans[index + 0]
    }

    #[inline]
    pub fn value_span(&self) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        self.ast.spans[index + 1]
    }
}

impl<'a> Node<'a, GetField> {
    #[inline]
    pub fn parent_span(&self) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        self.ast.spans[index + 0]
    }

    #[inline]
    pub fn key_span(&self) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        self.ast.spans[index + 1]
    }
}

impl<'a> Node<'a, SetField> {
    #[inline]
    pub fn base_span(&self) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        self.ast.spans[index + 0]
    }

    #[inline]
    pub fn value_span(&self) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        self.ast.spans[index + 1]
    }
}

impl<'a> Node<'a, GetIndex> {
    #[inline]
    pub fn parent_span(&self) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        self.ast.spans[index + 0]
    }

    #[inline]
    pub fn key_span(&self) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        self.ast.spans[index + 1]
    }
}

impl<'a> Node<'a, SetIndex> {
    #[inline]
    pub fn base_span(&self) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        self.ast.spans[index + 0]
    }

    #[inline]
    pub fn value_span(&self) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        self.ast.spans[index + 1]
    }
}

impl<'a> Node<'a, Call> {
    #[inline]
    pub fn callee_span(&self) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        self.ast.spans[index + 0]
    }

    #[inline]
    pub fn args_spans(&self) -> &'a [Span] {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = 1 + repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        &self.ast.spans[index..index + tail_length]
    }
}

impl<'a> Node<'a, CallTable> {
    #[inline]
    pub fn callee_span(&self) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        self.ast.spans[index + 0]
    }

    #[inline]
    pub fn args_spans(&self) -> &'a [Span] {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = 1 + repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        &self.ast.spans[index..index + tail_length]
    }
}

impl<'a> Node<'a, Infix> {
    #[inline]
    pub fn lhs_span(&self) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        self.ast.spans[index + 0]
    }

    #[inline]
    pub fn rhs_span(&self) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        self.ast.spans[index + 1]
    }
}

impl<'a> Node<'a, Prefix> {
    #[inline]
    pub fn rhs_span(&self) -> Span {
        let repr = unsafe { self.0.as_fixed_arity_inline() };
        let index = repr.index as usize;
        self.ast.spans[index + 0]
    }
}

impl<'a> Node<'a, List> {
    #[inline]
    pub fn items_spans(&self) -> &'a [Span] {
        let repr = unsafe { self.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        &self.ast.spans[index..index + length]
    }
}

impl<'a> Node<'a, Table> {
    #[inline]
    pub fn entries_spans(&self) -> &'a [Span] {
        let repr = unsafe { self.0.as_variable_arity() };
        let index = repr.index as usize;
        let length = repr.length.get() as usize;
        &self.ast.spans[index..index + length]
    }
}

impl<'a> Node<'a, Branch> {
    #[inline]
    pub fn cond_span(&self) -> Span {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = repr.index as usize;
        self.ast.spans[index + 0]
    }

    #[inline]
    pub fn body_spans(&self) -> &'a [Span] {
        let repr = unsafe { self.0.as_mixed_arity() };
        let index = 1 + repr.index as usize;
        let tail_length = repr.tail_length.get() as usize;
        &self.ast.spans[index..index + tail_length]
    }
}

impl<'a> Node<'a, TableEntry> {
    #[inline]
    pub fn key_span(&self) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        self.ast.spans[index + 0]
    }

    #[inline]
    pub fn value_span(&self) -> Span {
        let repr = unsafe { self.0.as_fixed_arity() };
        let index = repr.index as usize;
        self.ast.spans[index + 1]
    }
}

impl<'a> std::fmt::Debug for Node<'a, Stmt> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.kind() {
            StmtKind::Var(node) => std::fmt::Debug::fmt(&node, f),
            StmtKind::Loop(node) => std::fmt::Debug::fmt(&node, f),
            StmtKind::FuncDecl(node) => std::fmt::Debug::fmt(&node, f),
            StmtKind::StmtExpr(node) => std::fmt::Debug::fmt(&node, f),
        }
    }
}

impl<'a> std::fmt::Debug for Node<'a, Expr> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.kind() {
            ExprKind::Return(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::Break(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::Continue(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::IfSimple(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::IfMulti(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::Block(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::FuncAnon(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::GetVar(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::SetVar(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::GetField(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::SetField(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::GetIndex(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::SetIndex(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::Call(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::CallTable(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::Infix(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::Prefix(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::List(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::Table(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::Int32(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::Int64(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::Float32(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::Float64(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::Bool(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::Str(node) => std::fmt::Debug::fmt(&node, f),
            ExprKind::Nil(node) => std::fmt::Debug::fmt(&node, f),
        }
    }
}

impl<'a> std::fmt::Debug for Node<'a, Root> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Root")
            .field(&DebugIter(self.body().iter()))
            .finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, Var> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Var")
            .field(&self.name())
            .field(&self.value())
            .finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, Loop> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Loop")
            .field(&DebugIter(self.body().iter()))
            .finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, FuncDecl> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("FuncDecl")
            .field(&self.name())
            .field(&self.body())
            .field(&DebugIter(self.params().iter()))
            .finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, StmtExpr> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("StmtExpr").field(&self.inner()).finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, Return> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Return")
            .field(&self.value().as_option())
            .finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, Break> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Break")?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, Continue> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Continue")?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, IfSimple> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("IfSimple")
            .field(&self.cond())
            .field(&self.tail().as_option())
            .field(&DebugIter(self.body().iter()))
            .finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, IfMulti> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("IfMulti")
            .field(&self.tail().as_option())
            .field(&DebugIter(self.branches().iter()))
            .finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, Block> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Block")
            .field(&DebugIter(self.body().iter()))
            .finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, FuncAnon> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("FuncAnon")
            .field(&self.name().as_option())
            .field(&self.body())
            .field(&DebugIter(self.params().iter()))
            .finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, GetVar> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("GetVar").field(&self.name()).finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, SetVar> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("SetVar")
            .field(&self.op())
            .field(&self.base())
            .field(&self.value())
            .finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, GetField> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("GetField")
            .field(&self.parent())
            .field(&self.key())
            .finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, SetField> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("SetField")
            .field(&self.op())
            .field(&self.base())
            .field(&self.value())
            .finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, GetIndex> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("GetIndex")
            .field(&self.parent())
            .field(&self.key())
            .finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, SetIndex> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("SetIndex")
            .field(&self.op())
            .field(&self.base())
            .field(&self.value())
            .finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, Call> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Call")
            .field(&self.callee())
            .field(&DebugIter(self.args().iter()))
            .finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, CallTable> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("CallTable")
            .field(&self.callee())
            .field(&DebugIter(self.args().iter()))
            .finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, Infix> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Infix")
            .field(&self.op())
            .field(&self.lhs())
            .field(&self.rhs())
            .finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, Prefix> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Prefix")
            .field(&self.op())
            .field(&self.rhs())
            .finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, List> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("List")
            .field(&DebugIter(self.items().iter()))
            .finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, Table> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Table")
            .field(&DebugIter(self.entries().iter()))
            .finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, Int32> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Int32").field(&self.value()).finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, Int64> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Int64").field(&self.id()).finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, Float32> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Float32").field(&self.value()).finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, Float64> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Float64").field(&self.id()).finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, Bool> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Bool").field(&self.value()).finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, Str> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Str").field(&self.id()).finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, Nil> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Nil")?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, Branch> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Branch")
            .field(&self.cond())
            .field(&DebugIter(self.body().iter()))
            .finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, TableEntry> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("TableEntry")
            .field(&self.key())
            .field(&self.value())
            .finish()?;

        Ok(())
    }
}

impl<'a> std::fmt::Debug for Node<'a, Ident> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_tuple("Ident").field(&self.id()).finish()?;

        Ok(())
    }
}
