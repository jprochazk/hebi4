use std::sync::Arc;

use beef::lean::Cow;

use crate::{
    codegen::{
        EmitOptions, emit,
        opcodes::{FnId, Insn, Reg},
    },
    error::Result,
    parser::parse,
    span::Span,
    token::tokenize,
    vm::value::StringHasher,
};

/// Represents the result of code generation: A list of functions with
/// one of them marked as the entrypoint.
///
/// Can be executed in a [`Vm`].
///
/// Modules are immutable and internally reference counted.
pub struct Module {
    repr: Arc<ModuleRepr>,
}

#[repr(align(16))]
struct ModuleRepr {
    name: Cow<'static, str>,
    main: FnId,
    functions: Box<[FuncInfo]>,
}

impl Module {
    #[inline]
    pub(crate) fn new(
        name: Cow<'static, str>,
        main: FnId,
        functions: impl IntoIterator<Item = FuncInfo>,
    ) -> Self {
        Self {
            repr: Arc::new(ModuleRepr {
                name,
                main,
                functions: std::vec::Vec::from_iter(functions).into_boxed_slice(),
            }),
        }
    }

    #[inline]
    fn inner(&self) -> *const ModuleRepr {
        &*self.repr
    }

    #[inline]
    fn main(&self) -> FnId {
        self.repr.main
    }

    #[inline]
    pub(crate) fn name(&self) -> &str {
        &self.repr.name
    }

    #[inline]
    pub(crate) fn functions(&self) -> &[FuncInfo] {
        &*self.repr.functions
    }

    /// Compile Hebi source code into a [`Module`].
    ///
    /// The resulting error can be rendered using [`Error::render`][error::Error::render].
    pub fn compile(name: Option<Cow<'static, str>>, src: &str) -> Result<Self> {
        Self::compile_with(name, src, Default::default())
    }

    pub fn compile_with(
        name: Option<Cow<'static, str>>,
        src: &str,
        options: EmitOptions,
    ) -> Result<Self> {
        let tokens = tokenize(&src);
        let ast = parse(&tokens)?;
        let name = name.unwrap_or_else(|| {
            let src_hash = StringHasher::default().hash_str(src);
            format!("anon#{src_hash}").into()
        });
        emit(name, &ast, options)
    }
}

// TODO(opt): colocate data (?)
/// A function "prototype".
///
/// Stores the bytecode and associated constants generated by the compiler.
#[must_use]
pub struct FuncInfo {
    name: Cow<'static, str>,

    nparams: u8,
    nstack: u8,

    /// Bytecode.
    code: Box<[Insn]>,

    /// Constants referenced by the function's bytecode.
    literals: Box<[Literal]>,

    dbg: Option<Arc<FuncDebugInfo>>,
}

impl FuncInfo {
    #[inline]
    pub(crate) fn new(
        name: impl Into<Cow<'static, str>>,
        nparams: u8,
        nstack: u8,
        code: std::vec::Vec<Insn>,
        literals: std::vec::Vec<Literal>,
        dbg: FuncDebugInfo,
    ) -> Self {
        Self {
            name: name.into(),
            nparams,
            nstack,
            code: code.into_boxed_slice(),
            literals: literals.into_boxed_slice(),
            dbg: Some(Arc::new(dbg)),
        }
    }

    #[inline]
    pub fn name(&self) -> &str {
        self.name.as_ref()
    }

    #[inline]
    pub fn arity(&self) -> u8 {
        self.nparams
    }

    #[inline]
    pub fn stack_size(&self) -> u8 {
        self.nstack
    }

    #[inline]
    pub fn code(&self) -> &[Insn] {
        &self.code
    }

    #[inline]
    pub fn literals(&self) -> &[Literal] {
        &self.literals
    }

    #[inline]
    pub fn dbg(&self) -> Option<&Arc<FuncDebugInfo>> {
        self.dbg.as_ref()
    }
}

pub struct FuncDebugInfo {
    pub(crate) spans: Box<[Span]>,
    pub(crate) locals: Box<[Local]>,
}

#[derive(Clone, Copy)]
pub struct Local {
    pub(crate) span: Span,
    pub(crate) reg: Reg,
}

#[derive(Debug)]
pub enum Literal {
    Nil,
    Bool(bool),
    Int(i64),
    Float(f64),
    String(String),
}

impl Literal {
    pub fn nil(&self) -> Option<()> {
        if let Self::Nil = self { Some(()) } else { None }
    }

    pub fn bool(&self) -> Option<&bool> {
        if let Self::Bool(v) = self {
            Some(v)
        } else {
            None
        }
    }

    pub fn int(&self) -> Option<&i64> {
        if let Self::Int(v) = self {
            Some(v)
        } else {
            None
        }
    }

    pub fn num(&self) -> Option<&f64> {
        if let Self::Float(v) = self {
            Some(v)
        } else {
            None
        }
    }

    pub fn str(&self) -> Option<&String> {
        if let Self::String(v) = self {
            Some(v)
        } else {
            None
        }
    }
}

impl std::fmt::Display for Literal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Literal::Nil => f.write_str("nil"),
            Literal::Bool(v) => write!(f, "{v}"),
            Literal::Int(v) => write!(f, "{v}"),
            Literal::Float(v) => write!(f, "{v:?}"),
            Literal::String(v) => write!(f, "{v:?}"),
        }
    }
}
