pub mod native;

use std::sync::Arc;

use beef::lean::Cow;
pub use native::{
    NativeFunction, NativeModule, Param, TryFromHebiValueRaw, TryIntoHebiValueRaw, Value, f,
};

use crate::{
    codegen::{
        EmitOptions, emit,
        opcodes::{FnId, Insn, Mvar, Reg, Uv},
    },
    error::Result,
    parser::parse,
    span::Span,
    token::tokenize,
    vm::value::StringHasher,
};

/// Represents the result of code generation: A list of functions with
/// one of them marked as the entrypoint.
///
/// Can be executed in a [`Vm`].
///
/// Modules are immutable and internally reference counted.
pub struct Module {
    repr: Arc<ModuleRepr>,
}

#[repr(align(16))]
struct ModuleRepr {
    name: Cow<'static, str>,
    main: FnId,
    functions: Box<[FuncInfo]>,
    module_vars: usize,
}

impl Module {
    #[inline]
    pub(crate) fn new(
        name: Cow<'static, str>,
        main: FnId,
        functions: impl IntoIterator<Item = FuncInfo>,
        module_vars: usize,
    ) -> Self {
        Self {
            repr: Arc::new(ModuleRepr {
                name,
                main,
                functions: std::vec::Vec::from_iter(functions).into_boxed_slice(),
                module_vars,
            }),
        }
    }

    #[inline]
    fn inner(&self) -> *const ModuleRepr {
        &*self.repr
    }

    #[inline]
    fn main(&self) -> FnId {
        self.repr.main
    }

    #[inline]
    pub(crate) fn name(&self) -> &str {
        &self.repr.name
    }

    #[inline]
    pub(crate) fn functions(&self) -> &[FuncInfo] {
        &*self.repr.functions
    }

    #[inline]
    pub(crate) fn module_vars(&self) -> usize {
        self.repr.module_vars
    }

    /// Compile Hebi source code into a [`Module`].
    ///
    /// The resulting error can be rendered using [`Error::render`][error::Error::render].
    pub fn compile(name: Option<Cow<'static, str>>, src: &str) -> Result<Self> {
        Self::compile_with(name, src, Default::default())
    }

    pub fn compile_with(
        name: Option<Cow<'static, str>>,
        src: &str,
        options: EmitOptions,
    ) -> Result<Self> {
        let tokens = tokenize(&src);
        let ast = parse(&tokens)?;
        let name = name.unwrap_or_else(|| {
            let src_hash = StringHasher::default().hash_str(src);
            format!("anon#{src_hash}").into()
        });
        emit(name, &ast, options)
    }
}

// TODO(opt): colocate data (?)
/// A function "prototype".
///
/// Stores the bytecode and associated constants generated by the compiler.
#[must_use]
pub struct FuncInfo {
    name: Cow<'static, str>,

    nparams: u8,
    nstack: u8,

    /// Bytecode.
    code: Box<[Insn]>,

    /// Constants referenced by the function's bytecode.
    literals: Box<[Literal]>,

    dbg: Option<Arc<FuncDebugInfo>>,
}

impl FuncInfo {
    #[inline]
    pub(crate) fn new(
        name: impl Into<Cow<'static, str>>,
        nparams: u8,
        nstack: u8,
        code: std::vec::Vec<Insn>,
        literals: std::vec::Vec<Literal>,
        dbg: FuncDebugInfo,
    ) -> Self {
        Self {
            name: name.into(),
            nparams,
            nstack,
            code: code.into_boxed_slice(),
            literals: literals.into_boxed_slice(),
            dbg: Some(Arc::new(dbg)),
        }
    }

    #[inline]
    pub fn name(&self) -> &str {
        self.name.as_ref()
    }

    #[inline]
    pub fn arity(&self) -> u8 {
        self.nparams
    }

    #[inline]
    pub fn stack_size(&self) -> u8 {
        self.nstack
    }

    #[inline]
    pub fn code(&self) -> &[Insn] {
        &self.code
    }

    #[inline]
    pub fn literals(&self) -> &[Literal] {
        &self.literals
    }

    #[inline]
    pub fn dbg(&self) -> Option<&Arc<FuncDebugInfo>> {
        self.dbg.as_ref()
    }
}

pub struct FuncDebugInfo {
    pub(crate) spans: Box<[Span]>,
    pub(crate) locals: Box<[Local]>,
    pub(crate) upvalues: Box<[Upvalue]>,
}

#[derive(Clone, Copy)]
pub struct Local {
    pub(crate) span: Span,
    pub(crate) reg: Reg,
}

#[derive(Clone, Copy)]
pub struct Upvalue {
    pub(crate) span: Span,
    pub(crate) info: UpvalueDescriptor,
}

#[derive(Debug)]
pub struct ClosureInfo {
    pub(crate) func: FnId,
    pub(crate) upvalues: Box<[UpvalueDescriptor]>,
}

impl ClosureInfo {
    pub(crate) fn new(func: FnId, upvalues: std::vec::Vec<UpvalueDescriptor>) -> Self {
        Self {
            func,
            upvalues: upvalues.into_boxed_slice(),
        }
    }
}

#[derive(Debug, Clone, Copy)]
pub enum UpvalueDescriptor {
    Reg(Reg),
    Uv(Uv),
}

/// Information about an import statement.
#[derive(Debug)]
pub enum ImportInfo {
    /// Bare import: `import "spec" as name`
    /// Imports the entire module into a single register.
    Bare { spec: String, dst: ImportBinding },
    /// Named imports: `import a as x, b as y from "spec"`
    /// Imports specific names from the module into separate registers.
    Named {
        spec: String,
        bindings: Box<[(String, ImportBinding)]>,
    },
}

#[derive(Debug, Clone, Copy)]
pub enum ImportBinding {
    Reg(Reg),
    Mvar(Mvar),
}

impl ImportInfo {
    pub(crate) fn bare(spec: String, dst: ImportBinding) -> Self {
        Self::Bare { spec, dst }
    }

    pub(crate) fn named(spec: String, bindings: std::vec::Vec<(String, ImportBinding)>) -> Self {
        Self::Named {
            spec,
            bindings: bindings.into_boxed_slice(),
        }
    }
}

#[derive(Debug)]
pub enum Literal {
    Nil,
    Bool(bool),
    Int(i64),
    Float(f64),
    String(String),
    ClosureInfo(ClosureInfo),
    ImportInfo(ImportInfo),
}

impl Literal {
    pub fn nil(&self) -> Option<()> {
        if let Self::Nil = self { Some(()) } else { None }
    }

    pub fn bool(&self) -> Option<&bool> {
        if let Self::Bool(v) = self {
            Some(v)
        } else {
            None
        }
    }

    pub fn int(&self) -> Option<&i64> {
        if let Self::Int(v) = self {
            Some(v)
        } else {
            None
        }
    }

    pub fn num(&self) -> Option<&f64> {
        if let Self::Float(v) = self {
            Some(v)
        } else {
            None
        }
    }

    pub fn str(&self) -> Option<&String> {
        if let Self::String(v) = self {
            Some(v)
        } else {
            None
        }
    }

    pub fn closure(&self) -> Option<&ClosureInfo> {
        if let Self::ClosureInfo(v) = self {
            Some(v)
        } else {
            None
        }
    }

    pub fn import(&self) -> Option<&ImportInfo> {
        if let Self::ImportInfo(v) = self {
            Some(v)
        } else {
            None
        }
    }
}

impl std::fmt::Display for Literal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Literal::Nil => f.write_str("nil"),
            Literal::Bool(v) => write!(f, "{v}"),
            Literal::Int(v) => write!(f, "{v}"),
            Literal::Float(v) => write!(f, "{v:?}"),
            Literal::String(v) => {
                if v.len() < 50 {
                    write!(f, "{v:?}")
                } else {
                    write!(f, "{:?}...", &v[0..50])
                }
            }
            Literal::ClosureInfo(v) => {
                write!(f, "{{{f}, n={n}}}", f = v.func, n = v.upvalues.len())
            }
            Literal::ImportInfo(v) => match v {
                ImportInfo::Bare { spec, dst } => match dst {
                    ImportBinding::Reg(reg) => write!(f, "{{import {spec:?} -> {reg}}}"),
                    ImportBinding::Mvar(mvar) => write!(f, "{{import {spec:?} -> {mvar}}}"),
                },
                ImportInfo::Named { spec, bindings } => {
                    write!(f, "{{import {:?}, n={}}}", spec, bindings.len())
                }
            },
        }
    }
}

impl std::fmt::Display for UpvalueDescriptor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            UpvalueDescriptor::Reg(reg) => write!(f, "{reg}"),
            UpvalueDescriptor::Uv(cap) => write!(f, "{cap}"),
        }
    }
}
