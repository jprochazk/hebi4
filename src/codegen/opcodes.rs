// Generated by asmgen at 2025-10-11T20:20:30.28196632+00:00[UTC]
//
// See `asmgen/src/main.rs` and `asmgen/src/runtime.rs`
#![allow(unsafe_op_in_unsafe_fn)]

mod private {
    pub trait Sealed {}
}

use super::{Context, Control, Literal, ValueRaw};

pub trait OperandPack: private::Sealed + Sized {}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Sp(pub(crate) *mut ValueRaw);

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Ip(pub(crate) *const RawInstruction);

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct RawInstruction(u32);

impl RawInstruction {
    #[inline]
    pub fn tag(self) -> isize {
        (self.0 & 0xFF) as isize
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Jt(pub(crate) *const OpaqueOp);

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Lp(pub(crate) *const Literal);

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Ctx(pub(crate) *mut Context);

const _: () = {
    use std::mem::align_of;
    assert!(align_of::<JumpTable>() == align_of::<[OpaqueOp; 1]>());
};

#[allow(non_camel_case_types)]
#[derive(Clone, Copy, Hash)]
#[repr(C, packed)]
pub struct u24([u8; 3]);

impl u24 {
    pub const MAX: u24 = u24([255; 3]);
    pub const MIN: u24 = u24([0; 3]);
    pub const ZERO: u24 = u24([0; 3]);

    #[inline]
    pub const fn new(v: u32) -> Self {
        if v > Self::MAX.get() {
            panic!("value is out of bounds for u24");
        }

        unsafe { Self::new_unchecked(v) }
    }

    #[inline]
    pub const unsafe fn new_unchecked(v: u32) -> Self {
        debug_assert!(v <= Self::MAX.get());
        let [a, b, c, _] = v.to_le_bytes();
        Self([a, b, c])
    }

    #[inline]
    pub const fn get(self) -> u32 {
        let [a, b, c] = self.0;
        u32::from_le_bytes([a, b, c, 0])
    }

    #[inline]
    pub const fn as_i24(self) -> i24 {
        i24(self)
    }
}

impl PartialEq for u24 {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        PartialEq::eq(&self.get(), &other.get())
    }
}

impl Eq for u24 {}

impl PartialOrd for u24 {
    #[inline]
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        PartialOrd::partial_cmp(&self.get(), &other.get())
    }
}

impl Ord for u24 {
    #[inline]
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        Ord::cmp(&self.get(), &other.get())
    }
}

impl std::fmt::Debug for u24 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        <u32 as std::fmt::Debug>::fmt(&self.get(), f)
    }
}

impl std::fmt::Display for u24 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        <u32 as std::fmt::Display>::fmt(&self.get(), f)
    }
}

impl TryFrom<usize> for u24 {
    type Error = ();

    fn try_from(value: usize) -> Result<Self, Self::Error> {
        if value > u24::MAX.zx() as usize {
            return Err(());
        }

        Ok(unsafe { u24::new_unchecked(value as u32) })
    }
}

#[allow(non_camel_case_types)]
#[derive(Clone, Copy, Hash)]
#[repr(transparent)]
pub struct i24(u24);

impl i24 {
    pub const MAX: i24 = i24(unsafe { u24::new_unchecked(16_777_215) });
    pub const MIN: i24 = i24(u24::ZERO);
    pub const ZERO: i24 = i24(unsafe { u24::new_unchecked(8_388_608) });

    const OFFSET: u32 = 8_388_608; // 2^23, which is i24::MAX + 1

    #[inline]
    pub const fn new(v: i32) -> Self {
        if v > Self::MAX.get() || v < Self::MIN.get() {
            panic!("value is out of bounds for i24");
        }

        unsafe { Self::new_unchecked(v) }
    }

    #[inline]
    pub const unsafe fn new_unchecked(v: i32) -> Self {
        Self(u24::new_unchecked((v as u32).wrapping_add(Self::OFFSET)))
    }

    #[inline]
    pub const fn get(self) -> i32 {
        self.0.get().wrapping_sub(Self::OFFSET) as i32
    }

    #[inline]
    pub const fn as_u24(self) -> u24 {
        self.0
    }
}

impl PartialEq for i24 {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.0.eq(&other.0)
    }
}

impl Eq for i24 {}

impl PartialOrd for i24 {
    #[inline]
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        self.0.partial_cmp(&other.0)
    }
}

impl Ord for i24 {
    #[inline]
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.0.cmp(&other.0)
    }
}

impl std::fmt::Debug for i24 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        <i32 as std::fmt::Debug>::fmt(&self.get(), f)
    }
}

impl std::fmt::Display for i24 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        <i32 as std::fmt::Display>::fmt(&self.get(), f)
    }
}

impl TryFrom<isize> for i24 {
    type Error = ();

    fn try_from(value: isize) -> Result<Self, Self::Error> {
        if value > i24::MAX.get() as isize || value < i24::MIN.get() as isize {
            return Err(());
        }

        Ok(unsafe { i24::new_unchecked(value as i32) })
    }
}

#[cfg(not(windows))]
macro_rules! Op {
    (
        fn ($($ty:ty),* $(,)?) -> $ret:ty
    ) => {
        unsafe extern "C" fn($($ty),*) -> $ret
    };
}

#[cfg(windows)]
macro_rules! Op {
    (
        fn ($($ty:ty),* $(,)?) -> $ret:ty
    ) => {
        unsafe extern "sysv64" fn($($ty),*) -> $ret
    };
}

#[cfg(not(windows))]
macro_rules! op {
    (
        unsafe extern "?" fn $name:ident($($i:ident : $ty:ty),* $(,)?) -> $ret:ty $body:block
    ) => {
        unsafe extern "C" fn $name($($i:$ty),*) -> $ret $body
    };
}

#[cfg(windows)]
macro_rules! op {
    (
        unsafe extern "?" fn $name:ident($($i:ident : $ty:ty),* $(,)?) -> $ret:ty $body:block
    ) => {
        unsafe extern "sysv64" fn $name($($i:$ty),*) -> $ret $body
    };
}

macro_rules! jump_table {
    {
        $($op:ident),* $(,)?
    } => {
        JumpTable {
            $($op: {
                type __Operands = $crate::codegen::opcodes::__operands::$op;
                const __OP: unsafe fn(__Operands, Jt, Sp, Lp, Ip, Ctx) -> Control = $op;

                {
                    op! {
                        unsafe extern "?" fn $op(args: RawInstruction, jt: Jt, sp: Sp, lp: Lp, ip: Ip, ctx: Ctx) -> Control {
                            let args: __Operands = core::mem::transmute(args);
                            __OP(args, jt, sp, lp, ip, ctx)
                        }
                    }

                    $op
                }
            }),*
        }
    };
}

pub type Op<Operands> = Op!(fn(Operands, Jt, Sp, Lp, Ip, Ctx) -> Control);

pub type OpaqueOp = Op!(fn(RawInstruction, Jt, Sp, Lp, Ip, Ctx) -> Control);

macro_rules! declare_operand_type {
    ($name:ident, $ty:ident, $fmt:literal) => {
        #[derive(Debug, Clone, Copy)]
        #[repr(transparent)]
        #[must_use = "unused operand"]
        pub struct $name($ty);

        impl $name {
            #[inline(always)]
            pub fn get(self) -> $ty {
                self.0
            }

            #[inline(always)]
            pub const unsafe fn new_unchecked(v: $ty) -> Self {
                Self(v)
            }

            #[inline(always)]
            pub fn zx(self) -> usize {
                self.0.zx()
            }

            #[inline(always)]
            pub fn sz(self) -> isize {
                self.0.sz()
            }
        }

        impl std::fmt::Display for $name {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(f, $fmt, self.0)
            }
        }
    };
}

trait ExtendEx: Sized {
    fn zx(self) -> usize;
    fn sz(self) -> isize;
}

macro_rules! extend_primitive {
    ($ty:ty) => {
        impl ExtendEx for $ty {
            #[inline(always)]
            fn zx(self) -> usize {
                self as usize
            }

            #[inline(always)]
            fn sz(self) -> isize {
                self as isize
            }
        }
    };
}

extend_primitive!(u8);
extend_primitive!(u16);
extend_primitive!(i16);

impl ExtendEx for u24 {
    #[inline(always)]
    fn zx(self) -> usize {
        self.get() as usize
    }

    #[inline(always)]
    fn sz(self) -> isize {
        self.get() as isize
    }
}

impl ExtendEx for i24 {
    fn zx(self) -> usize {
        self.get() as usize
    }

    fn sz(self) -> isize {
        self.get() as isize
    }
}

macro_rules! declare_operand_types {
    (
        $(
            $name:ident($ty:ident) = $fmt:literal
        ),* $(,)?
    ) => {
        $(
            declare_operand_type!($name, $ty, $fmt);
        )*
    };
}

declare_operand_types! {
    Reg(u8) = "r{}",

    Mvar(u16) = "m{}",
    Cap(u8) = "c{}",

    Lit(u16) = "l{}",
    Lit8(u8) = "l{}",

    FnId(u16) = "fn{}",

    Imm8(u8) = "{}",
    Imm16(u16) = "{}",
    Imm16s(i16) = "{}",
    Imm24(u24) = "{}",
    Imm24s(i24) = "{}",
}

const fn assert_bit_equal<A, B>(a: &A, b: &B) {
    let a: [u32; 1] = unsafe { (a as *const A as *const [u32; 1]).read() };
    let b: [u32; 1] = unsafe { (b as *const B as *const [u32; 1]).read() };
    if a[0] != b[0] {
        panic!("not bit equal");
    }
}

// ...

#[derive(Clone, Copy)]
#[repr(u8, align(4))]
pub enum Instruction {
    Nop { _a: u8, _b: u8, _c: u8 } = 0,
    Mov { dst: Reg, src: Reg, _c: u8 } = 1,
    Lmvar { dst: Reg, src: Mvar } = 2,
    Smvar { src: Reg, dst: Mvar } = 3,
    Lcap { dst: Reg, src: Cap, _c: u8 } = 4,
    Scap { dst: Cap, src: Reg, _c: u8 } = 5,
    Lidx { dst: Reg, target: Reg, idx: Reg } = 6,
    Lidxn { dst: Reg, target: Reg, idx: Lit8 } = 7,
    Sidx { target: Reg, idx: Reg, src: Reg } = 8,
    Sidxn { target: Reg, idx: Lit8, src: Reg } = 9,
    Lkey { dst: Reg, target: Reg, key: Reg } = 10,
    Lkeyc { dst: Reg, target: Reg, key: Lit8 } = 11,
    Skey { target: Reg, key: Reg, src: Reg } = 12,
    Skeyc { target: Reg, key: Lit8, src: Reg } = 13,
    Lnil { dst: Reg, _b: u8, _c: u8 } = 14,
    Lsmi { dst: Reg, v: Imm16s } = 15,
    Ltrue { dst: Reg, _b: u8, _c: u8 } = 16,
    Lfalse { dst: Reg, _b: u8, _c: u8 } = 17,
    Lint { dst: Reg, id: Lit } = 18,
    Lnum { dst: Reg, id: Lit } = 19,
    Lstr { dst: Reg, id: Lit } = 20,
    Lclosure { dst: Reg, id: Lit } = 21,
    Lfunc { dst: Reg, id: Lit } = 22,
    Llist { dst: Reg, cap: Imm16 } = 23,
    Ltable { dst: Reg, cap: Imm16 } = 24,
    Jmp { rel: Imm24s } = 25,
    Istrue { v: Reg, _b: u8, _c: u8 } = 26,
    Isfalse { v: Reg, _b: u8, _c: u8 } = 27,
    Istruec { dst: Reg, v: Reg, _c: u8 } = 28,
    Isfalsec { dst: Reg, v: Reg, _c: u8 } = 29,
    Islt { lhs: Reg, rhs: Reg, _c: u8 } = 30,
    Isle { lhs: Reg, rhs: Reg, _c: u8 } = 31,
    Isgt { lhs: Reg, rhs: Reg, _c: u8 } = 32,
    Isge { lhs: Reg, rhs: Reg, _c: u8 } = 33,
    Iseq { lhs: Reg, rhs: Reg, _c: u8 } = 34,
    Isne { lhs: Reg, rhs: Reg, _c: u8 } = 35,
    Iseqs { lhs: Reg, rhs: Lit } = 36,
    Isnes { lhs: Reg, rhs: Lit } = 37,
    Iseqn { lhs: Reg, rhs: Lit } = 38,
    Isnen { lhs: Reg, rhs: Lit } = 39,
    Iseqp { lhs: Reg, rhs: Imm8, _c: u8 } = 40,
    Isnep { lhs: Reg, rhs: Imm8, _c: u8 } = 41,
    Isltv { dst: Reg, lhs: Reg, rhs: Reg } = 42,
    Islev { dst: Reg, lhs: Reg, rhs: Reg } = 43,
    Isgtv { dst: Reg, lhs: Reg, rhs: Reg } = 44,
    Isgev { dst: Reg, lhs: Reg, rhs: Reg } = 45,
    Iseqv { dst: Reg, lhs: Reg, rhs: Reg } = 46,
    Isnev { dst: Reg, lhs: Reg, rhs: Reg } = 47,
    Addvv { dst: Reg, lhs: Reg, rhs: Reg } = 48,
    Addvn { dst: Reg, lhs: Reg, rhs: Lit8 } = 49,
    Addnv { dst: Reg, lhs: Lit8, rhs: Reg } = 50,
    Subvv { dst: Reg, lhs: Reg, rhs: Reg } = 51,
    Subvn { dst: Reg, lhs: Reg, rhs: Lit8 } = 52,
    Subnv { dst: Reg, lhs: Lit8, rhs: Reg } = 53,
    Mulvv { dst: Reg, lhs: Reg, rhs: Reg } = 54,
    Mulvn { dst: Reg, lhs: Reg, rhs: Lit8 } = 55,
    Mulnv { dst: Reg, lhs: Lit8, rhs: Reg } = 56,
    Divvv { dst: Reg, lhs: Reg, rhs: Reg } = 57,
    Divvn { dst: Reg, lhs: Reg, rhs: Lit8 } = 58,
    Divnv { dst: Reg, lhs: Lit8, rhs: Reg } = 59,
    Unm { dst: Reg, rhs: Reg, _c: u8 } = 60,
    Not { dst: Reg, rhs: Reg, _c: u8 } = 61,
    Call { dst: Reg, args: Imm8, _c: u8 } = 62,
    Fastcall { dst: Reg, id: FnId } = 63,
    Ret { _a: u8, _b: u8, _c: u8 } = 64,
    Stop { _a: u8, _b: u8, _c: u8 } = 65,
}

// assert compatibility with `u32`
const _: () = assert!(std::mem::size_of::<Instruction>() == std::mem::size_of::<u32>());
const _: () = assert!(std::mem::align_of::<Instruction>() == std::mem::align_of::<u32>());

#[doc = "Do nothing."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Nop {
    _op: u8,
    _a: u8,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Nop>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Nop>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Nop {
        _op: 0,
        _a: 0x7A,
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Nop {
        _a: 0x7A,
        _b: 0x7B,
        _c: 0x7C,
    },
);

#[doc = "Move value from register `src` to register `dst`."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Mov {
    _op: u8,
    pub dst: Reg,
    pub src: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Mov>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Mov>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Mov {
        _op: 1,
        dst: Reg(0x7A),
        src: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Mov {
        dst: Reg(0x7A),
        src: Reg(0x7B),
        _c: 0x7C,
    },
);

#[doc = "Load module variable `src` to register `dst`."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lmvar {
    _op: u8,
    pub dst: Reg,
    pub src: Mvar,
}

const _: () = assert!(std::mem::size_of::<Lmvar>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lmvar>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lmvar {
        _op: 2,
        dst: Reg(0x7A),
        src: Mvar(0x7B7C),
    },
    &Instruction::Lmvar {
        dst: Reg(0x7A),
        src: Mvar(0x7B7C),
    },
);

#[doc = "Store register `dst` into module variable `mvar`."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Smvar {
    _op: u8,
    pub src: Reg,
    pub dst: Mvar,
}

const _: () = assert!(std::mem::size_of::<Smvar>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Smvar>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Smvar {
        _op: 3,
        src: Reg(0x7A),
        dst: Mvar(0x7B7C),
    },
    &Instruction::Smvar {
        src: Reg(0x7A),
        dst: Mvar(0x7B7C),
    },
);

#[doc = "Load current closure's capture `src` to register `dst`."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lcap {
    _op: u8,
    pub dst: Reg,
    pub src: Cap,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Lcap>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lcap>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lcap {
        _op: 4,
        dst: Reg(0x7A),
        src: Cap(0x7B),
        _c: 0x7C,
    },
    &Instruction::Lcap {
        dst: Reg(0x7A),
        src: Cap(0x7B),
        _c: 0x7C,
    },
);

#[doc = "Store register `src` to current closure's capture `dst`."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Scap {
    _op: u8,
    pub dst: Cap,
    pub src: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Scap>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Scap>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Scap {
        _op: 5,
        dst: Cap(0x7A),
        src: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Scap {
        dst: Cap(0x7A),
        src: Reg(0x7B),
        _c: 0x7C,
    },
);

#[doc = "Load index `idx` (register) from `target` (array) to register `dst`."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lidx {
    _op: u8,
    pub dst: Reg,
    pub target: Reg,
    pub idx: Reg,
}

const _: () = assert!(std::mem::size_of::<Lidx>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lidx>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lidx {
        _op: 6,
        dst: Reg(0x7A),
        target: Reg(0x7B),
        idx: Reg(0x7C),
    },
    &Instruction::Lidx {
        dst: Reg(0x7A),
        target: Reg(0x7B),
        idx: Reg(0x7C),
    },
);

#[doc = "Load index `idx` (literal) from `target` (array) to register `dst`."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lidxn {
    _op: u8,
    pub dst: Reg,
    pub target: Reg,
    pub idx: Lit8,
}

const _: () = assert!(std::mem::size_of::<Lidxn>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lidxn>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lidxn {
        _op: 7,
        dst: Reg(0x7A),
        target: Reg(0x7B),
        idx: Lit8(0x7C),
    },
    &Instruction::Lidxn {
        dst: Reg(0x7A),
        target: Reg(0x7B),
        idx: Lit8(0x7C),
    },
);

#[doc = "Store value from `src` into `idx` (register) in `target` (array)."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Sidx {
    _op: u8,
    pub target: Reg,
    pub idx: Reg,
    pub src: Reg,
}

const _: () = assert!(std::mem::size_of::<Sidx>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Sidx>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Sidx {
        _op: 8,
        target: Reg(0x7A),
        idx: Reg(0x7B),
        src: Reg(0x7C),
    },
    &Instruction::Sidx {
        target: Reg(0x7A),
        idx: Reg(0x7B),
        src: Reg(0x7C),
    },
);

#[doc = "Store value from `src` into `idx` (register) in `target` (array)."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Sidxn {
    _op: u8,
    pub target: Reg,
    pub idx: Lit8,
    pub src: Reg,
}

const _: () = assert!(std::mem::size_of::<Sidxn>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Sidxn>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Sidxn {
        _op: 9,
        target: Reg(0x7A),
        idx: Lit8(0x7B),
        src: Reg(0x7C),
    },
    &Instruction::Sidxn {
        target: Reg(0x7A),
        idx: Lit8(0x7B),
        src: Reg(0x7C),
    },
);

#[doc = "Load `key` (register) from `target` (object) to register `dst` (object)."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lkey {
    _op: u8,
    pub dst: Reg,
    pub target: Reg,
    pub key: Reg,
}

const _: () = assert!(std::mem::size_of::<Lkey>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lkey>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lkey {
        _op: 10,
        dst: Reg(0x7A),
        target: Reg(0x7B),
        key: Reg(0x7C),
    },
    &Instruction::Lkey {
        dst: Reg(0x7A),
        target: Reg(0x7B),
        key: Reg(0x7C),
    },
);

#[doc = "Load `key` (literal) from `target` (object) to register `dst` (object)."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lkeyc {
    _op: u8,
    pub dst: Reg,
    pub target: Reg,
    pub key: Lit8,
}

const _: () = assert!(std::mem::size_of::<Lkeyc>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lkeyc>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lkeyc {
        _op: 11,
        dst: Reg(0x7A),
        target: Reg(0x7B),
        key: Lit8(0x7C),
    },
    &Instruction::Lkeyc {
        dst: Reg(0x7A),
        target: Reg(0x7B),
        key: Lit8(0x7C),
    },
);

#[doc = "Store value from `src` into `key` (register) in `target` (object)."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Skey {
    _op: u8,
    pub target: Reg,
    pub key: Reg,
    pub src: Reg,
}

const _: () = assert!(std::mem::size_of::<Skey>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Skey>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Skey {
        _op: 12,
        target: Reg(0x7A),
        key: Reg(0x7B),
        src: Reg(0x7C),
    },
    &Instruction::Skey {
        target: Reg(0x7A),
        key: Reg(0x7B),
        src: Reg(0x7C),
    },
);

#[doc = "Store value from `src` into `key` (literal) in `target` (object)."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Skeyc {
    _op: u8,
    pub target: Reg,
    pub key: Lit8,
    pub src: Reg,
}

const _: () = assert!(std::mem::size_of::<Skeyc>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Skeyc>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Skeyc {
        _op: 13,
        target: Reg(0x7A),
        key: Lit8(0x7B),
        src: Reg(0x7C),
    },
    &Instruction::Skeyc {
        target: Reg(0x7A),
        key: Lit8(0x7B),
        src: Reg(0x7C),
    },
);

#[doc = "Load `nil` value into register `dst`."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lnil {
    _op: u8,
    pub dst: Reg,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Lnil>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lnil>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lnil {
        _op: 14,
        dst: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Lnil {
        dst: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
);

#[doc = "Load 16-bit integer `v` into register `dst`."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lsmi {
    _op: u8,
    pub dst: Reg,
    pub v: Imm16s,
}

const _: () = assert!(std::mem::size_of::<Lsmi>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lsmi>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lsmi {
        _op: 15,
        dst: Reg(0x7A),
        v: Imm16s(0x7B7C),
    },
    &Instruction::Lsmi {
        dst: Reg(0x7A),
        v: Imm16s(0x7B7C),
    },
);

#[doc = "Load literal `true` into register `dst`."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Ltrue {
    _op: u8,
    pub dst: Reg,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Ltrue>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Ltrue>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Ltrue {
        _op: 16,
        dst: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Ltrue {
        dst: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
);

#[doc = "Load literal `false` into register `dst`."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lfalse {
    _op: u8,
    pub dst: Reg,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Lfalse>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lfalse>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lfalse {
        _op: 17,
        dst: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Lfalse {
        dst: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
);

#[doc = "Load literal by `id` into register `dst`.

`id` holds a 64-bit integer."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lint {
    _op: u8,
    pub dst: Reg,
    pub id: Lit,
}

const _: () = assert!(std::mem::size_of::<Lint>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lint>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lint {
        _op: 18,
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
    &Instruction::Lint {
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
);

#[doc = "Load literal by `id` into register `dst`.

`id` holds a 64-bit float."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lnum {
    _op: u8,
    pub dst: Reg,
    pub id: Lit,
}

const _: () = assert!(std::mem::size_of::<Lnum>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lnum>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lnum {
        _op: 19,
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
    &Instruction::Lnum {
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
);

#[doc = "Load literal by `id` into register `dst`.

`id` holds a string literal."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lstr {
    _op: u8,
    pub dst: Reg,
    pub id: Lit,
}

const _: () = assert!(std::mem::size_of::<Lstr>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lstr>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lstr {
        _op: 20,
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
    &Instruction::Lstr {
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
);

#[doc = "Load closure function by `id` into register `dst`.

`id` holds a ClosureInfo."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lclosure {
    _op: u8,
    pub dst: Reg,
    pub id: Lit,
}

const _: () = assert!(std::mem::size_of::<Lclosure>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lclosure>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lclosure {
        _op: 21,
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
    &Instruction::Lclosure {
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
);

#[doc = "Load function by `id` into register `dst`.

`id` holds a FuncInfo.

This implies no captures, but the resulting object
is still a `Closure`."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lfunc {
    _op: u8,
    pub dst: Reg,
    pub id: Lit,
}

const _: () = assert!(std::mem::size_of::<Lfunc>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lfunc>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lfunc {
        _op: 22,
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
    &Instruction::Lfunc {
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
);

#[doc = "Allocate a list with `capacity` into register `dst`."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Llist {
    _op: u8,
    pub dst: Reg,
    pub cap: Imm16,
}

const _: () = assert!(std::mem::size_of::<Llist>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Llist>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Llist {
        _op: 23,
        dst: Reg(0x7A),
        cap: Imm16(0x7B7C),
    },
    &Instruction::Llist {
        dst: Reg(0x7A),
        cap: Imm16(0x7B7C),
    },
);

#[doc = "Allocate an object with `capacity` into register `dst`."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Ltable {
    _op: u8,
    pub dst: Reg,
    pub cap: Imm16,
}

const _: () = assert!(std::mem::size_of::<Ltable>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Ltable>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Ltable {
        _op: 24,
        dst: Reg(0x7A),
        cap: Imm16(0x7B7C),
    },
    &Instruction::Ltable {
        dst: Reg(0x7A),
        cap: Imm16(0x7B7C),
    },
);

#[doc = "Adjust instruction pointer by `rel`."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Jmp {
    _op: u8,
    pub rel: Imm24s,
}

const _: () = assert!(std::mem::size_of::<Jmp>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Jmp>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Jmp {
        _op: 25,
        rel: Imm24s(i24::new(0x7A7B7C)),
    },
    &Instruction::Jmp {
        rel: Imm24s(i24::new(0x7A7B7C)),
    },
);

#[doc = "Skip `jmp` if `v` coerced to bool is `true`"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Istrue {
    _op: u8,
    pub v: Reg,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Istrue>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Istrue>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Istrue {
        _op: 26,
        v: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Istrue {
        v: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
);

#[doc = "Skip `jmp` if `v` coerced to bool is `false`"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isfalse {
    _op: u8,
    pub v: Reg,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Isfalse>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isfalse>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isfalse {
        _op: 27,
        v: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Isfalse {
        v: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
);

#[doc = "If `v` coerced to bool is `true`:
- Set `dst` to original `v`
- Skip `jmp`"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Istruec {
    _op: u8,
    pub dst: Reg,
    pub v: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Istruec>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Istruec>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Istruec {
        _op: 28,
        dst: Reg(0x7A),
        v: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Istruec {
        dst: Reg(0x7A),
        v: Reg(0x7B),
        _c: 0x7C,
    },
);

#[doc = "If `v` coerced to bool is `false`:
- Set `dst` to original `v`
- Skip `jmp`"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isfalsec {
    _op: u8,
    pub dst: Reg,
    pub v: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Isfalsec>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isfalsec>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isfalsec {
        _op: 29,
        dst: Reg(0x7A),
        v: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Isfalsec {
        dst: Reg(0x7A),
        v: Reg(0x7B),
        _c: 0x7C,
    },
);

#[doc = "Skip `jmp` if `lhs < rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Islt {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Islt>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Islt>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Islt {
        _op: 30,
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Islt {
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[doc = "Skip `jmp` if `lhs <= rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isle {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Isle>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isle>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isle {
        _op: 31,
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Isle {
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[doc = "Skip `jmp` if `lhs > rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isgt {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Isgt>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isgt>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isgt {
        _op: 32,
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Isgt {
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[doc = "Skip `jmp` if `lhs >= rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isge {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Isge>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isge>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isge {
        _op: 33,
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Isge {
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[doc = "Skip `jmp` if `lhs == rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Iseq {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Iseq>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Iseq>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Iseq {
        _op: 34,
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Iseq {
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[doc = "Skip `jmp` if `lhs != rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isne {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Isne>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isne>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isne {
        _op: 35,
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Isne {
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[doc = "Skip `jmp` if `lhs == rhs` (register, literal string)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Iseqs {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Lit,
}

const _: () = assert!(std::mem::size_of::<Iseqs>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Iseqs>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Iseqs {
        _op: 36,
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
    &Instruction::Iseqs {
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
);

#[doc = "Skip `jmp` if `lhs != rhs` (register, literal string)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isnes {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Lit,
}

const _: () = assert!(std::mem::size_of::<Isnes>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isnes>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isnes {
        _op: 37,
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
    &Instruction::Isnes {
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
);

#[doc = "Skip `jmp` if `lhs == rhs` (register, literal number)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Iseqn {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Lit,
}

const _: () = assert!(std::mem::size_of::<Iseqn>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Iseqn>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Iseqn {
        _op: 38,
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
    &Instruction::Iseqn {
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
);

#[doc = "Skip `jmp` if `lhs != rhs` (register, literal number)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isnen {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Lit,
}

const _: () = assert!(std::mem::size_of::<Isnen>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isnen>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isnen {
        _op: 39,
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
    &Instruction::Isnen {
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
);

#[doc = "Skip `jmp` if `lhs == rhs` (register, primitive)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Iseqp {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Imm8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Iseqp>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Iseqp>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Iseqp {
        _op: 40,
        lhs: Reg(0x7A),
        rhs: Imm8(0x7B),
        _c: 0x7C,
    },
    &Instruction::Iseqp {
        lhs: Reg(0x7A),
        rhs: Imm8(0x7B),
        _c: 0x7C,
    },
);

#[doc = "Skip `jmp` if `lhs != rhs` (register, primitive)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isnep {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Imm8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Isnep>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isnep>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isnep {
        _op: 41,
        lhs: Reg(0x7A),
        rhs: Imm8(0x7B),
        _c: 0x7C,
    },
    &Instruction::Isnep {
        lhs: Reg(0x7A),
        rhs: Imm8(0x7B),
        _c: 0x7C,
    },
);

#[doc = "`dst = lhs < rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isltv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Isltv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isltv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isltv {
        _op: 42,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Isltv {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
);

#[doc = "`dst = lhs <= rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Islev {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Islev>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Islev>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Islev {
        _op: 43,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Islev {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
);

#[doc = "`dst = lhs > rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isgtv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Isgtv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isgtv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isgtv {
        _op: 44,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Isgtv {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
);

#[doc = "`dst = lhs >= rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isgev {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Isgev>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isgev>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isgev {
        _op: 45,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Isgev {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
);

#[doc = "`dst = lhs == rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Iseqv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Iseqv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Iseqv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Iseqv {
        _op: 46,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Iseqv {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
);

#[doc = "`dst = lhs != rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isnev {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Isnev>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isnev>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isnev {
        _op: 47,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Isnev {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
);

#[doc = "`dst = lhs + rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Addvv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Addvv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Addvv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Addvv {
        _op: 48,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Addvv {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
);

#[doc = "`dst = lhs + rhs` (register, literal)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Addvn {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Lit8,
}

const _: () = assert!(std::mem::size_of::<Addvn>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Addvn>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Addvn {
        _op: 49,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
    &Instruction::Addvn {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
);

#[doc = "`dst = lhs + rhs` (literal, register)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Addnv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Lit8,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Addnv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Addnv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Addnv {
        _op: 50,
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Addnv {
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
);

#[doc = "`dst = lhs - rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Subvv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Subvv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Subvv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Subvv {
        _op: 51,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Subvv {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
);

#[doc = "`dst = lhs - rhs` (register, literal)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Subvn {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Lit8,
}

const _: () = assert!(std::mem::size_of::<Subvn>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Subvn>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Subvn {
        _op: 52,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
    &Instruction::Subvn {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
);

#[doc = "`dst = lhs - rhs` (literal, register)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Subnv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Lit8,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Subnv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Subnv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Subnv {
        _op: 53,
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Subnv {
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
);

#[doc = "`dst = lhs * rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Mulvv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Mulvv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Mulvv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Mulvv {
        _op: 54,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Mulvv {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
);

#[doc = "`dst = lhs * rhs` (register, literal)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Mulvn {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Lit8,
}

const _: () = assert!(std::mem::size_of::<Mulvn>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Mulvn>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Mulvn {
        _op: 55,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
    &Instruction::Mulvn {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
);

#[doc = "`dst = lhs * rhs` (literal, register)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Mulnv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Lit8,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Mulnv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Mulnv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Mulnv {
        _op: 56,
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Mulnv {
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
);

#[doc = "`dst = lhs / rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Divvv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Divvv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Divvv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Divvv {
        _op: 57,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Divvv {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
);

#[doc = "`dst = lhs / rhs` (register, literal)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Divvn {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Lit8,
}

const _: () = assert!(std::mem::size_of::<Divvn>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Divvn>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Divvn {
        _op: 58,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
    &Instruction::Divvn {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
);

#[doc = "`dst = lhs / rhs` (literal, register)"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Divnv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Lit8,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Divnv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Divnv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Divnv {
        _op: 59,
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Divnv {
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
);

#[doc = "`dst = -rhs`"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Unm {
    _op: u8,
    pub dst: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Unm>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Unm>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Unm {
        _op: 60,
        dst: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Unm {
        dst: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[doc = "`dst = not rhs`"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Not {
    _op: u8,
    pub dst: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Not>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Not>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Not {
        _op: 61,
        dst: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Not {
        dst: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[doc = "`dst = dst(dst+1..dst+1+args)`"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Call {
    _op: u8,
    pub dst: Reg,
    pub args: Imm8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Call>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Call>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Call {
        _op: 62,
        dst: Reg(0x7A),
        args: Imm8(0x7B),
        _c: 0x7C,
    },
    &Instruction::Call {
        dst: Reg(0x7A),
        args: Imm8(0x7B),
        _c: 0x7C,
    },
);

#[doc = "`dst = funcs[id](dst..dst+funcs[id].args)`"]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Fastcall {
    _op: u8,
    pub dst: Reg,
    pub id: FnId,
}

const _: () = assert!(std::mem::size_of::<Fastcall>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Fastcall>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Fastcall {
        _op: 63,
        dst: Reg(0x7A),
        id: FnId(0x7B7C),
    },
    &Instruction::Fastcall {
        dst: Reg(0x7A),
        id: FnId(0x7B7C),
    },
);

#[doc = "Return from the current call."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Ret {
    _op: u8,
    _a: u8,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Ret>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Ret>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Ret {
        _op: 64,
        _a: 0x7A,
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Ret {
        _a: 0x7A,
        _b: 0x7B,
        _c: 0x7C,
    },
);

#[doc = "Stop execution, and yield to the VM's caller.
Never generated by the compiler."]
#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Stop {
    _op: u8,
    _a: u8,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Stop>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Stop>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Stop {
        _op: 65,
        _a: 0x7A,
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Stop {
        _a: 0x7A,
        _b: 0x7B,
        _c: 0x7C,
    },
);

#[doc(hidden)]
pub mod __operands {
    #![allow(non_camel_case_types)]

    pub type nop = super::Nop;
    pub type mov = super::Mov;
    pub type lmvar = super::Lmvar;
    pub type smvar = super::Smvar;
    pub type lcap = super::Lcap;
    pub type scap = super::Scap;
    pub type lidx = super::Lidx;
    pub type lidxn = super::Lidxn;
    pub type sidx = super::Sidx;
    pub type sidxn = super::Sidxn;
    pub type lkey = super::Lkey;
    pub type lkeyc = super::Lkeyc;
    pub type skey = super::Skey;
    pub type skeyc = super::Skeyc;
    pub type lnil = super::Lnil;
    pub type lsmi = super::Lsmi;
    pub type ltrue = super::Ltrue;
    pub type lfalse = super::Lfalse;
    pub type lint = super::Lint;
    pub type lnum = super::Lnum;
    pub type lstr = super::Lstr;
    pub type lclosure = super::Lclosure;
    pub type lfunc = super::Lfunc;
    pub type llist = super::Llist;
    pub type ltable = super::Ltable;
    pub type jmp = super::Jmp;
    pub type istrue = super::Istrue;
    pub type isfalse = super::Isfalse;
    pub type istruec = super::Istruec;
    pub type isfalsec = super::Isfalsec;
    pub type islt = super::Islt;
    pub type isle = super::Isle;
    pub type isgt = super::Isgt;
    pub type isge = super::Isge;
    pub type iseq = super::Iseq;
    pub type isne = super::Isne;
    pub type iseqs = super::Iseqs;
    pub type isnes = super::Isnes;
    pub type iseqn = super::Iseqn;
    pub type isnen = super::Isnen;
    pub type iseqp = super::Iseqp;
    pub type isnep = super::Isnep;
    pub type isltv = super::Isltv;
    pub type islev = super::Islev;
    pub type isgtv = super::Isgtv;
    pub type isgev = super::Isgev;
    pub type iseqv = super::Iseqv;
    pub type isnev = super::Isnev;
    pub type addvv = super::Addvv;
    pub type addvn = super::Addvn;
    pub type addnv = super::Addnv;
    pub type subvv = super::Subvv;
    pub type subvn = super::Subvn;
    pub type subnv = super::Subnv;
    pub type mulvv = super::Mulvv;
    pub type mulvn = super::Mulvn;
    pub type mulnv = super::Mulnv;
    pub type divvv = super::Divvv;
    pub type divvn = super::Divvn;
    pub type divnv = super::Divnv;
    pub type unm = super::Unm;
    pub type not = super::Not;
    pub type call = super::Call;
    pub type fastcall = super::Fastcall;
    pub type ret = super::Ret;
    pub type stop = super::Stop;
}

pub mod asm {
    use super::*;
    #[doc = "Do nothing."]
    pub const fn nop() -> Instruction {
        Instruction::Nop {
            _a: 0x7F,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
    #[doc = "Move value from register `src` to register `dst`."]
    pub const fn mov(dst: Reg, src: Reg) -> Instruction {
        Instruction::Mov { dst, src, _c: 0x7F }
    }
    #[doc = "Load module variable `src` to register `dst`."]
    pub const fn lmvar(dst: Reg, src: Mvar) -> Instruction {
        Instruction::Lmvar { dst, src }
    }
    #[doc = "Store register `dst` into module variable `mvar`."]
    pub const fn smvar(src: Reg, dst: Mvar) -> Instruction {
        Instruction::Smvar { src, dst }
    }
    #[doc = "Load current closure's capture `src` to register `dst`."]
    pub const fn lcap(dst: Reg, src: Cap) -> Instruction {
        Instruction::Lcap { dst, src, _c: 0x7F }
    }
    #[doc = "Store register `src` to current closure's capture `dst`."]
    pub const fn scap(dst: Cap, src: Reg) -> Instruction {
        Instruction::Scap { dst, src, _c: 0x7F }
    }
    #[doc = "Load index `idx` (register) from `target` (array) to register `dst`."]
    pub const fn lidx(dst: Reg, target: Reg, idx: Reg) -> Instruction {
        Instruction::Lidx { dst, target, idx }
    }
    #[doc = "Load index `idx` (literal) from `target` (array) to register `dst`."]
    pub const fn lidxn(dst: Reg, target: Reg, idx: Lit8) -> Instruction {
        Instruction::Lidxn { dst, target, idx }
    }
    #[doc = "Store value from `src` into `idx` (register) in `target` (array)."]
    pub const fn sidx(target: Reg, idx: Reg, src: Reg) -> Instruction {
        Instruction::Sidx { target, idx, src }
    }
    #[doc = "Store value from `src` into `idx` (register) in `target` (array)."]
    pub const fn sidxn(target: Reg, idx: Lit8, src: Reg) -> Instruction {
        Instruction::Sidxn { target, idx, src }
    }
    #[doc = "Load `key` (register) from `target` (object) to register `dst` (object)."]
    pub const fn lkey(dst: Reg, target: Reg, key: Reg) -> Instruction {
        Instruction::Lkey { dst, target, key }
    }
    #[doc = "Load `key` (literal) from `target` (object) to register `dst` (object)."]
    pub const fn lkeyc(dst: Reg, target: Reg, key: Lit8) -> Instruction {
        Instruction::Lkeyc { dst, target, key }
    }
    #[doc = "Store value from `src` into `key` (register) in `target` (object)."]
    pub const fn skey(target: Reg, key: Reg, src: Reg) -> Instruction {
        Instruction::Skey { target, key, src }
    }
    #[doc = "Store value from `src` into `key` (literal) in `target` (object)."]
    pub const fn skeyc(target: Reg, key: Lit8, src: Reg) -> Instruction {
        Instruction::Skeyc { target, key, src }
    }
    #[doc = "Load `nil` value into register `dst`."]
    pub const fn lnil(dst: Reg) -> Instruction {
        Instruction::Lnil {
            dst,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
    #[doc = "Load 16-bit integer `v` into register `dst`."]
    pub const fn lsmi(dst: Reg, v: Imm16s) -> Instruction {
        Instruction::Lsmi { dst, v }
    }
    #[doc = "Load literal `true` into register `dst`."]
    pub const fn ltrue(dst: Reg) -> Instruction {
        Instruction::Ltrue {
            dst,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
    #[doc = "Load literal `false` into register `dst`."]
    pub const fn lfalse(dst: Reg) -> Instruction {
        Instruction::Lfalse {
            dst,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
    #[doc = "Load literal by `id` into register `dst`.\n\n`id` holds a 64-bit integer."]
    pub const fn lint(dst: Reg, id: Lit) -> Instruction {
        Instruction::Lint { dst, id }
    }
    #[doc = "Load literal by `id` into register `dst`.\n\n`id` holds a 64-bit float."]
    pub const fn lnum(dst: Reg, id: Lit) -> Instruction {
        Instruction::Lnum { dst, id }
    }
    #[doc = "Load literal by `id` into register `dst`.\n\n`id` holds a string literal."]
    pub const fn lstr(dst: Reg, id: Lit) -> Instruction {
        Instruction::Lstr { dst, id }
    }
    #[doc = "Load closure function by `id` into register `dst`.\n\n`id` holds a ClosureInfo."]
    pub const fn lclosure(dst: Reg, id: Lit) -> Instruction {
        Instruction::Lclosure { dst, id }
    }
    #[doc = "Load function by `id` into register `dst`.\n\n`id` holds a FuncInfo.\n\nThis implies no captures, but the resulting object\nis still a `Closure`."]
    pub const fn lfunc(dst: Reg, id: Lit) -> Instruction {
        Instruction::Lfunc { dst, id }
    }
    #[doc = "Allocate a list with `capacity` into register `dst`."]
    pub const fn llist(dst: Reg, cap: Imm16) -> Instruction {
        Instruction::Llist { dst, cap }
    }
    #[doc = "Allocate an object with `capacity` into register `dst`."]
    pub const fn ltable(dst: Reg, cap: Imm16) -> Instruction {
        Instruction::Ltable { dst, cap }
    }
    #[doc = "Adjust instruction pointer by `rel`."]
    pub const fn jmp(rel: Imm24s) -> Instruction {
        Instruction::Jmp { rel }
    }
    #[doc = "Skip `jmp` if `v` coerced to bool is `true`"]
    pub const fn istrue(v: Reg) -> Instruction {
        Instruction::Istrue {
            v,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
    #[doc = "Skip `jmp` if `v` coerced to bool is `false`"]
    pub const fn isfalse(v: Reg) -> Instruction {
        Instruction::Isfalse {
            v,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
    #[doc = "If `v` coerced to bool is `true`:\n- Set `dst` to original `v`\n- Skip `jmp`"]
    pub const fn istruec(dst: Reg, v: Reg) -> Instruction {
        Instruction::Istruec { dst, v, _c: 0x7F }
    }
    #[doc = "If `v` coerced to bool is `false`:\n- Set `dst` to original `v`\n- Skip `jmp`"]
    pub const fn isfalsec(dst: Reg, v: Reg) -> Instruction {
        Instruction::Isfalsec { dst, v, _c: 0x7F }
    }
    #[doc = "Skip `jmp` if `lhs < rhs` (register, register)"]
    pub const fn islt(lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Islt { lhs, rhs, _c: 0x7F }
    }
    #[doc = "Skip `jmp` if `lhs <= rhs` (register, register)"]
    pub const fn isle(lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Isle { lhs, rhs, _c: 0x7F }
    }
    #[doc = "Skip `jmp` if `lhs > rhs` (register, register)"]
    pub const fn isgt(lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Isgt { lhs, rhs, _c: 0x7F }
    }
    #[doc = "Skip `jmp` if `lhs >= rhs` (register, register)"]
    pub const fn isge(lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Isge { lhs, rhs, _c: 0x7F }
    }
    #[doc = "Skip `jmp` if `lhs == rhs` (register, register)"]
    pub const fn iseq(lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Iseq { lhs, rhs, _c: 0x7F }
    }
    #[doc = "Skip `jmp` if `lhs != rhs` (register, register)"]
    pub const fn isne(lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Isne { lhs, rhs, _c: 0x7F }
    }
    #[doc = "Skip `jmp` if `lhs == rhs` (register, literal string)"]
    pub const fn iseqs(lhs: Reg, rhs: Lit) -> Instruction {
        Instruction::Iseqs { lhs, rhs }
    }
    #[doc = "Skip `jmp` if `lhs != rhs` (register, literal string)"]
    pub const fn isnes(lhs: Reg, rhs: Lit) -> Instruction {
        Instruction::Isnes { lhs, rhs }
    }
    #[doc = "Skip `jmp` if `lhs == rhs` (register, literal number)"]
    pub const fn iseqn(lhs: Reg, rhs: Lit) -> Instruction {
        Instruction::Iseqn { lhs, rhs }
    }
    #[doc = "Skip `jmp` if `lhs != rhs` (register, literal number)"]
    pub const fn isnen(lhs: Reg, rhs: Lit) -> Instruction {
        Instruction::Isnen { lhs, rhs }
    }
    #[doc = "Skip `jmp` if `lhs == rhs` (register, primitive)"]
    pub const fn iseqp(lhs: Reg, rhs: Imm8) -> Instruction {
        Instruction::Iseqp { lhs, rhs, _c: 0x7F }
    }
    #[doc = "Skip `jmp` if `lhs != rhs` (register, primitive)"]
    pub const fn isnep(lhs: Reg, rhs: Imm8) -> Instruction {
        Instruction::Isnep { lhs, rhs, _c: 0x7F }
    }
    #[doc = "`dst = lhs < rhs` (register, register)"]
    pub const fn isltv(dst: Reg, lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Isltv { dst, lhs, rhs }
    }
    #[doc = "`dst = lhs <= rhs` (register, register)"]
    pub const fn islev(dst: Reg, lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Islev { dst, lhs, rhs }
    }
    #[doc = "`dst = lhs > rhs` (register, register)"]
    pub const fn isgtv(dst: Reg, lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Isgtv { dst, lhs, rhs }
    }
    #[doc = "`dst = lhs >= rhs` (register, register)"]
    pub const fn isgev(dst: Reg, lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Isgev { dst, lhs, rhs }
    }
    #[doc = "`dst = lhs == rhs` (register, register)"]
    pub const fn iseqv(dst: Reg, lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Iseqv { dst, lhs, rhs }
    }
    #[doc = "`dst = lhs != rhs` (register, register)"]
    pub const fn isnev(dst: Reg, lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Isnev { dst, lhs, rhs }
    }
    #[doc = "`dst = lhs + rhs` (register, register)"]
    pub const fn addvv(dst: Reg, lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Addvv { dst, lhs, rhs }
    }
    #[doc = "`dst = lhs + rhs` (register, literal)"]
    pub const fn addvn(dst: Reg, lhs: Reg, rhs: Lit8) -> Instruction {
        Instruction::Addvn { dst, lhs, rhs }
    }
    #[doc = "`dst = lhs + rhs` (literal, register)"]
    pub const fn addnv(dst: Reg, lhs: Lit8, rhs: Reg) -> Instruction {
        Instruction::Addnv { dst, lhs, rhs }
    }
    #[doc = "`dst = lhs - rhs` (register, register)"]
    pub const fn subvv(dst: Reg, lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Subvv { dst, lhs, rhs }
    }
    #[doc = "`dst = lhs - rhs` (register, literal)"]
    pub const fn subvn(dst: Reg, lhs: Reg, rhs: Lit8) -> Instruction {
        Instruction::Subvn { dst, lhs, rhs }
    }
    #[doc = "`dst = lhs - rhs` (literal, register)"]
    pub const fn subnv(dst: Reg, lhs: Lit8, rhs: Reg) -> Instruction {
        Instruction::Subnv { dst, lhs, rhs }
    }
    #[doc = "`dst = lhs * rhs` (register, register)"]
    pub const fn mulvv(dst: Reg, lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Mulvv { dst, lhs, rhs }
    }
    #[doc = "`dst = lhs * rhs` (register, literal)"]
    pub const fn mulvn(dst: Reg, lhs: Reg, rhs: Lit8) -> Instruction {
        Instruction::Mulvn { dst, lhs, rhs }
    }
    #[doc = "`dst = lhs * rhs` (literal, register)"]
    pub const fn mulnv(dst: Reg, lhs: Lit8, rhs: Reg) -> Instruction {
        Instruction::Mulnv { dst, lhs, rhs }
    }
    #[doc = "`dst = lhs / rhs` (register, register)"]
    pub const fn divvv(dst: Reg, lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Divvv { dst, lhs, rhs }
    }
    #[doc = "`dst = lhs / rhs` (register, literal)"]
    pub const fn divvn(dst: Reg, lhs: Reg, rhs: Lit8) -> Instruction {
        Instruction::Divvn { dst, lhs, rhs }
    }
    #[doc = "`dst = lhs / rhs` (literal, register)"]
    pub const fn divnv(dst: Reg, lhs: Lit8, rhs: Reg) -> Instruction {
        Instruction::Divnv { dst, lhs, rhs }
    }
    #[doc = "`dst = -rhs`"]
    pub const fn unm(dst: Reg, rhs: Reg) -> Instruction {
        Instruction::Unm { dst, rhs, _c: 0x7F }
    }
    #[doc = "`dst = not rhs`"]
    pub const fn not(dst: Reg, rhs: Reg) -> Instruction {
        Instruction::Not { dst, rhs, _c: 0x7F }
    }
    #[doc = "`dst = dst(dst+1..dst+1+args)`"]
    pub const fn call(dst: Reg, args: Imm8) -> Instruction {
        Instruction::Call {
            dst,
            args,
            _c: 0x7F,
        }
    }
    #[doc = "`dst = funcs[id](dst..dst+funcs[id].args)`"]
    pub const fn fastcall(dst: Reg, id: FnId) -> Instruction {
        Instruction::Fastcall { dst, id }
    }
    #[doc = "Return from the current call."]
    pub const fn ret() -> Instruction {
        Instruction::Ret {
            _a: 0x7F,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
    #[doc = "Stop execution, and yield to the VM's caller.\nNever generated by the compiler."]
    pub const fn stop() -> Instruction {
        Instruction::Stop {
            _a: 0x7F,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
}
#[repr(C)]
pub struct JumpTable {
    pub nop: OpaqueOp,
    pub mov: OpaqueOp,
    pub lmvar: OpaqueOp,
    pub smvar: OpaqueOp,
    pub lcap: OpaqueOp,
    pub scap: OpaqueOp,
    pub lidx: OpaqueOp,
    pub lidxn: OpaqueOp,
    pub sidx: OpaqueOp,
    pub sidxn: OpaqueOp,
    pub lkey: OpaqueOp,
    pub lkeyc: OpaqueOp,
    pub skey: OpaqueOp,
    pub skeyc: OpaqueOp,
    pub lnil: OpaqueOp,
    pub lsmi: OpaqueOp,
    pub ltrue: OpaqueOp,
    pub lfalse: OpaqueOp,
    pub lint: OpaqueOp,
    pub lnum: OpaqueOp,
    pub lstr: OpaqueOp,
    pub lclosure: OpaqueOp,
    pub lfunc: OpaqueOp,
    pub llist: OpaqueOp,
    pub ltable: OpaqueOp,
    pub jmp: OpaqueOp,
    pub istrue: OpaqueOp,
    pub isfalse: OpaqueOp,
    pub istruec: OpaqueOp,
    pub isfalsec: OpaqueOp,
    pub islt: OpaqueOp,
    pub isle: OpaqueOp,
    pub isgt: OpaqueOp,
    pub isge: OpaqueOp,
    pub iseq: OpaqueOp,
    pub isne: OpaqueOp,
    pub iseqs: OpaqueOp,
    pub isnes: OpaqueOp,
    pub iseqn: OpaqueOp,
    pub isnen: OpaqueOp,
    pub iseqp: OpaqueOp,
    pub isnep: OpaqueOp,
    pub isltv: OpaqueOp,
    pub islev: OpaqueOp,
    pub isgtv: OpaqueOp,
    pub isgev: OpaqueOp,
    pub iseqv: OpaqueOp,
    pub isnev: OpaqueOp,
    pub addvv: OpaqueOp,
    pub addvn: OpaqueOp,
    pub addnv: OpaqueOp,
    pub subvv: OpaqueOp,
    pub subvn: OpaqueOp,
    pub subnv: OpaqueOp,
    pub mulvv: OpaqueOp,
    pub mulvn: OpaqueOp,
    pub mulnv: OpaqueOp,
    pub divvv: OpaqueOp,
    pub divvn: OpaqueOp,
    pub divnv: OpaqueOp,
    pub unm: OpaqueOp,
    pub not: OpaqueOp,
    pub call: OpaqueOp,
    pub fastcall: OpaqueOp,
    pub ret: OpaqueOp,
    pub stop: OpaqueOp,
}

impl JumpTable {
    #[inline]
    pub fn as_ptr(&self) -> Jt {
        let ptr = &raw const self.nop;
        Jt(ptr.cast())
    }
}
