// Generated by asmgen at 2025-11-08T14:32:17.00726069+00:00[UTC]
//
// See `asmgen/src/main.rs` and `asmgen/src/runtime.rs`
#![allow(unsafe_op_in_unsafe_fn, dead_code, unused_variables)]

mod private {
    pub trait Sealed {}
}

use core::ptr::NonNull;

use super::{Control, ValueRaw, VmState};

pub trait OperandPack: private::Sealed + Sized {}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Sp(pub(crate) NonNull<ValueRaw>);

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Ip(pub(crate) NonNull<Insn>);

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Insn(u32);

impl Insn {
    #[inline(always)]
    pub fn tag(self) -> isize {
        (self.0 & 0xFF) as isize
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Jt(pub(crate) NonNull<OpaqueHandler>);

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Lp(pub(crate) NonNull<ValueRaw>);

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Vm(pub(crate) NonNull<VmState>);

const _: () = {
    use std::mem::align_of;
    assert!(align_of::<JumpTable>() == align_of::<[OpaqueHandler; 1]>());
};

#[allow(non_camel_case_types)]
#[derive(Clone, Copy, Hash)]
#[repr(transparent)]
pub struct u24(u32);

impl u24 {
    pub const MAX: u24 = u24(0xFFFFFF);
    pub const MIN: u24 = u24(0);
    pub const ZERO: u24 = u24(0);

    #[inline]
    pub const fn new(v: u32) -> Self {
        if v > Self::MAX.get() {
            panic!("value is out of bounds for u24");
        }

        unsafe { Self::new_unchecked(v) }
    }

    #[inline]
    pub const unsafe fn new_unchecked(v: u32) -> Self {
        debug_assert!(v <= Self::MAX.get());
        Self(v)
    }

    #[inline]
    pub const fn get(self) -> u32 {
        self.0
    }

    #[inline]
    pub const fn as_i24(self) -> i24 {
        i24(self)
    }
}

impl PartialEq for u24 {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        PartialEq::eq(&self.get(), &other.get())
    }
}

impl Eq for u24 {}

impl PartialOrd for u24 {
    #[inline]
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        PartialOrd::partial_cmp(&self.get(), &other.get())
    }
}

impl Ord for u24 {
    #[inline]
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        Ord::cmp(&self.get(), &other.get())
    }
}

impl std::fmt::Debug for u24 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        <u32 as std::fmt::Debug>::fmt(&self.get(), f)
    }
}

impl std::fmt::Display for u24 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        <u32 as std::fmt::Display>::fmt(&self.get(), f)
    }
}

impl TryFrom<usize> for u24 {
    type Error = ();

    #[inline]
    fn try_from(value: usize) -> Result<Self, Self::Error> {
        if value > u24::MAX.zx() as usize {
            return Err(());
        }

        Ok(unsafe { u24::new_unchecked(value as u32) })
    }
}

#[allow(non_camel_case_types)]
#[derive(Clone, Copy, Hash)]
#[repr(transparent)]
pub struct i24(u24);

impl i24 {
    pub const MAX: i24 = i24(unsafe { u24::new_unchecked(16_777_215) });
    pub const MIN: i24 = i24(u24::ZERO);
    pub const ZERO: i24 = i24(unsafe { u24::new_unchecked(8_388_608) });

    const OFFSET: u32 = 8_388_608; // 2^23, which is i24::MAX + 1

    #[inline]
    pub const fn new(v: i32) -> Self {
        if v > Self::MAX.get() || v < Self::MIN.get() {
            panic!("value is out of bounds for i24");
        }

        unsafe { Self::new_unchecked(v) }
    }

    #[inline]
    pub const unsafe fn new_unchecked(v: i32) -> Self {
        Self(u24::new_unchecked((v as u32).wrapping_add(Self::OFFSET)))
    }

    #[inline]
    pub const fn get(self) -> i32 {
        self.0.get().wrapping_sub(Self::OFFSET) as i32
    }

    #[inline]
    pub const fn as_u24(self) -> u24 {
        self.0
    }
}

impl PartialEq for i24 {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.0.eq(&other.0)
    }
}

impl Eq for i24 {}

impl PartialOrd for i24 {
    #[inline]
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        self.0.partial_cmp(&other.0)
    }
}

impl Ord for i24 {
    #[inline]
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.0.cmp(&other.0)
    }
}

impl std::fmt::Debug for i24 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        <i32 as std::fmt::Debug>::fmt(&self.get(), f)
    }
}

impl std::fmt::Display for i24 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        <i32 as std::fmt::Display>::fmt(&self.get(), f)
    }
}

impl TryFrom<isize> for i24 {
    type Error = ();

    #[inline]
    fn try_from(value: isize) -> Result<Self, Self::Error> {
        if value > i24::MAX.get() as isize || value < i24::MIN.get() as isize {
            return Err(());
        }

        Ok(unsafe { i24::new_unchecked(value as i32) })
    }
}

impl From<u24> for i24 {
    #[inline(always)]
    fn from(value: u24) -> Self {
        value.as_i24()
    }
}

impl From<i24> for u24 {
    #[inline(always)]
    fn from(value: i24) -> Self {
        value.as_u24()
    }
}

#[cfg(not(windows))]
macro_rules! Handler {
    (
        fn ($($ty:ty),* $(,)?) -> $ret:ty
    ) => {
        unsafe extern "C" fn($($ty),*) -> $ret
    };
}

#[cfg(windows)]
macro_rules! Handler {
    (
        fn ($($ty:ty),* $(,)?) -> $ret:ty
    ) => {
        unsafe extern "sysv64" fn($($ty),*) -> $ret
    };
}

#[cfg(not(windows))]
macro_rules! handler {
    (
        unsafe extern "?" fn $name:ident($($i:ident : $ty:ty),* $(,)?) -> $ret:ty $body:block
    ) => {
        unsafe extern "C" fn $name($($i:$ty),*) -> $ret $body
    };
}

#[cfg(windows)]
macro_rules! handler {
    (
        unsafe extern "?" fn $name:ident($($i:ident : $ty:ty),* $(,)?) -> $ret:ty $body:block
    ) => {
        unsafe extern "sysv64" fn $name($($i:$ty),*) -> $ret $body
    };
}

macro_rules! jump_table {
    {
        $($op:ident),* $(,)?
    } => {
        JumpTable {
            $($op: {
                type __Operands = $crate::codegen::opcodes::__operands::$op;
                const __OP: unsafe fn(Vm, Jt, Ip, __Operands, Sp, Lp) -> Control = $op;

                {
                    handler! {
                        unsafe extern "?" fn $op(vm: Vm, jt: Jt, ip: Ip, args: Insn, sp: Sp, lp: Lp) -> Control {
                            let args: __Operands = core::mem::transmute(args);
                            __OP(vm, jt, ip, args, sp, lp)
                        }
                    }

                    $op
                }
            }),*
        }
    };
}

/*
NOTE: Order of handler parameters matters:
We want `Insn` in a register with high-8-bits-of-low-16-bits monikers.

  abc: c:8  b:8  a:8  op:8
  aB:       B:16 a:8  op:8
  A:             A:16 op:8

x86-64 SysV: 6 registers, and their monikers:

    64   32   16   8-hi  8-lo
  0 RDI  EDI  DI   N/A   DIL
  1 RSI  ESI  SI   N/A   SIL
  2 RDX  EDX  DX   DH    DL
  3 RCX  ECX  CX   CH    CL
  4 R8   R8D  R8W  N/A   R8B
  5 R9   R9D  R9W  N/A   R9B

So the only suitable ones are `RDX` and `RCX`, because:
- The full instruction is in `EDX`/`ECX`,
- `op` is `movzx <dst>,DL/CL`
- `a` is `movzx <dst>,DH/CH`
- `b` is `movzx <dst>,DX/CX` + `shrn <dst>,8`
- `c` is `movzx <dst>,EDX/ECX` + `shrn <dst>,24`
- `B` is `movzx <dst>,EDX/ECX` + `shrn <dst>,16`
- `A` is `movxz <dst>,EDX/ECX` + `shrn <dst>,8`

If we used any other registers, `a` couldn't be decoded with just a `mov`.

  TODO: do the same for AArch64
  though i'm pretty sure things are less fucked up over there
*/

pub type Handler<Operands> = Handler!(fn(Vm, Jt, Ip, Operands, Sp, Lp) -> Control);

pub type OpaqueHandler = Handler!(fn(Vm, Jt, Ip, Insn, Sp, Lp) -> Control);

macro_rules! declare_operand_type {
    ($name:ident, $ty:ident, $fmt:literal) => {
        #[derive(Debug, Clone, Copy)]
        #[repr(transparent)]
        #[must_use = "unused operand"]
        pub struct $name($ty);

        impl $name {
            #[inline(always)]
            pub fn get(self) -> $ty {
                self.0
            }

            #[inline(always)]
            pub const unsafe fn new_unchecked(v: $ty) -> Self {
                Self(v)
            }

            #[inline(always)]
            pub fn zx(self) -> usize {
                self.0.zx()
            }

            #[inline(always)]
            pub fn sz(self) -> isize {
                self.0.sz()
            }
        }

        impl std::fmt::Display for $name {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(f, $fmt, self.0)
            }
        }
    };
}

trait ExtendEx: Sized {
    fn zx(self) -> usize;
    fn sz(self) -> isize;
}

macro_rules! extend_primitive {
    ($ty:ty) => {
        impl ExtendEx for $ty {
            #[inline(always)]
            fn zx(self) -> usize {
                self as usize
            }

            #[inline(always)]
            fn sz(self) -> isize {
                self as isize
            }
        }
    };
}

extend_primitive!(u8);
extend_primitive!(u16);
extend_primitive!(i16);

impl ExtendEx for u24 {
    #[inline(always)]
    fn zx(self) -> usize {
        self.get() as usize
    }

    #[inline(always)]
    fn sz(self) -> isize {
        self.get() as isize
    }
}

impl ExtendEx for i24 {
    #[inline(always)]
    fn zx(self) -> usize {
        self.get() as usize
    }

    #[inline(always)]
    fn sz(self) -> isize {
        self.get() as isize
    }
}

macro_rules! declare_operand_types {
    (
        $(
            $name:ident($ty:ident) = $fmt:literal
        ),* $(,)?
    ) => {
        $(
            declare_operand_type!($name, $ty, $fmt);
        )*
    };
}

declare_operand_types! {
    Reg(u8) = "r{}",

    Mvar(u16) = "m{}",
    Cap(u8) = "c{}",

    Lit(u16) = "l{}",
    Lit8(u8) = "l{}",

    FnId(u16) = "fn{}",
    HostId(u16) = "h{}",

    Imm8(u8) = "{}",
    Imm16(u16) = "{}",
    Imm16s(i16) = "{}",
    Imm24(u24) = "{}",
    Imm24s(i24) = "{}",
}

#[allow(non_snake_case)]
#[inline(always)]
const fn op_abc(op: Opcode, a: u8, b: u8, c: u8) -> Insn {
    let mut v = 0u32;
    v |= op as u32;
    v |= (a as u32) << 8;
    v |= (b as u32) << 16;
    v |= (c as u32) << 24;
    Insn(v)
}

#[allow(non_snake_case)]
#[inline(always)]
const fn op_aB(op: Opcode, a: u8, B: u16) -> Insn {
    let mut v = 0u32;
    v |= op as u32;
    v |= (a as u32) << 8;
    v |= (B as u32) << 16;
    Insn(v)
}

#[allow(non_snake_case)]
#[inline(always)]
const fn op_aS(op: Opcode, a: u8, B: i16) -> Insn {
    let mut v = 0u32;
    v |= op as u32;
    v |= (a as u32) << 8;
    v |= (B as u32) << 16;
    Insn(v)
}

#[allow(non_snake_case)]
#[inline(always)]
const fn op_A(op: Opcode, A: u24) -> Insn {
    let mut v = 0u32;
    v |= op as u32;
    v |= (A.0) << 8;
    Insn(v)
}

#[allow(non_snake_case)]
#[inline(always)]
const fn op_S(op: Opcode, A: i24) -> Insn {
    let mut v = 0u32;
    v |= op as u32;
    v |= (A.0 .0) << 8;
    Insn(v)
}

impl Opcode {
    #[inline(always)]
    fn zx(self) -> usize {
        self as usize
    }
}

#[allow(non_snake_case)]
impl Insn {
    #[inline(always)]
    pub fn op(self) -> Opcode {
        unsafe { ::core::mem::transmute((self.0 & 0xFF) as u8) }
    }

    #[inline(always)]
    fn a(self) -> u8 {
        ((self.0 >> 8) & 0xFF) as u8
    }

    #[inline(always)]
    fn b(self) -> u8 {
        ((self.0 >> 16) & 0xFF) as u8
    }

    #[inline(always)]
    fn c(self) -> u8 {
        (self.0 >> 24) as u8
    }

    #[inline(always)]
    fn B(self) -> u16 {
        (self.0 >> 16) as u16
    }

    #[inline(always)]
    fn A(self) -> u24 {
        u24((self.0 >> 8) as u32)
    }
}

// ...

#[derive(Clone, Copy)]
#[repr(u8, align(4))]
pub enum DecodedInsn {
    Nop {} = 0,
    Mov { dst: Reg, src: Reg } = 1,
    Lmvar { dst: Reg, src: Mvar } = 2,
    Smvar { src: Reg, dst: Mvar } = 3,
    Lcap { dst: Reg, src: Cap } = 4,
    Scap { dst: Cap, src: Reg } = 5,
    Lidx { dst: Reg, target: Reg, idx: Reg } = 6,
    Lidxn { dst: Reg, target: Reg, idx: Lit8 } = 7,
    Sidx { target: Reg, idx: Reg, src: Reg } = 8,
    Sidxn { target: Reg, idx: Lit8, src: Reg } = 9,
    Lkey { dst: Reg, target: Reg, key: Reg } = 10,
    Lkeyc { dst: Reg, target: Reg, key: Lit8 } = 11,
    Skey { target: Reg, key: Reg, src: Reg } = 12,
    Skeyc { target: Reg, key: Lit8, src: Reg } = 13,
    Lnil { dst: Reg } = 14,
    Lsmi { dst: Reg, v: Imm16s } = 15,
    Ltrue { dst: Reg } = 16,
    Lfalse { dst: Reg } = 17,
    Lint { dst: Reg, id: Lit } = 18,
    Lnum { dst: Reg, id: Lit } = 19,
    Lstr { dst: Reg, id: Lit } = 20,
    Lclosure { dst: Reg, id: Lit } = 21,
    Lfunc { dst: Reg, id: FnId } = 22,
    Lhost { dst: Reg, id: HostId } = 23,
    Llist { dst: Reg, cap: Imm16 } = 24,
    Ltable { dst: Reg, cap: Imm16 } = 25,
    Jmp { rel: Imm24s } = 26,
    Islt { lhs: Reg, rhs: Reg } = 27,
    Isle { lhs: Reg, rhs: Reg } = 28,
    Isgt { lhs: Reg, rhs: Reg } = 29,
    Isge { lhs: Reg, rhs: Reg } = 30,
    Iseq { lhs: Reg, rhs: Reg } = 31,
    Isne { lhs: Reg, rhs: Reg } = 32,
    Isnil { v: Reg } = 33,
    Isnotnil { v: Reg } = 34,
    Istrue { v: Reg } = 35,
    Isfalse { v: Reg } = 36,
    Iseqs { lhs: Reg, rhs: Lit } = 37,
    Isnes { lhs: Reg, rhs: Lit } = 38,
    Iseqi { lhs: Reg, rhs: Lit } = 39,
    Isnei { lhs: Reg, rhs: Lit } = 40,
    Iseqf { lhs: Reg, rhs: Lit } = 41,
    Isnef { lhs: Reg, rhs: Lit } = 42,
    Isltv { dst: Reg, lhs: Reg, rhs: Reg } = 43,
    Islev { dst: Reg, lhs: Reg, rhs: Reg } = 44,
    Isgtv { dst: Reg, lhs: Reg, rhs: Reg } = 45,
    Isgev { dst: Reg, lhs: Reg, rhs: Reg } = 46,
    Iseqv { dst: Reg, lhs: Reg, rhs: Reg } = 47,
    Isnev { dst: Reg, lhs: Reg, rhs: Reg } = 48,
    Addvv { dst: Reg, lhs: Reg, rhs: Reg } = 49,
    Addvn { dst: Reg, lhs: Reg, rhs: Lit8 } = 50,
    Addnv { dst: Reg, lhs: Lit8, rhs: Reg } = 51,
    Subvv { dst: Reg, lhs: Reg, rhs: Reg } = 52,
    Subvn { dst: Reg, lhs: Reg, rhs: Lit8 } = 53,
    Subnv { dst: Reg, lhs: Lit8, rhs: Reg } = 54,
    Mulvv { dst: Reg, lhs: Reg, rhs: Reg } = 55,
    Mulvn { dst: Reg, lhs: Reg, rhs: Lit8 } = 56,
    Mulnv { dst: Reg, lhs: Lit8, rhs: Reg } = 57,
    Divvv { dst: Reg, lhs: Reg, rhs: Reg } = 58,
    Divvn { dst: Reg, lhs: Reg, rhs: Lit8 } = 59,
    Divnv { dst: Reg, lhs: Lit8, rhs: Reg } = 60,
    Unm { dst: Reg, rhs: Reg } = 61,
    Not { dst: Reg, rhs: Reg } = 62,
    Call { dst: Reg, callee: Reg, args: Imm8 } = 63,
    Fastcall { dst: Reg, id: FnId } = 64,
    Hostcall { dst: Reg, id: HostId } = 65,
    Import { _unused: Reg, id: Lit } = 66,
    Ret {} = 67,
    Retv { src: Reg } = 68,
    Stop {} = 69,
}

impl Insn {
    #[inline]
    pub fn into_enum(self) -> DecodedInsn {
        match self.op() {
            Opcode::Nop => DecodedInsn::Nop {},
            Opcode::Mov => DecodedInsn::Mov {
                dst: Mov(self).dst(),
                src: Mov(self).src(),
            },
            Opcode::Lmvar => DecodedInsn::Lmvar {
                dst: Lmvar(self).dst(),
                src: Lmvar(self).src(),
            },
            Opcode::Smvar => DecodedInsn::Smvar {
                src: Smvar(self).src(),
                dst: Smvar(self).dst(),
            },
            Opcode::Lcap => DecodedInsn::Lcap {
                dst: Lcap(self).dst(),
                src: Lcap(self).src(),
            },
            Opcode::Scap => DecodedInsn::Scap {
                dst: Scap(self).dst(),
                src: Scap(self).src(),
            },
            Opcode::Lidx => DecodedInsn::Lidx {
                dst: Lidx(self).dst(),
                target: Lidx(self).target(),
                idx: Lidx(self).idx(),
            },
            Opcode::Lidxn => DecodedInsn::Lidxn {
                dst: Lidxn(self).dst(),
                target: Lidxn(self).target(),
                idx: Lidxn(self).idx(),
            },
            Opcode::Sidx => DecodedInsn::Sidx {
                target: Sidx(self).target(),
                idx: Sidx(self).idx(),
                src: Sidx(self).src(),
            },
            Opcode::Sidxn => DecodedInsn::Sidxn {
                target: Sidxn(self).target(),
                idx: Sidxn(self).idx(),
                src: Sidxn(self).src(),
            },
            Opcode::Lkey => DecodedInsn::Lkey {
                dst: Lkey(self).dst(),
                target: Lkey(self).target(),
                key: Lkey(self).key(),
            },
            Opcode::Lkeyc => DecodedInsn::Lkeyc {
                dst: Lkeyc(self).dst(),
                target: Lkeyc(self).target(),
                key: Lkeyc(self).key(),
            },
            Opcode::Skey => DecodedInsn::Skey {
                target: Skey(self).target(),
                key: Skey(self).key(),
                src: Skey(self).src(),
            },
            Opcode::Skeyc => DecodedInsn::Skeyc {
                target: Skeyc(self).target(),
                key: Skeyc(self).key(),
                src: Skeyc(self).src(),
            },
            Opcode::Lnil => DecodedInsn::Lnil {
                dst: Lnil(self).dst(),
            },
            Opcode::Lsmi => DecodedInsn::Lsmi {
                dst: Lsmi(self).dst(),
                v: Lsmi(self).v(),
            },
            Opcode::Ltrue => DecodedInsn::Ltrue {
                dst: Ltrue(self).dst(),
            },
            Opcode::Lfalse => DecodedInsn::Lfalse {
                dst: Lfalse(self).dst(),
            },
            Opcode::Lint => DecodedInsn::Lint {
                dst: Lint(self).dst(),
                id: Lint(self).id(),
            },
            Opcode::Lnum => DecodedInsn::Lnum {
                dst: Lnum(self).dst(),
                id: Lnum(self).id(),
            },
            Opcode::Lstr => DecodedInsn::Lstr {
                dst: Lstr(self).dst(),
                id: Lstr(self).id(),
            },
            Opcode::Lclosure => DecodedInsn::Lclosure {
                dst: Lclosure(self).dst(),
                id: Lclosure(self).id(),
            },
            Opcode::Lfunc => DecodedInsn::Lfunc {
                dst: Lfunc(self).dst(),
                id: Lfunc(self).id(),
            },
            Opcode::Lhost => DecodedInsn::Lhost {
                dst: Lhost(self).dst(),
                id: Lhost(self).id(),
            },
            Opcode::Llist => DecodedInsn::Llist {
                dst: Llist(self).dst(),
                cap: Llist(self).cap(),
            },
            Opcode::Ltable => DecodedInsn::Ltable {
                dst: Ltable(self).dst(),
                cap: Ltable(self).cap(),
            },
            Opcode::Jmp => DecodedInsn::Jmp {
                rel: Jmp(self).rel(),
            },
            Opcode::Islt => DecodedInsn::Islt {
                lhs: Islt(self).lhs(),
                rhs: Islt(self).rhs(),
            },
            Opcode::Isle => DecodedInsn::Isle {
                lhs: Isle(self).lhs(),
                rhs: Isle(self).rhs(),
            },
            Opcode::Isgt => DecodedInsn::Isgt {
                lhs: Isgt(self).lhs(),
                rhs: Isgt(self).rhs(),
            },
            Opcode::Isge => DecodedInsn::Isge {
                lhs: Isge(self).lhs(),
                rhs: Isge(self).rhs(),
            },
            Opcode::Iseq => DecodedInsn::Iseq {
                lhs: Iseq(self).lhs(),
                rhs: Iseq(self).rhs(),
            },
            Opcode::Isne => DecodedInsn::Isne {
                lhs: Isne(self).lhs(),
                rhs: Isne(self).rhs(),
            },
            Opcode::Isnil => DecodedInsn::Isnil { v: Isnil(self).v() },
            Opcode::Isnotnil => DecodedInsn::Isnotnil {
                v: Isnotnil(self).v(),
            },
            Opcode::Istrue => DecodedInsn::Istrue {
                v: Istrue(self).v(),
            },
            Opcode::Isfalse => DecodedInsn::Isfalse {
                v: Isfalse(self).v(),
            },
            Opcode::Iseqs => DecodedInsn::Iseqs {
                lhs: Iseqs(self).lhs(),
                rhs: Iseqs(self).rhs(),
            },
            Opcode::Isnes => DecodedInsn::Isnes {
                lhs: Isnes(self).lhs(),
                rhs: Isnes(self).rhs(),
            },
            Opcode::Iseqi => DecodedInsn::Iseqi {
                lhs: Iseqi(self).lhs(),
                rhs: Iseqi(self).rhs(),
            },
            Opcode::Isnei => DecodedInsn::Isnei {
                lhs: Isnei(self).lhs(),
                rhs: Isnei(self).rhs(),
            },
            Opcode::Iseqf => DecodedInsn::Iseqf {
                lhs: Iseqf(self).lhs(),
                rhs: Iseqf(self).rhs(),
            },
            Opcode::Isnef => DecodedInsn::Isnef {
                lhs: Isnef(self).lhs(),
                rhs: Isnef(self).rhs(),
            },
            Opcode::Isltv => DecodedInsn::Isltv {
                dst: Isltv(self).dst(),
                lhs: Isltv(self).lhs(),
                rhs: Isltv(self).rhs(),
            },
            Opcode::Islev => DecodedInsn::Islev {
                dst: Islev(self).dst(),
                lhs: Islev(self).lhs(),
                rhs: Islev(self).rhs(),
            },
            Opcode::Isgtv => DecodedInsn::Isgtv {
                dst: Isgtv(self).dst(),
                lhs: Isgtv(self).lhs(),
                rhs: Isgtv(self).rhs(),
            },
            Opcode::Isgev => DecodedInsn::Isgev {
                dst: Isgev(self).dst(),
                lhs: Isgev(self).lhs(),
                rhs: Isgev(self).rhs(),
            },
            Opcode::Iseqv => DecodedInsn::Iseqv {
                dst: Iseqv(self).dst(),
                lhs: Iseqv(self).lhs(),
                rhs: Iseqv(self).rhs(),
            },
            Opcode::Isnev => DecodedInsn::Isnev {
                dst: Isnev(self).dst(),
                lhs: Isnev(self).lhs(),
                rhs: Isnev(self).rhs(),
            },
            Opcode::Addvv => DecodedInsn::Addvv {
                dst: Addvv(self).dst(),
                lhs: Addvv(self).lhs(),
                rhs: Addvv(self).rhs(),
            },
            Opcode::Addvn => DecodedInsn::Addvn {
                dst: Addvn(self).dst(),
                lhs: Addvn(self).lhs(),
                rhs: Addvn(self).rhs(),
            },
            Opcode::Addnv => DecodedInsn::Addnv {
                dst: Addnv(self).dst(),
                lhs: Addnv(self).lhs(),
                rhs: Addnv(self).rhs(),
            },
            Opcode::Subvv => DecodedInsn::Subvv {
                dst: Subvv(self).dst(),
                lhs: Subvv(self).lhs(),
                rhs: Subvv(self).rhs(),
            },
            Opcode::Subvn => DecodedInsn::Subvn {
                dst: Subvn(self).dst(),
                lhs: Subvn(self).lhs(),
                rhs: Subvn(self).rhs(),
            },
            Opcode::Subnv => DecodedInsn::Subnv {
                dst: Subnv(self).dst(),
                lhs: Subnv(self).lhs(),
                rhs: Subnv(self).rhs(),
            },
            Opcode::Mulvv => DecodedInsn::Mulvv {
                dst: Mulvv(self).dst(),
                lhs: Mulvv(self).lhs(),
                rhs: Mulvv(self).rhs(),
            },
            Opcode::Mulvn => DecodedInsn::Mulvn {
                dst: Mulvn(self).dst(),
                lhs: Mulvn(self).lhs(),
                rhs: Mulvn(self).rhs(),
            },
            Opcode::Mulnv => DecodedInsn::Mulnv {
                dst: Mulnv(self).dst(),
                lhs: Mulnv(self).lhs(),
                rhs: Mulnv(self).rhs(),
            },
            Opcode::Divvv => DecodedInsn::Divvv {
                dst: Divvv(self).dst(),
                lhs: Divvv(self).lhs(),
                rhs: Divvv(self).rhs(),
            },
            Opcode::Divvn => DecodedInsn::Divvn {
                dst: Divvn(self).dst(),
                lhs: Divvn(self).lhs(),
                rhs: Divvn(self).rhs(),
            },
            Opcode::Divnv => DecodedInsn::Divnv {
                dst: Divnv(self).dst(),
                lhs: Divnv(self).lhs(),
                rhs: Divnv(self).rhs(),
            },
            Opcode::Unm => DecodedInsn::Unm {
                dst: Unm(self).dst(),
                rhs: Unm(self).rhs(),
            },
            Opcode::Not => DecodedInsn::Not {
                dst: Not(self).dst(),
                rhs: Not(self).rhs(),
            },
            Opcode::Call => DecodedInsn::Call {
                dst: Call(self).dst(),
                callee: Call(self).callee(),
                args: Call(self).args(),
            },
            Opcode::Fastcall => DecodedInsn::Fastcall {
                dst: Fastcall(self).dst(),
                id: Fastcall(self).id(),
            },
            Opcode::Hostcall => DecodedInsn::Hostcall {
                dst: Hostcall(self).dst(),
                id: Hostcall(self).id(),
            },
            Opcode::Import => DecodedInsn::Import {
                _unused: Import(self)._unused(),
                id: Import(self).id(),
            },
            Opcode::Ret => DecodedInsn::Ret {},
            Opcode::Retv => DecodedInsn::Retv {
                src: Retv(self).src(),
            },
            Opcode::Stop => DecodedInsn::Stop {},
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u8)]
pub enum Opcode {
    Nop = 0,
    Mov = 1,
    Lmvar = 2,
    Smvar = 3,
    Lcap = 4,
    Scap = 5,
    Lidx = 6,
    Lidxn = 7,
    Sidx = 8,
    Sidxn = 9,
    Lkey = 10,
    Lkeyc = 11,
    Skey = 12,
    Skeyc = 13,
    Lnil = 14,
    Lsmi = 15,
    Ltrue = 16,
    Lfalse = 17,
    Lint = 18,
    Lnum = 19,
    Lstr = 20,
    Lclosure = 21,
    Lfunc = 22,
    Lhost = 23,
    Llist = 24,
    Ltable = 25,
    Jmp = 26,
    Islt = 27,
    Isle = 28,
    Isgt = 29,
    Isge = 30,
    Iseq = 31,
    Isne = 32,
    Isnil = 33,
    Isnotnil = 34,
    Istrue = 35,
    Isfalse = 36,
    Iseqs = 37,
    Isnes = 38,
    Iseqi = 39,
    Isnei = 40,
    Iseqf = 41,
    Isnef = 42,
    Isltv = 43,
    Islev = 44,
    Isgtv = 45,
    Isgev = 46,
    Iseqv = 47,
    Isnev = 48,
    Addvv = 49,
    Addvn = 50,
    Addnv = 51,
    Subvv = 52,
    Subvn = 53,
    Subnv = 54,
    Mulvv = 55,
    Mulvn = 56,
    Mulnv = 57,
    Divvv = 58,
    Divvn = 59,
    Divnv = 60,
    Unm = 61,
    Not = 62,
    Call = 63,
    Fastcall = 64,
    Hostcall = 65,
    Import = 66,
    Ret = 67,
    Retv = 68,
    Stop = 69,
}
#[doc = "Do nothing."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Nop(Insn);

impl Nop {}

#[doc = "Move value from register `src` to register `dst`."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Mov(Insn);

impl Mov {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn src(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }
}

#[doc = "Load module variable `src` to register `dst`."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Lmvar(Insn);

impl Lmvar {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn src(self) -> Mvar {
        Mvar(unsafe { ::core::mem::transmute(self.0.B()) })
    }
}

#[doc = "Store register `dst` into module variable `mvar`."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Smvar(Insn);

impl Smvar {
    #[allow(unnecessary_transmutes)]
    pub fn src(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Mvar {
        Mvar(unsafe { ::core::mem::transmute(self.0.B()) })
    }
}

#[doc = "Load current closure's capture `src` to register `dst`."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Lcap(Insn);

impl Lcap {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn src(self) -> Cap {
        Cap(unsafe { ::core::mem::transmute(self.0.b()) })
    }
}

#[doc = "Store register `src` to current closure's capture `dst`."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Scap(Insn);

impl Scap {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Cap {
        Cap(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn src(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }
}

#[doc = "Load index `idx` (register) from `target` (array or table) to register `dst`."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Lidx(Insn);

impl Lidx {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn target(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn idx(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "Load index `idx` (literal) from `target` (array) to register `dst`."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Lidxn(Insn);

impl Lidxn {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn target(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn idx(self) -> Lit8 {
        Lit8(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "Store value from `src` into `idx` (register) in `target` (array or table)."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Sidx(Insn);

impl Sidx {
    #[allow(unnecessary_transmutes)]
    pub fn target(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn idx(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn src(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "Store value from `src` into `idx` (register) in `target` (array)."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Sidxn(Insn);

impl Sidxn {
    #[allow(unnecessary_transmutes)]
    pub fn target(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn idx(self) -> Lit8 {
        Lit8(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn src(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "Load `key` (register) from `target` (object) to register `dst` (object)."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Lkey(Insn);

impl Lkey {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn target(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn key(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "Load `key` (literal) from `target` (object) to register `dst` (object)."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Lkeyc(Insn);

impl Lkeyc {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn target(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn key(self) -> Lit8 {
        Lit8(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "Store value from `src` into `key` (register) in `target` (object)."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Skey(Insn);

impl Skey {
    #[allow(unnecessary_transmutes)]
    pub fn target(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn key(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn src(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "Store value from `src` into `key` (literal) in `target` (object)."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Skeyc(Insn);

impl Skeyc {
    #[allow(unnecessary_transmutes)]
    pub fn target(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn key(self) -> Lit8 {
        Lit8(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn src(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "Load `nil` value into register `dst`."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Lnil(Insn);

impl Lnil {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }
}

#[doc = "Load 16-bit integer `v` into register `dst`."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Lsmi(Insn);

impl Lsmi {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn v(self) -> Imm16s {
        Imm16s(unsafe { ::core::mem::transmute(self.0.B()) })
    }
}

#[doc = "Load literal `true` into register `dst`."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Ltrue(Insn);

impl Ltrue {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }
}

#[doc = "Load literal `false` into register `dst`."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Lfalse(Insn);

impl Lfalse {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }
}

#[doc = "Load literal by `id` into register `dst`.

`id` holds a 64-bit integer."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Lint(Insn);

impl Lint {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn id(self) -> Lit {
        Lit(unsafe { ::core::mem::transmute(self.0.B()) })
    }
}

#[doc = "Load literal by `id` into register `dst`.

`id` holds a 64-bit float."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Lnum(Insn);

impl Lnum {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn id(self) -> Lit {
        Lit(unsafe { ::core::mem::transmute(self.0.B()) })
    }
}

#[doc = "Load literal by `id` into register `dst`.

`id` holds a string literal."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Lstr(Insn);

impl Lstr {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn id(self) -> Lit {
        Lit(unsafe { ::core::mem::transmute(self.0.B()) })
    }
}

#[doc = "Load closure function by `id` into register `dst`.

`id` holds a `ClosureProto`."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Lclosure(Insn);

impl Lclosure {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn id(self) -> Lit {
        Lit(unsafe { ::core::mem::transmute(self.0.B()) })
    }
}

#[doc = "Load function by `id` into register `dst`."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Lfunc(Insn);

impl Lfunc {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn id(self) -> FnId {
        FnId(unsafe { ::core::mem::transmute(self.0.B()) })
    }
}

#[doc = "Load host function by `id` into register `dst`."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Lhost(Insn);

impl Lhost {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn id(self) -> HostId {
        HostId(unsafe { ::core::mem::transmute(self.0.B()) })
    }
}

#[doc = "Allocate a list with `capacity` into register `dst`."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Llist(Insn);

impl Llist {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn cap(self) -> Imm16 {
        Imm16(unsafe { ::core::mem::transmute(self.0.B()) })
    }
}

#[doc = "Allocate an object with `capacity` into register `dst`."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Ltable(Insn);

impl Ltable {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn cap(self) -> Imm16 {
        Imm16(unsafe { ::core::mem::transmute(self.0.B()) })
    }
}

#[doc = "Adjust instruction pointer by `rel`."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Jmp(Insn);

impl Jmp {
    #[allow(unnecessary_transmutes)]
    pub fn rel(self) -> Imm24s {
        Imm24s(unsafe { ::core::mem::transmute(self.0.A()) })
    }
}

#[doc = "Skip `jmp` if `lhs < rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Islt(Insn);

impl Islt {
    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }
}

#[doc = "Skip `jmp` if `lhs <= rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Isle(Insn);

impl Isle {
    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }
}

#[doc = "Skip `jmp` if `lhs > rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Isgt(Insn);

impl Isgt {
    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }
}

#[doc = "Skip `jmp` if `lhs >= rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Isge(Insn);

impl Isge {
    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }
}

#[doc = "Skip `jmp` if `lhs == rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Iseq(Insn);

impl Iseq {
    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }
}

#[doc = "Skip `jmp` if `lhs != rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Isne(Insn);

impl Isne {
    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }
}

#[doc = "Skip `jmp` if `lhs == nil` (register, primitive)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Isnil(Insn);

impl Isnil {
    #[allow(unnecessary_transmutes)]
    pub fn v(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }
}

#[doc = "Skip `jmp` if `lhs != nil` (register, primitive)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Isnotnil(Insn);

impl Isnotnil {
    #[allow(unnecessary_transmutes)]
    pub fn v(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }
}

#[doc = "Skip `jmp` if `v` coerced to bool is `true`"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Istrue(Insn);

impl Istrue {
    #[allow(unnecessary_transmutes)]
    pub fn v(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }
}

#[doc = "Skip `jmp` if `v` coerced to bool is `false`"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Isfalse(Insn);

impl Isfalse {
    #[allow(unnecessary_transmutes)]
    pub fn v(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }
}

#[doc = "Skip `jmp` if `lhs == rhs` (register, literal string)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Iseqs(Insn);

impl Iseqs {
    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Lit {
        Lit(unsafe { ::core::mem::transmute(self.0.B()) })
    }
}

#[doc = "Skip `jmp` if `lhs != rhs` (register, literal string)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Isnes(Insn);

impl Isnes {
    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Lit {
        Lit(unsafe { ::core::mem::transmute(self.0.B()) })
    }
}

#[doc = "Skip `jmp` if `lhs == rhs` (register, literal int)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Iseqi(Insn);

impl Iseqi {
    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Lit {
        Lit(unsafe { ::core::mem::transmute(self.0.B()) })
    }
}

#[doc = "Skip `jmp` if `lhs != rhs` (register, literal int)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Isnei(Insn);

impl Isnei {
    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Lit {
        Lit(unsafe { ::core::mem::transmute(self.0.B()) })
    }
}

#[doc = "Skip `jmp` if `lhs == rhs` (register, literal float)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Iseqf(Insn);

impl Iseqf {
    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Lit {
        Lit(unsafe { ::core::mem::transmute(self.0.B()) })
    }
}

#[doc = "Skip `jmp` if `lhs != rhs` (register, literal float)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Isnef(Insn);

impl Isnef {
    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Lit {
        Lit(unsafe { ::core::mem::transmute(self.0.B()) })
    }
}

#[doc = "`dst = lhs < rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Isltv(Insn);

impl Isltv {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "`dst = lhs <= rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Islev(Insn);

impl Islev {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "`dst = lhs > rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Isgtv(Insn);

impl Isgtv {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "`dst = lhs >= rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Isgev(Insn);

impl Isgev {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "`dst = lhs == rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Iseqv(Insn);

impl Iseqv {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "`dst = lhs != rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Isnev(Insn);

impl Isnev {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "`dst = lhs + rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Addvv(Insn);

impl Addvv {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "`dst = lhs + rhs` (register, literal)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Addvn(Insn);

impl Addvn {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Lit8 {
        Lit8(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "`dst = lhs + rhs` (literal, register)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Addnv(Insn);

impl Addnv {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Lit8 {
        Lit8(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "`dst = lhs - rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Subvv(Insn);

impl Subvv {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "`dst = lhs - rhs` (register, literal)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Subvn(Insn);

impl Subvn {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Lit8 {
        Lit8(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "`dst = lhs - rhs` (literal, register)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Subnv(Insn);

impl Subnv {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Lit8 {
        Lit8(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "`dst = lhs * rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Mulvv(Insn);

impl Mulvv {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "`dst = lhs * rhs` (register, literal)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Mulvn(Insn);

impl Mulvn {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Lit8 {
        Lit8(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "`dst = lhs * rhs` (literal, register)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Mulnv(Insn);

impl Mulnv {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Lit8 {
        Lit8(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "`dst = lhs / rhs` (register, register)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Divvv(Insn);

impl Divvv {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "`dst = lhs / rhs` (register, literal)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Divvn(Insn);

impl Divvn {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Lit8 {
        Lit8(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "`dst = lhs / rhs` (literal, register)"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Divnv(Insn);

impl Divnv {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn lhs(self) -> Lit8 {
        Lit8(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "`dst = -rhs`"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Unm(Insn);

impl Unm {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }
}

#[doc = "`dst = not rhs`"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Not(Insn);

impl Not {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn rhs(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }
}

#[doc = "`dst = callee(callee+1..callee+1+args)`"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Call(Insn);

impl Call {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn callee(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.b()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn args(self) -> Imm8 {
        Imm8(unsafe { ::core::mem::transmute(self.0.c()) })
    }
}

#[doc = "`dst = funcs[id](dst..dst+funcs[id].args)`"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Fastcall(Insn);

impl Fastcall {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn id(self) -> FnId {
        FnId(unsafe { ::core::mem::transmute(self.0.B()) })
    }
}

#[doc = "`dst = host[id](dst..dst+host[id].args)`"]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Hostcall(Insn);

impl Hostcall {
    #[allow(unnecessary_transmutes)]
    pub fn dst(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn id(self) -> HostId {
        HostId(unsafe { ::core::mem::transmute(self.0.B()) })
    }
}

#[doc = "Import a module.

`id` holds an `ImportInfo` literal that contains the module spec
and the mapping of module names to local registers."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Import(Insn);

impl Import {
    #[allow(unnecessary_transmutes)]
    pub fn _unused(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }

    #[allow(unnecessary_transmutes)]
    pub fn id(self) -> Lit {
        Lit(unsafe { ::core::mem::transmute(self.0.B()) })
    }
}

#[doc = "Return from the current call."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Ret(Insn);

impl Ret {}

#[doc = "Return from the current call, using value from `src`."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Retv(Insn);

impl Retv {
    #[allow(unnecessary_transmutes)]
    pub fn src(self) -> Reg {
        Reg(unsafe { ::core::mem::transmute(self.0.a()) })
    }
}

#[doc = "Stop execution, and yield to the VM's caller.
Never generated by the compiler."]
#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Stop(Insn);

impl Stop {}

#[doc(hidden)]
pub mod __operands {
    #![allow(non_camel_case_types)]

    pub type nop = super::Nop;
    pub type mov = super::Mov;
    pub type lmvar = super::Lmvar;
    pub type smvar = super::Smvar;
    pub type lcap = super::Lcap;
    pub type scap = super::Scap;
    pub type lidx = super::Lidx;
    pub type lidxn = super::Lidxn;
    pub type sidx = super::Sidx;
    pub type sidxn = super::Sidxn;
    pub type lkey = super::Lkey;
    pub type lkeyc = super::Lkeyc;
    pub type skey = super::Skey;
    pub type skeyc = super::Skeyc;
    pub type lnil = super::Lnil;
    pub type lsmi = super::Lsmi;
    pub type ltrue = super::Ltrue;
    pub type lfalse = super::Lfalse;
    pub type lint = super::Lint;
    pub type lnum = super::Lnum;
    pub type lstr = super::Lstr;
    pub type lclosure = super::Lclosure;
    pub type lfunc = super::Lfunc;
    pub type lhost = super::Lhost;
    pub type llist = super::Llist;
    pub type ltable = super::Ltable;
    pub type jmp = super::Jmp;
    pub type islt = super::Islt;
    pub type isle = super::Isle;
    pub type isgt = super::Isgt;
    pub type isge = super::Isge;
    pub type iseq = super::Iseq;
    pub type isne = super::Isne;
    pub type isnil = super::Isnil;
    pub type isnotnil = super::Isnotnil;
    pub type istrue = super::Istrue;
    pub type isfalse = super::Isfalse;
    pub type iseqs = super::Iseqs;
    pub type isnes = super::Isnes;
    pub type iseqi = super::Iseqi;
    pub type isnei = super::Isnei;
    pub type iseqf = super::Iseqf;
    pub type isnef = super::Isnef;
    pub type isltv = super::Isltv;
    pub type islev = super::Islev;
    pub type isgtv = super::Isgtv;
    pub type isgev = super::Isgev;
    pub type iseqv = super::Iseqv;
    pub type isnev = super::Isnev;
    pub type addvv = super::Addvv;
    pub type addvn = super::Addvn;
    pub type addnv = super::Addnv;
    pub type subvv = super::Subvv;
    pub type subvn = super::Subvn;
    pub type subnv = super::Subnv;
    pub type mulvv = super::Mulvv;
    pub type mulvn = super::Mulvn;
    pub type mulnv = super::Mulnv;
    pub type divvv = super::Divvv;
    pub type divvn = super::Divvn;
    pub type divnv = super::Divnv;
    pub type unm = super::Unm;
    pub type not = super::Not;
    pub type call = super::Call;
    pub type fastcall = super::Fastcall;
    pub type hostcall = super::Hostcall;
    pub type import = super::Import;
    pub type ret = super::Ret;
    pub type retv = super::Retv;
    pub type stop = super::Stop;
}

pub mod asm {
    use super::*;
    #[doc = "Do nothing."]
    pub const fn nop() -> Insn {
        op_abc(Opcode::Nop, 0, 0, 0)
    }
    #[doc = "Move value from register `src` to register `dst`."]
    pub const fn mov(dst: Reg, src: Reg) -> Insn {
        op_abc(Opcode::Mov, dst.0, src.0, 0)
    }
    #[doc = "Load module variable `src` to register `dst`."]
    pub const fn lmvar(dst: Reg, src: Mvar) -> Insn {
        op_aB(Opcode::Lmvar, dst.0, src.0)
    }
    #[doc = "Store register `dst` into module variable `mvar`."]
    pub const fn smvar(src: Reg, dst: Mvar) -> Insn {
        op_aB(Opcode::Smvar, src.0, dst.0)
    }
    #[doc = "Load current closure's capture `src` to register `dst`."]
    pub const fn lcap(dst: Reg, src: Cap) -> Insn {
        op_abc(Opcode::Lcap, dst.0, src.0, 0)
    }
    #[doc = "Store register `src` to current closure's capture `dst`."]
    pub const fn scap(dst: Cap, src: Reg) -> Insn {
        op_abc(Opcode::Scap, dst.0, src.0, 0)
    }
    #[doc = "Load index `idx` (register) from `target` (array or table) to register `dst`."]
    pub const fn lidx(dst: Reg, target: Reg, idx: Reg) -> Insn {
        op_abc(Opcode::Lidx, dst.0, target.0, idx.0)
    }
    #[doc = "Load index `idx` (literal) from `target` (array) to register `dst`."]
    pub const fn lidxn(dst: Reg, target: Reg, idx: Lit8) -> Insn {
        op_abc(Opcode::Lidxn, dst.0, target.0, idx.0)
    }
    #[doc = "Store value from `src` into `idx` (register) in `target` (array or table)."]
    pub const fn sidx(target: Reg, idx: Reg, src: Reg) -> Insn {
        op_abc(Opcode::Sidx, target.0, idx.0, src.0)
    }
    #[doc = "Store value from `src` into `idx` (register) in `target` (array)."]
    pub const fn sidxn(target: Reg, idx: Lit8, src: Reg) -> Insn {
        op_abc(Opcode::Sidxn, target.0, idx.0, src.0)
    }
    #[doc = "Load `key` (register) from `target` (object) to register `dst` (object)."]
    pub const fn lkey(dst: Reg, target: Reg, key: Reg) -> Insn {
        op_abc(Opcode::Lkey, dst.0, target.0, key.0)
    }
    #[doc = "Load `key` (literal) from `target` (object) to register `dst` (object)."]
    pub const fn lkeyc(dst: Reg, target: Reg, key: Lit8) -> Insn {
        op_abc(Opcode::Lkeyc, dst.0, target.0, key.0)
    }
    #[doc = "Store value from `src` into `key` (register) in `target` (object)."]
    pub const fn skey(target: Reg, key: Reg, src: Reg) -> Insn {
        op_abc(Opcode::Skey, target.0, key.0, src.0)
    }
    #[doc = "Store value from `src` into `key` (literal) in `target` (object)."]
    pub const fn skeyc(target: Reg, key: Lit8, src: Reg) -> Insn {
        op_abc(Opcode::Skeyc, target.0, key.0, src.0)
    }
    #[doc = "Load `nil` value into register `dst`."]
    pub const fn lnil(dst: Reg) -> Insn {
        op_abc(Opcode::Lnil, dst.0, 0, 0)
    }
    #[doc = "Load 16-bit integer `v` into register `dst`."]
    pub const fn lsmi(dst: Reg, v: Imm16s) -> Insn {
        op_aS(Opcode::Lsmi, dst.0, v.0)
    }
    #[doc = "Load literal `true` into register `dst`."]
    pub const fn ltrue(dst: Reg) -> Insn {
        op_abc(Opcode::Ltrue, dst.0, 0, 0)
    }
    #[doc = "Load literal `false` into register `dst`."]
    pub const fn lfalse(dst: Reg) -> Insn {
        op_abc(Opcode::Lfalse, dst.0, 0, 0)
    }
    #[doc = "Load literal by `id` into register `dst`.\n\n`id` holds a 64-bit integer."]
    pub const fn lint(dst: Reg, id: Lit) -> Insn {
        op_aB(Opcode::Lint, dst.0, id.0)
    }
    #[doc = "Load literal by `id` into register `dst`.\n\n`id` holds a 64-bit float."]
    pub const fn lnum(dst: Reg, id: Lit) -> Insn {
        op_aB(Opcode::Lnum, dst.0, id.0)
    }
    #[doc = "Load literal by `id` into register `dst`.\n\n`id` holds a string literal."]
    pub const fn lstr(dst: Reg, id: Lit) -> Insn {
        op_aB(Opcode::Lstr, dst.0, id.0)
    }
    #[doc = "Load closure function by `id` into register `dst`.\n\n`id` holds a `ClosureProto`."]
    pub const fn lclosure(dst: Reg, id: Lit) -> Insn {
        op_aB(Opcode::Lclosure, dst.0, id.0)
    }
    #[doc = "Load function by `id` into register `dst`."]
    pub const fn lfunc(dst: Reg, id: FnId) -> Insn {
        op_aB(Opcode::Lfunc, dst.0, id.0)
    }
    #[doc = "Load host function by `id` into register `dst`."]
    pub const fn lhost(dst: Reg, id: HostId) -> Insn {
        op_aB(Opcode::Lhost, dst.0, id.0)
    }
    #[doc = "Allocate a list with `capacity` into register `dst`."]
    pub const fn llist(dst: Reg, cap: Imm16) -> Insn {
        op_aB(Opcode::Llist, dst.0, cap.0)
    }
    #[doc = "Allocate an object with `capacity` into register `dst`."]
    pub const fn ltable(dst: Reg, cap: Imm16) -> Insn {
        op_aB(Opcode::Ltable, dst.0, cap.0)
    }
    #[doc = "Adjust instruction pointer by `rel`."]
    pub const fn jmp(rel: Imm24s) -> Insn {
        op_S(Opcode::Jmp, rel.0)
    }
    #[doc = "Skip `jmp` if `lhs < rhs` (register, register)"]
    pub const fn islt(lhs: Reg, rhs: Reg) -> Insn {
        op_abc(Opcode::Islt, lhs.0, rhs.0, 0)
    }
    #[doc = "Skip `jmp` if `lhs <= rhs` (register, register)"]
    pub const fn isle(lhs: Reg, rhs: Reg) -> Insn {
        op_abc(Opcode::Isle, lhs.0, rhs.0, 0)
    }
    #[doc = "Skip `jmp` if `lhs > rhs` (register, register)"]
    pub const fn isgt(lhs: Reg, rhs: Reg) -> Insn {
        op_abc(Opcode::Isgt, lhs.0, rhs.0, 0)
    }
    #[doc = "Skip `jmp` if `lhs >= rhs` (register, register)"]
    pub const fn isge(lhs: Reg, rhs: Reg) -> Insn {
        op_abc(Opcode::Isge, lhs.0, rhs.0, 0)
    }
    #[doc = "Skip `jmp` if `lhs == rhs` (register, register)"]
    pub const fn iseq(lhs: Reg, rhs: Reg) -> Insn {
        op_abc(Opcode::Iseq, lhs.0, rhs.0, 0)
    }
    #[doc = "Skip `jmp` if `lhs != rhs` (register, register)"]
    pub const fn isne(lhs: Reg, rhs: Reg) -> Insn {
        op_abc(Opcode::Isne, lhs.0, rhs.0, 0)
    }
    #[doc = "Skip `jmp` if `lhs == nil` (register, primitive)"]
    pub const fn isnil(v: Reg) -> Insn {
        op_abc(Opcode::Isnil, v.0, 0, 0)
    }
    #[doc = "Skip `jmp` if `lhs != nil` (register, primitive)"]
    pub const fn isnotnil(v: Reg) -> Insn {
        op_abc(Opcode::Isnotnil, v.0, 0, 0)
    }
    #[doc = "Skip `jmp` if `v` coerced to bool is `true`"]
    pub const fn istrue(v: Reg) -> Insn {
        op_abc(Opcode::Istrue, v.0, 0, 0)
    }
    #[doc = "Skip `jmp` if `v` coerced to bool is `false`"]
    pub const fn isfalse(v: Reg) -> Insn {
        op_abc(Opcode::Isfalse, v.0, 0, 0)
    }
    #[doc = "Skip `jmp` if `lhs == rhs` (register, literal string)"]
    pub const fn iseqs(lhs: Reg, rhs: Lit) -> Insn {
        op_aB(Opcode::Iseqs, lhs.0, rhs.0)
    }
    #[doc = "Skip `jmp` if `lhs != rhs` (register, literal string)"]
    pub const fn isnes(lhs: Reg, rhs: Lit) -> Insn {
        op_aB(Opcode::Isnes, lhs.0, rhs.0)
    }
    #[doc = "Skip `jmp` if `lhs == rhs` (register, literal int)"]
    pub const fn iseqi(lhs: Reg, rhs: Lit) -> Insn {
        op_aB(Opcode::Iseqi, lhs.0, rhs.0)
    }
    #[doc = "Skip `jmp` if `lhs != rhs` (register, literal int)"]
    pub const fn isnei(lhs: Reg, rhs: Lit) -> Insn {
        op_aB(Opcode::Isnei, lhs.0, rhs.0)
    }
    #[doc = "Skip `jmp` if `lhs == rhs` (register, literal float)"]
    pub const fn iseqf(lhs: Reg, rhs: Lit) -> Insn {
        op_aB(Opcode::Iseqf, lhs.0, rhs.0)
    }
    #[doc = "Skip `jmp` if `lhs != rhs` (register, literal float)"]
    pub const fn isnef(lhs: Reg, rhs: Lit) -> Insn {
        op_aB(Opcode::Isnef, lhs.0, rhs.0)
    }
    #[doc = "`dst = lhs < rhs` (register, register)"]
    pub const fn isltv(dst: Reg, lhs: Reg, rhs: Reg) -> Insn {
        op_abc(Opcode::Isltv, dst.0, lhs.0, rhs.0)
    }
    #[doc = "`dst = lhs <= rhs` (register, register)"]
    pub const fn islev(dst: Reg, lhs: Reg, rhs: Reg) -> Insn {
        op_abc(Opcode::Islev, dst.0, lhs.0, rhs.0)
    }
    #[doc = "`dst = lhs > rhs` (register, register)"]
    pub const fn isgtv(dst: Reg, lhs: Reg, rhs: Reg) -> Insn {
        op_abc(Opcode::Isgtv, dst.0, lhs.0, rhs.0)
    }
    #[doc = "`dst = lhs >= rhs` (register, register)"]
    pub const fn isgev(dst: Reg, lhs: Reg, rhs: Reg) -> Insn {
        op_abc(Opcode::Isgev, dst.0, lhs.0, rhs.0)
    }
    #[doc = "`dst = lhs == rhs` (register, register)"]
    pub const fn iseqv(dst: Reg, lhs: Reg, rhs: Reg) -> Insn {
        op_abc(Opcode::Iseqv, dst.0, lhs.0, rhs.0)
    }
    #[doc = "`dst = lhs != rhs` (register, register)"]
    pub const fn isnev(dst: Reg, lhs: Reg, rhs: Reg) -> Insn {
        op_abc(Opcode::Isnev, dst.0, lhs.0, rhs.0)
    }
    #[doc = "`dst = lhs + rhs` (register, register)"]
    pub const fn addvv(dst: Reg, lhs: Reg, rhs: Reg) -> Insn {
        op_abc(Opcode::Addvv, dst.0, lhs.0, rhs.0)
    }
    #[doc = "`dst = lhs + rhs` (register, literal)"]
    pub const fn addvn(dst: Reg, lhs: Reg, rhs: Lit8) -> Insn {
        op_abc(Opcode::Addvn, dst.0, lhs.0, rhs.0)
    }
    #[doc = "`dst = lhs + rhs` (literal, register)"]
    pub const fn addnv(dst: Reg, lhs: Lit8, rhs: Reg) -> Insn {
        op_abc(Opcode::Addnv, dst.0, lhs.0, rhs.0)
    }
    #[doc = "`dst = lhs - rhs` (register, register)"]
    pub const fn subvv(dst: Reg, lhs: Reg, rhs: Reg) -> Insn {
        op_abc(Opcode::Subvv, dst.0, lhs.0, rhs.0)
    }
    #[doc = "`dst = lhs - rhs` (register, literal)"]
    pub const fn subvn(dst: Reg, lhs: Reg, rhs: Lit8) -> Insn {
        op_abc(Opcode::Subvn, dst.0, lhs.0, rhs.0)
    }
    #[doc = "`dst = lhs - rhs` (literal, register)"]
    pub const fn subnv(dst: Reg, lhs: Lit8, rhs: Reg) -> Insn {
        op_abc(Opcode::Subnv, dst.0, lhs.0, rhs.0)
    }
    #[doc = "`dst = lhs * rhs` (register, register)"]
    pub const fn mulvv(dst: Reg, lhs: Reg, rhs: Reg) -> Insn {
        op_abc(Opcode::Mulvv, dst.0, lhs.0, rhs.0)
    }
    #[doc = "`dst = lhs * rhs` (register, literal)"]
    pub const fn mulvn(dst: Reg, lhs: Reg, rhs: Lit8) -> Insn {
        op_abc(Opcode::Mulvn, dst.0, lhs.0, rhs.0)
    }
    #[doc = "`dst = lhs * rhs` (literal, register)"]
    pub const fn mulnv(dst: Reg, lhs: Lit8, rhs: Reg) -> Insn {
        op_abc(Opcode::Mulnv, dst.0, lhs.0, rhs.0)
    }
    #[doc = "`dst = lhs / rhs` (register, register)"]
    pub const fn divvv(dst: Reg, lhs: Reg, rhs: Reg) -> Insn {
        op_abc(Opcode::Divvv, dst.0, lhs.0, rhs.0)
    }
    #[doc = "`dst = lhs / rhs` (register, literal)"]
    pub const fn divvn(dst: Reg, lhs: Reg, rhs: Lit8) -> Insn {
        op_abc(Opcode::Divvn, dst.0, lhs.0, rhs.0)
    }
    #[doc = "`dst = lhs / rhs` (literal, register)"]
    pub const fn divnv(dst: Reg, lhs: Lit8, rhs: Reg) -> Insn {
        op_abc(Opcode::Divnv, dst.0, lhs.0, rhs.0)
    }
    #[doc = "`dst = -rhs`"]
    pub const fn unm(dst: Reg, rhs: Reg) -> Insn {
        op_abc(Opcode::Unm, dst.0, rhs.0, 0)
    }
    #[doc = "`dst = not rhs`"]
    pub const fn not(dst: Reg, rhs: Reg) -> Insn {
        op_abc(Opcode::Not, dst.0, rhs.0, 0)
    }
    #[doc = "`dst = callee(callee+1..callee+1+args)`"]
    pub const fn call(dst: Reg, callee: Reg, args: Imm8) -> Insn {
        op_abc(Opcode::Call, dst.0, callee.0, args.0)
    }
    #[doc = "`dst = funcs[id](dst..dst+funcs[id].args)`"]
    pub const fn fastcall(dst: Reg, id: FnId) -> Insn {
        op_aB(Opcode::Fastcall, dst.0, id.0)
    }
    #[doc = "`dst = host[id](dst..dst+host[id].args)`"]
    pub const fn hostcall(dst: Reg, id: HostId) -> Insn {
        op_aB(Opcode::Hostcall, dst.0, id.0)
    }
    #[doc = "Import a module.\n\n`id` holds an `ImportInfo` literal that contains the module spec\nand the mapping of module names to local registers."]
    pub const fn import(_unused: Reg, id: Lit) -> Insn {
        op_aB(Opcode::Import, _unused.0, id.0)
    }
    #[doc = "Return from the current call."]
    pub const fn ret() -> Insn {
        op_abc(Opcode::Ret, 0, 0, 0)
    }
    #[doc = "Return from the current call, using value from `src`."]
    pub const fn retv(src: Reg) -> Insn {
        op_abc(Opcode::Retv, src.0, 0, 0)
    }
    #[doc = "Stop execution, and yield to the VM's caller.\nNever generated by the compiler."]
    pub const fn stop() -> Insn {
        op_abc(Opcode::Stop, 0, 0, 0)
    }
}
#[repr(C)]
pub struct JumpTable {
    pub nop: OpaqueHandler,
    pub mov: OpaqueHandler,
    pub lmvar: OpaqueHandler,
    pub smvar: OpaqueHandler,
    pub lcap: OpaqueHandler,
    pub scap: OpaqueHandler,
    pub lidx: OpaqueHandler,
    pub lidxn: OpaqueHandler,
    pub sidx: OpaqueHandler,
    pub sidxn: OpaqueHandler,
    pub lkey: OpaqueHandler,
    pub lkeyc: OpaqueHandler,
    pub skey: OpaqueHandler,
    pub skeyc: OpaqueHandler,
    pub lnil: OpaqueHandler,
    pub lsmi: OpaqueHandler,
    pub ltrue: OpaqueHandler,
    pub lfalse: OpaqueHandler,
    pub lint: OpaqueHandler,
    pub lnum: OpaqueHandler,
    pub lstr: OpaqueHandler,
    pub lclosure: OpaqueHandler,
    pub lfunc: OpaqueHandler,
    pub lhost: OpaqueHandler,
    pub llist: OpaqueHandler,
    pub ltable: OpaqueHandler,
    pub jmp: OpaqueHandler,
    pub islt: OpaqueHandler,
    pub isle: OpaqueHandler,
    pub isgt: OpaqueHandler,
    pub isge: OpaqueHandler,
    pub iseq: OpaqueHandler,
    pub isne: OpaqueHandler,
    pub isnil: OpaqueHandler,
    pub isnotnil: OpaqueHandler,
    pub istrue: OpaqueHandler,
    pub isfalse: OpaqueHandler,
    pub iseqs: OpaqueHandler,
    pub isnes: OpaqueHandler,
    pub iseqi: OpaqueHandler,
    pub isnei: OpaqueHandler,
    pub iseqf: OpaqueHandler,
    pub isnef: OpaqueHandler,
    pub isltv: OpaqueHandler,
    pub islev: OpaqueHandler,
    pub isgtv: OpaqueHandler,
    pub isgev: OpaqueHandler,
    pub iseqv: OpaqueHandler,
    pub isnev: OpaqueHandler,
    pub addvv: OpaqueHandler,
    pub addvn: OpaqueHandler,
    pub addnv: OpaqueHandler,
    pub subvv: OpaqueHandler,
    pub subvn: OpaqueHandler,
    pub subnv: OpaqueHandler,
    pub mulvv: OpaqueHandler,
    pub mulvn: OpaqueHandler,
    pub mulnv: OpaqueHandler,
    pub divvv: OpaqueHandler,
    pub divvn: OpaqueHandler,
    pub divnv: OpaqueHandler,
    pub unm: OpaqueHandler,
    pub not: OpaqueHandler,
    pub call: OpaqueHandler,
    pub fastcall: OpaqueHandler,
    pub hostcall: OpaqueHandler,
    pub import: OpaqueHandler,
    pub ret: OpaqueHandler,
    pub retv: OpaqueHandler,
    pub stop: OpaqueHandler,
}

impl JumpTable {
    #[inline]
    pub fn as_ptr(&self) -> Jt {
        let ptr = self as *const JumpTable as *mut OpaqueHandler;
        let ptr = unsafe { NonNull::new_unchecked(ptr) };
        Jt(ptr)
    }
}
