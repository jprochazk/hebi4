// Generated by asmgen at 2025-08-05T18:52:48.854255543+00:00[UTC]
//
// See `asmgen/src/main.rs` and `asmgen/src/runtime.rs`
#![allow(unsafe_op_in_unsafe_fn)]

mod private {
    pub trait Sealed {}
}

use super::{Context, Control, Literal, Value};

pub trait OperandPack: private::Sealed + Sized {}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Sp(pub(crate) *mut Value);

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Ip(pub(crate) *const RawInstruction);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct RawInstruction {
    pub(crate) tag: u8,
    pub(crate) payload: [u8; 3],
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Jt(pub(crate) *const OpaqueOp);

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Lp(pub(crate) *const Literal);

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct Ctx(pub(crate) *mut Context);

const _: () = {
    use std::mem::align_of;
    assert!(align_of::<JumpTable>() == align_of::<[OpaqueOp; 1]>());
};

#[allow(non_camel_case_types)]
#[derive(Clone, Copy, Hash)]
#[repr(C, packed)]
pub struct u24([u8; 3]);

impl u24 {
    pub const MAX: u24 = u24([255; 3]);
    pub const MIN: u24 = u24([0; 3]);
    pub const ZERO: u24 = u24([0; 3]);

    #[inline]
    pub const fn new(v: u32) -> Self {
        if v > Self::MAX.get() {
            panic!("value is out of bounds for u24");
        }

        unsafe { Self::new_unchecked(v) }
    }

    #[inline]
    pub const unsafe fn new_unchecked(v: u32) -> Self {
        let [a, b, c, _] = v.to_le_bytes();
        Self([a, b, c])
    }

    #[inline]
    pub const fn get(self) -> u32 {
        let [a, b, c] = self.0;
        u32::from_le_bytes([a, b, c, 0])
    }
}

impl PartialEq for u24 {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        PartialEq::eq(&self.get(), &other.get())
    }
}

impl Eq for u24 {}

impl PartialOrd for u24 {
    #[inline]
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        PartialOrd::partial_cmp(&self.get(), &other.get())
    }
}

impl Ord for u24 {
    #[inline]
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        Ord::cmp(&self.get(), &other.get())
    }
}

impl std::fmt::Debug for u24 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        <u32 as std::fmt::Debug>::fmt(&self.get(), f)
    }
}

impl std::fmt::Display for u24 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        <u32 as std::fmt::Display>::fmt(&self.get(), f)
    }
}

#[cfg(not(windows))]
macro_rules! Op {
    (
        fn ($($ty:ty),* $(,)?) -> $ret:ty
    ) => {
        unsafe extern "C" fn($($ty),*) -> $ret
    };
}

#[cfg(windows)]
macro_rules! Op {
    (
        fn ($($ty:ty),* $(,)?) -> $ret:ty
    ) => {
        unsafe extern "sysv64" fn($($ty),*) -> $ret
    };
}

#[cfg(not(windows))]
macro_rules! op {
    (
        unsafe extern "?" fn $name:ident($($i:ident : $ty:ty),* $(,)?) -> $ret:ty $body:block
    ) => {
        unsafe extern "C" fn $name($($i:$ty),*) -> $ret $body
    };
}

#[cfg(windows)]
macro_rules! op {
    (
        unsafe extern "?" fn $name:ident($($i:ident : $ty:ty),* $(,)?) -> $ret:ty $body:block
    ) => {
        unsafe extern "sysv64" fn $name($($i:$ty),*) -> $ret $body
    };
}

macro_rules! jump_table {
    {
        $($op:ident),* $(,)?
    } => {
        JumpTable {
            $($op: {
                type __Operands = $crate::codegen::opcodes::__operands::$op;
                const __OP: unsafe fn(__Operands, Jt, Sp, Lp, Ip, Ctx) -> Control = $op;

                {
                    op! {
                        unsafe extern "?" fn $op(args: RawInstruction, jt: Jt, sp: Sp, lp: Lp, ip: Ip, ctx: Ctx) -> Control {
                            let args: __Operands = core::mem::transmute(args);
                            __OP(args, jt, sp, lp, ip, ctx)
                        }
                    }

                    $op
                }
            }),*
        }
    };
}

pub type Op<Operands> = Op!(fn(Operands, Jt, Sp, Lp, Ip, Ctx) -> Control);

pub type OpaqueOp = Op!(fn(RawInstruction, Jt, Sp, Lp, Ip, Ctx) -> Control);

macro_rules! declare_operand_type {
    ($name:ident, $ty:ident, $fmt:literal) => {
        #[derive(Clone, Copy)]
        #[repr(transparent)]
        pub struct $name($ty);

        impl $name {
            #[inline(always)]
            pub fn get(self) -> $ty {
                self.0
            }

            #[inline(always)]
            pub unsafe fn new_unchecked(v: $ty) -> Self {
                Self(v)
            }

            #[inline(always)]
            pub fn zx(self) -> usize {
                self.0.zx()
            }

            #[inline(always)]
            pub fn sz(self) -> isize {
                self.0.sz()
            }
        }

        impl std::fmt::Display for $name {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(f, $fmt, self.0)
            }
        }
    };
}

trait ExtendEx: Sized {
    fn zx(self) -> usize;
    fn sz(self) -> isize;
}

macro_rules! extend_primitive {
    ($ty:ty) => {
        impl ExtendEx for $ty {
            #[inline(always)]
            fn zx(self) -> usize {
                self as usize
            }

            #[inline(always)]
            fn sz(self) -> isize {
                self as isize
            }
        }
    };
}

extend_primitive!(u8);
extend_primitive!(u16);
extend_primitive!(i16);

impl ExtendEx for u24 {
    #[inline(always)]
    fn zx(self) -> usize {
        self.get() as usize
    }

    #[inline(always)]
    fn sz(self) -> isize {
        self.get() as isize
    }
}

macro_rules! declare_operand_types {
    (
        $(
            $name:ident($ty:ident) = $fmt:literal
        ),* $(,)?
    ) => {
        $(
            declare_operand_type!($name, $ty, $fmt);
        )*
    };
}

declare_operand_types! {
    Reg(u8) = "r{}",

    Lit(u16) = "l{}",
    Lit8(u8) = "l{}",

    FnId(u16) = "fn{}",

    Imm8(u8) = "{}",
    Imm16(i16) = "{}",
    Imm24(u24) = "{}",
}

const fn assert_bit_equal<A, B>(a: &A, b: &B) {
    let a: [u32; 1] = unsafe { (a as *const A as *const [u32; 1]).read() };
    let b: [u32; 1] = unsafe { (b as *const B as *const [u32; 1]).read() };
    if a[0] != b[0] {
        panic!("not bit equal");
    }
}

// ...

#[derive(Clone, Copy)]
#[repr(u8, align(4))]
pub enum Instruction {
    Nop { _a: u8, _b: u8, _c: u8 } = 0,
    Mov { dst: Reg, src: Reg, _c: u8 } = 1,
    Lnil { dst: Reg, _b: u8, _c: u8 } = 2,
    Lsmi { dst: Reg, v: Imm16 } = 3,
    Ltrue { dst: Reg, _b: u8, _c: u8 } = 4,
    Lfalse { dst: Reg, _b: u8, _c: u8 } = 5,
    Lint { dst: Reg, id: Lit } = 6,
    Lnum { dst: Reg, id: Lit } = 7,
    Lstr { dst: Reg, id: Lit } = 8,
    Lcli { dst: Reg, id: Lit } = 9,
    Lfni { dst: Reg, id: Lit } = 10,
    Larr { dst: Reg, len: Imm8, _c: u8 } = 11,
    Lobj { dst: Reg, len: Imm8, _c: u8 } = 12,
    Jmp { rel: Imm24 } = 13,
    Istrue { v: Reg, _b: u8, _c: u8 } = 14,
    Istruec { dst: Reg, v: Reg, _c: u8 } = 15,
    Isfalse { v: Reg, _b: u8, _c: u8 } = 16,
    Isfalsec { dst: Reg, v: Reg, _c: u8 } = 17,
    Islt { lhs: Reg, rhs: Reg, _c: u8 } = 18,
    Isle { lhs: Reg, rhs: Reg, _c: u8 } = 19,
    Isgt { lhs: Reg, rhs: Reg, _c: u8 } = 20,
    Isge { lhs: Reg, rhs: Reg, _c: u8 } = 21,
    Iseq { lhs: Reg, rhs: Reg, _c: u8 } = 22,
    Isne { lhs: Reg, rhs: Reg, _c: u8 } = 23,
    Iseqs { lhs: Reg, rhs: Lit } = 24,
    Isnes { lhs: Reg, rhs: Lit } = 25,
    Iseqn { lhs: Reg, rhs: Lit } = 26,
    Isnen { lhs: Reg, rhs: Lit } = 27,
    Iseqp { lhs: Reg, rhs: Imm8, _c: u8 } = 28,
    Isnep { lhs: Reg, rhs: Imm8, _c: u8 } = 29,
    Addvv { dst: Reg, lhs: Reg, rhs: Reg } = 30,
    Addvn { dst: Reg, lhs: Reg, rhs: Lit8 } = 31,
    Addnv { dst: Reg, lhs: Lit8, rhs: Reg } = 32,
    Subvv { dst: Reg, lhs: Reg, rhs: Reg } = 33,
    Subvn { dst: Reg, lhs: Reg, rhs: Lit8 } = 34,
    Subnv { dst: Reg, lhs: Lit8, rhs: Reg } = 35,
    Mulvv { dst: Reg, lhs: Reg, rhs: Reg } = 36,
    Mulvn { dst: Reg, lhs: Reg, rhs: Lit8 } = 37,
    Mulnv { dst: Reg, lhs: Lit8, rhs: Reg } = 38,
    Divvv { dst: Reg, lhs: Reg, rhs: Reg } = 39,
    Divvn { dst: Reg, lhs: Reg, rhs: Lit8 } = 40,
    Divnv { dst: Reg, lhs: Lit8, rhs: Reg } = 41,
    Unm { dst: Reg, rhs: Reg, _c: u8 } = 42,
    Not { dst: Reg, rhs: Reg, _c: u8 } = 43,
    Call { dst: Reg, func: Reg, args: Imm8 } = 44,
    Fastcall { dst: Reg, id: FnId } = 45,
    Ret { _a: u8, _b: u8, _c: u8 } = 46,
    Stop { _a: u8, _b: u8, _c: u8 } = 47,
    Trap { _a: u8, _b: u8, _c: u8 } = 48,
}

// assert compatibility with `u32`
const _: () = assert!(std::mem::size_of::<Instruction>() == std::mem::size_of::<u32>());
const _: () = assert!(std::mem::align_of::<Instruction>() == std::mem::align_of::<u32>());

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Nop {
    _op: u8,
    _a: u8,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Nop>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Nop>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Nop {
        _op: 0,
        _a: 0x7A,
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Nop {
        _a: 0x7A,
        _b: 0x7B,
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Mov {
    _op: u8,
    pub dst: Reg,
    pub src: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Mov>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Mov>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Mov {
        _op: 1,
        dst: Reg(0x7A),
        src: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Mov {
        dst: Reg(0x7A),
        src: Reg(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lnil {
    _op: u8,
    pub dst: Reg,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Lnil>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lnil>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lnil {
        _op: 2,
        dst: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Lnil {
        dst: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lsmi {
    _op: u8,
    pub dst: Reg,
    pub v: Imm16,
}

const _: () = assert!(std::mem::size_of::<Lsmi>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lsmi>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lsmi {
        _op: 3,
        dst: Reg(0x7A),
        v: Imm16(0x7B7C),
    },
    &Instruction::Lsmi {
        dst: Reg(0x7A),
        v: Imm16(0x7B7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Ltrue {
    _op: u8,
    pub dst: Reg,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Ltrue>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Ltrue>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Ltrue {
        _op: 4,
        dst: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Ltrue {
        dst: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lfalse {
    _op: u8,
    pub dst: Reg,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Lfalse>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lfalse>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lfalse {
        _op: 5,
        dst: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Lfalse {
        dst: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lint {
    _op: u8,
    pub dst: Reg,
    pub id: Lit,
}

const _: () = assert!(std::mem::size_of::<Lint>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lint>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lint {
        _op: 6,
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
    &Instruction::Lint {
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lnum {
    _op: u8,
    pub dst: Reg,
    pub id: Lit,
}

const _: () = assert!(std::mem::size_of::<Lnum>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lnum>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lnum {
        _op: 7,
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
    &Instruction::Lnum {
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lstr {
    _op: u8,
    pub dst: Reg,
    pub id: Lit,
}

const _: () = assert!(std::mem::size_of::<Lstr>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lstr>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lstr {
        _op: 8,
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
    &Instruction::Lstr {
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lcli {
    _op: u8,
    pub dst: Reg,
    pub id: Lit,
}

const _: () = assert!(std::mem::size_of::<Lcli>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lcli>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lcli {
        _op: 9,
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
    &Instruction::Lcli {
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lfni {
    _op: u8,
    pub dst: Reg,
    pub id: Lit,
}

const _: () = assert!(std::mem::size_of::<Lfni>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lfni>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lfni {
        _op: 10,
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
    &Instruction::Lfni {
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Larr {
    _op: u8,
    pub dst: Reg,
    pub len: Imm8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Larr>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Larr>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Larr {
        _op: 11,
        dst: Reg(0x7A),
        len: Imm8(0x7B),
        _c: 0x7C,
    },
    &Instruction::Larr {
        dst: Reg(0x7A),
        len: Imm8(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lobj {
    _op: u8,
    pub dst: Reg,
    pub len: Imm8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Lobj>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lobj>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lobj {
        _op: 12,
        dst: Reg(0x7A),
        len: Imm8(0x7B),
        _c: 0x7C,
    },
    &Instruction::Lobj {
        dst: Reg(0x7A),
        len: Imm8(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Jmp {
    _op: u8,
    pub rel: Imm24,
}

const _: () = assert!(std::mem::size_of::<Jmp>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Jmp>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Jmp {
        _op: 13,
        rel: Imm24(u24::new(0x7A7B7C)),
    },
    &Instruction::Jmp {
        rel: Imm24(u24::new(0x7A7B7C)),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Istrue {
    _op: u8,
    pub v: Reg,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Istrue>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Istrue>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Istrue {
        _op: 14,
        v: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Istrue {
        v: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Istruec {
    _op: u8,
    pub dst: Reg,
    pub v: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Istruec>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Istruec>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Istruec {
        _op: 15,
        dst: Reg(0x7A),
        v: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Istruec {
        dst: Reg(0x7A),
        v: Reg(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isfalse {
    _op: u8,
    pub v: Reg,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Isfalse>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isfalse>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isfalse {
        _op: 16,
        v: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Isfalse {
        v: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isfalsec {
    _op: u8,
    pub dst: Reg,
    pub v: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Isfalsec>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isfalsec>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isfalsec {
        _op: 17,
        dst: Reg(0x7A),
        v: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Isfalsec {
        dst: Reg(0x7A),
        v: Reg(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Islt {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Islt>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Islt>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Islt {
        _op: 18,
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Islt {
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isle {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Isle>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isle>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isle {
        _op: 19,
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Isle {
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isgt {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Isgt>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isgt>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isgt {
        _op: 20,
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Isgt {
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isge {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Isge>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isge>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isge {
        _op: 21,
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Isge {
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Iseq {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Iseq>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Iseq>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Iseq {
        _op: 22,
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Iseq {
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isne {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Isne>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isne>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isne {
        _op: 23,
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Isne {
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Iseqs {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Lit,
}

const _: () = assert!(std::mem::size_of::<Iseqs>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Iseqs>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Iseqs {
        _op: 24,
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
    &Instruction::Iseqs {
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isnes {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Lit,
}

const _: () = assert!(std::mem::size_of::<Isnes>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isnes>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isnes {
        _op: 25,
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
    &Instruction::Isnes {
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Iseqn {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Lit,
}

const _: () = assert!(std::mem::size_of::<Iseqn>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Iseqn>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Iseqn {
        _op: 26,
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
    &Instruction::Iseqn {
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isnen {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Lit,
}

const _: () = assert!(std::mem::size_of::<Isnen>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isnen>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isnen {
        _op: 27,
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
    &Instruction::Isnen {
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Iseqp {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Imm8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Iseqp>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Iseqp>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Iseqp {
        _op: 28,
        lhs: Reg(0x7A),
        rhs: Imm8(0x7B),
        _c: 0x7C,
    },
    &Instruction::Iseqp {
        lhs: Reg(0x7A),
        rhs: Imm8(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isnep {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Imm8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Isnep>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isnep>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isnep {
        _op: 29,
        lhs: Reg(0x7A),
        rhs: Imm8(0x7B),
        _c: 0x7C,
    },
    &Instruction::Isnep {
        lhs: Reg(0x7A),
        rhs: Imm8(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Addvv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Addvv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Addvv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Addvv {
        _op: 30,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Addvv {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Addvn {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Lit8,
}

const _: () = assert!(std::mem::size_of::<Addvn>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Addvn>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Addvn {
        _op: 31,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
    &Instruction::Addvn {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Addnv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Lit8,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Addnv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Addnv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Addnv {
        _op: 32,
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Addnv {
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Subvv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Subvv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Subvv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Subvv {
        _op: 33,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Subvv {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Subvn {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Lit8,
}

const _: () = assert!(std::mem::size_of::<Subvn>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Subvn>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Subvn {
        _op: 34,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
    &Instruction::Subvn {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Subnv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Lit8,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Subnv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Subnv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Subnv {
        _op: 35,
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Subnv {
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Mulvv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Mulvv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Mulvv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Mulvv {
        _op: 36,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Mulvv {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Mulvn {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Lit8,
}

const _: () = assert!(std::mem::size_of::<Mulvn>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Mulvn>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Mulvn {
        _op: 37,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
    &Instruction::Mulvn {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Mulnv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Lit8,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Mulnv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Mulnv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Mulnv {
        _op: 38,
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Mulnv {
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Divvv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Divvv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Divvv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Divvv {
        _op: 39,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Divvv {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Divvn {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Lit8,
}

const _: () = assert!(std::mem::size_of::<Divvn>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Divvn>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Divvn {
        _op: 40,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
    &Instruction::Divvn {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Divnv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Lit8,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Divnv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Divnv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Divnv {
        _op: 41,
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Divnv {
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Unm {
    _op: u8,
    pub dst: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Unm>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Unm>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Unm {
        _op: 42,
        dst: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Unm {
        dst: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Not {
    _op: u8,
    pub dst: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Not>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Not>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Not {
        _op: 43,
        dst: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Not {
        dst: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Call {
    _op: u8,
    pub dst: Reg,
    pub func: Reg,
    pub args: Imm8,
}

const _: () = assert!(std::mem::size_of::<Call>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Call>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Call {
        _op: 44,
        dst: Reg(0x7A),
        func: Reg(0x7B),
        args: Imm8(0x7C),
    },
    &Instruction::Call {
        dst: Reg(0x7A),
        func: Reg(0x7B),
        args: Imm8(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Fastcall {
    _op: u8,
    pub dst: Reg,
    pub id: FnId,
}

const _: () = assert!(std::mem::size_of::<Fastcall>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Fastcall>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Fastcall {
        _op: 45,
        dst: Reg(0x7A),
        id: FnId(0x7B7C),
    },
    &Instruction::Fastcall {
        dst: Reg(0x7A),
        id: FnId(0x7B7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Ret {
    _op: u8,
    _a: u8,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Ret>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Ret>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Ret {
        _op: 46,
        _a: 0x7A,
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Ret {
        _a: 0x7A,
        _b: 0x7B,
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Stop {
    _op: u8,
    _a: u8,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Stop>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Stop>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Stop {
        _op: 47,
        _a: 0x7A,
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Stop {
        _a: 0x7A,
        _b: 0x7B,
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Trap {
    _op: u8,
    _a: u8,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Trap>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Trap>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Trap {
        _op: 48,
        _a: 0x7A,
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Trap {
        _a: 0x7A,
        _b: 0x7B,
        _c: 0x7C,
    },
);

#[doc(hidden)]
pub mod __operands {
    #![allow(non_camel_case_types)]

    pub type nop = super::Nop;
    pub type mov = super::Mov;
    pub type lnil = super::Lnil;
    pub type lsmi = super::Lsmi;
    pub type ltrue = super::Ltrue;
    pub type lfalse = super::Lfalse;
    pub type lint = super::Lint;
    pub type lnum = super::Lnum;
    pub type lstr = super::Lstr;
    pub type lcli = super::Lcli;
    pub type lfni = super::Lfni;
    pub type larr = super::Larr;
    pub type lobj = super::Lobj;
    pub type jmp = super::Jmp;
    pub type istrue = super::Istrue;
    pub type istruec = super::Istruec;
    pub type isfalse = super::Isfalse;
    pub type isfalsec = super::Isfalsec;
    pub type islt = super::Islt;
    pub type isle = super::Isle;
    pub type isgt = super::Isgt;
    pub type isge = super::Isge;
    pub type iseq = super::Iseq;
    pub type isne = super::Isne;
    pub type iseqs = super::Iseqs;
    pub type isnes = super::Isnes;
    pub type iseqn = super::Iseqn;
    pub type isnen = super::Isnen;
    pub type iseqp = super::Iseqp;
    pub type isnep = super::Isnep;
    pub type addvv = super::Addvv;
    pub type addvn = super::Addvn;
    pub type addnv = super::Addnv;
    pub type subvv = super::Subvv;
    pub type subvn = super::Subvn;
    pub type subnv = super::Subnv;
    pub type mulvv = super::Mulvv;
    pub type mulvn = super::Mulvn;
    pub type mulnv = super::Mulnv;
    pub type divvv = super::Divvv;
    pub type divvn = super::Divvn;
    pub type divnv = super::Divnv;
    pub type unm = super::Unm;
    pub type not = super::Not;
    pub type call = super::Call;
    pub type fastcall = super::Fastcall;
    pub type ret = super::Ret;
    pub type stop = super::Stop;
    pub type trap = super::Trap;
}

pub mod asm {
    use super::*;
    pub const fn nop() -> Instruction {
        Instruction::Nop {
            _a: 0x7F,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
    pub const fn mov(dst: Reg, src: Reg) -> Instruction {
        Instruction::Mov { dst, src, _c: 0x7F }
    }
    pub const fn lnil(dst: Reg) -> Instruction {
        Instruction::Lnil {
            dst,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
    pub const fn lsmi(dst: Reg, v: Imm16) -> Instruction {
        Instruction::Lsmi { dst, v }
    }
    pub const fn ltrue(dst: Reg) -> Instruction {
        Instruction::Ltrue {
            dst,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
    pub const fn lfalse(dst: Reg) -> Instruction {
        Instruction::Lfalse {
            dst,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
    pub const fn lint(dst: Reg, id: Lit) -> Instruction {
        Instruction::Lint { dst, id }
    }
    pub const fn lnum(dst: Reg, id: Lit) -> Instruction {
        Instruction::Lnum { dst, id }
    }
    pub const fn lstr(dst: Reg, id: Lit) -> Instruction {
        Instruction::Lstr { dst, id }
    }
    pub const fn lcli(dst: Reg, id: Lit) -> Instruction {
        Instruction::Lcli { dst, id }
    }
    pub const fn lfni(dst: Reg, id: Lit) -> Instruction {
        Instruction::Lfni { dst, id }
    }
    pub const fn larr(dst: Reg, len: Imm8) -> Instruction {
        Instruction::Larr { dst, len, _c: 0x7F }
    }
    pub const fn lobj(dst: Reg, len: Imm8) -> Instruction {
        Instruction::Lobj { dst, len, _c: 0x7F }
    }
    pub const fn jmp(rel: Imm24) -> Instruction {
        Instruction::Jmp { rel }
    }
    pub const fn istrue(v: Reg) -> Instruction {
        Instruction::Istrue {
            v,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
    pub const fn istruec(dst: Reg, v: Reg) -> Instruction {
        Instruction::Istruec { dst, v, _c: 0x7F }
    }
    pub const fn isfalse(v: Reg) -> Instruction {
        Instruction::Isfalse {
            v,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
    pub const fn isfalsec(dst: Reg, v: Reg) -> Instruction {
        Instruction::Isfalsec { dst, v, _c: 0x7F }
    }
    pub const fn islt(lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Islt { lhs, rhs, _c: 0x7F }
    }
    pub const fn isle(lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Isle { lhs, rhs, _c: 0x7F }
    }
    pub const fn isgt(lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Isgt { lhs, rhs, _c: 0x7F }
    }
    pub const fn isge(lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Isge { lhs, rhs, _c: 0x7F }
    }
    pub const fn iseq(lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Iseq { lhs, rhs, _c: 0x7F }
    }
    pub const fn isne(lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Isne { lhs, rhs, _c: 0x7F }
    }
    pub const fn iseqs(lhs: Reg, rhs: Lit) -> Instruction {
        Instruction::Iseqs { lhs, rhs }
    }
    pub const fn isnes(lhs: Reg, rhs: Lit) -> Instruction {
        Instruction::Isnes { lhs, rhs }
    }
    pub const fn iseqn(lhs: Reg, rhs: Lit) -> Instruction {
        Instruction::Iseqn { lhs, rhs }
    }
    pub const fn isnen(lhs: Reg, rhs: Lit) -> Instruction {
        Instruction::Isnen { lhs, rhs }
    }
    pub const fn iseqp(lhs: Reg, rhs: Imm8) -> Instruction {
        Instruction::Iseqp { lhs, rhs, _c: 0x7F }
    }
    pub const fn isnep(lhs: Reg, rhs: Imm8) -> Instruction {
        Instruction::Isnep { lhs, rhs, _c: 0x7F }
    }
    pub const fn addvv(dst: Reg, lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Addvv { dst, lhs, rhs }
    }
    pub const fn addvn(dst: Reg, lhs: Reg, rhs: Lit8) -> Instruction {
        Instruction::Addvn { dst, lhs, rhs }
    }
    pub const fn addnv(dst: Reg, lhs: Lit8, rhs: Reg) -> Instruction {
        Instruction::Addnv { dst, lhs, rhs }
    }
    pub const fn subvv(dst: Reg, lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Subvv { dst, lhs, rhs }
    }
    pub const fn subvn(dst: Reg, lhs: Reg, rhs: Lit8) -> Instruction {
        Instruction::Subvn { dst, lhs, rhs }
    }
    pub const fn subnv(dst: Reg, lhs: Lit8, rhs: Reg) -> Instruction {
        Instruction::Subnv { dst, lhs, rhs }
    }
    pub const fn mulvv(dst: Reg, lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Mulvv { dst, lhs, rhs }
    }
    pub const fn mulvn(dst: Reg, lhs: Reg, rhs: Lit8) -> Instruction {
        Instruction::Mulvn { dst, lhs, rhs }
    }
    pub const fn mulnv(dst: Reg, lhs: Lit8, rhs: Reg) -> Instruction {
        Instruction::Mulnv { dst, lhs, rhs }
    }
    pub const fn divvv(dst: Reg, lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Divvv { dst, lhs, rhs }
    }
    pub const fn divvn(dst: Reg, lhs: Reg, rhs: Lit8) -> Instruction {
        Instruction::Divvn { dst, lhs, rhs }
    }
    pub const fn divnv(dst: Reg, lhs: Lit8, rhs: Reg) -> Instruction {
        Instruction::Divnv { dst, lhs, rhs }
    }
    pub const fn unm(dst: Reg, rhs: Reg) -> Instruction {
        Instruction::Unm { dst, rhs, _c: 0x7F }
    }
    pub const fn not(dst: Reg, rhs: Reg) -> Instruction {
        Instruction::Not { dst, rhs, _c: 0x7F }
    }
    pub const fn call(dst: Reg, func: Reg, args: Imm8) -> Instruction {
        Instruction::Call { dst, func, args }
    }
    pub const fn fastcall(dst: Reg, id: FnId) -> Instruction {
        Instruction::Fastcall { dst, id }
    }
    pub const fn ret() -> Instruction {
        Instruction::Ret {
            _a: 0x7F,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
    pub const fn stop() -> Instruction {
        Instruction::Stop {
            _a: 0x7F,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
    pub const fn trap() -> Instruction {
        Instruction::Trap {
            _a: 0x7F,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
}
#[repr(C)]
pub struct JumpTable {
    pub nop: OpaqueOp,
    pub mov: OpaqueOp,
    pub lnil: OpaqueOp,
    pub lsmi: OpaqueOp,
    pub ltrue: OpaqueOp,
    pub lfalse: OpaqueOp,
    pub lint: OpaqueOp,
    pub lnum: OpaqueOp,
    pub lstr: OpaqueOp,
    pub lcli: OpaqueOp,
    pub lfni: OpaqueOp,
    pub larr: OpaqueOp,
    pub lobj: OpaqueOp,
    pub jmp: OpaqueOp,
    pub istrue: OpaqueOp,
    pub istruec: OpaqueOp,
    pub isfalse: OpaqueOp,
    pub isfalsec: OpaqueOp,
    pub islt: OpaqueOp,
    pub isle: OpaqueOp,
    pub isgt: OpaqueOp,
    pub isge: OpaqueOp,
    pub iseq: OpaqueOp,
    pub isne: OpaqueOp,
    pub iseqs: OpaqueOp,
    pub isnes: OpaqueOp,
    pub iseqn: OpaqueOp,
    pub isnen: OpaqueOp,
    pub iseqp: OpaqueOp,
    pub isnep: OpaqueOp,
    pub addvv: OpaqueOp,
    pub addvn: OpaqueOp,
    pub addnv: OpaqueOp,
    pub subvv: OpaqueOp,
    pub subvn: OpaqueOp,
    pub subnv: OpaqueOp,
    pub mulvv: OpaqueOp,
    pub mulvn: OpaqueOp,
    pub mulnv: OpaqueOp,
    pub divvv: OpaqueOp,
    pub divvn: OpaqueOp,
    pub divnv: OpaqueOp,
    pub unm: OpaqueOp,
    pub not: OpaqueOp,
    pub call: OpaqueOp,
    pub fastcall: OpaqueOp,
    pub ret: OpaqueOp,
    pub stop: OpaqueOp,
    pub trap: OpaqueOp,
}

impl JumpTable {
    #[inline]
    pub fn as_ptr(&self) -> Jt {
        let ptr = &raw const self.nop;
        Jt(ptr.cast())
    }
}
