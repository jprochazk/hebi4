// Generated by asmgen at 2025-08-02T13:46:56.577367832+00:00[UTC]
//
// See `asmgen/src/main.rs` and `asmgen/src/runtime.rs`

mod private {
    pub trait Sealed {}
}

use super::{Context, Value};

pub trait OperandPack: private::Sealed + Sized {}

#[repr(transparent)]
pub struct StackPtr(*mut Value);

#[repr(transparent)]
pub struct InstructionPtr(*const u32);

#[repr(transparent)]
pub struct JumpTablePtr(*const OpaqueOp);

#[derive(Debug, Clone, Copy)]
#[repr(u8)]
pub enum Control {
    Yield = 0,
    Error = 1,
}

const _: () = {
    use std::mem::align_of;
    assert!(align_of::<JumpTable>() == align_of::<[OpaqueOp; 1]>());
};

#[repr(transparent)]
pub struct ContextPtr(*mut Context);

#[allow(non_camel_case_types)]
#[derive(Clone, Copy, Hash)]
#[repr(C, packed)]
pub struct u24([u8; 3]);

impl u24 {
    pub const MAX: u24 = u24([255; 3]);
    pub const MIN: u24 = u24([0; 3]);
    pub const ZERO: u24 = u24([0; 3]);

    #[inline]
    pub const fn new(v: u32) -> Self {
        if v > Self::MAX.get() {
            panic!("value is out of bounds for u24");
        }

        unsafe { Self::new_unchecked(v) }
    }

    #[inline]
    pub const unsafe fn new_unchecked(v: u32) -> Self {
        let [a, b, c, _] = v.to_le_bytes();
        Self([a, b, c])
    }

    #[inline]
    pub const fn get(self) -> u32 {
        let [a, b, c] = self.0;
        u32::from_le_bytes([a, b, c, 0])
    }
}

impl PartialEq for u24 {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        PartialEq::eq(&self.get(), &other.get())
    }
}

impl Eq for u24 {}

impl PartialOrd for u24 {
    #[inline]
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        PartialOrd::partial_cmp(&self.get(), &other.get())
    }
}

impl Ord for u24 {
    #[inline]
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        Ord::cmp(&self.get(), &other.get())
    }
}

impl std::fmt::Debug for u24 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        <u32 as std::fmt::Debug>::fmt(&self.get(), f)
    }
}

#[cfg(not(windows))]
macro_rules! Op {
    (
        fn ($($ty:ty),* $(,)?) -> $ret:ty
    ) => {
        unsafe extern "C" fn($($ty),*) -> $ret
    };
}

#[cfg(windows)]
macro_rules! Op {
    (
        fn ($($ty:ty),* $(,)?) -> $ret:ty
    ) => {
        unsafe extern "sysv64" fn($($ty),*) -> $ret
    };
}

#[cfg(not(windows))]
macro_rules! op {
    (
        unsafe extern "?" fn $name:ident($($i:ident : $ty:ty),* $(,)?) -> $ret:ty $body:block
    ) => {
        unsafe extern "C" fn $name($($i:$ty),*) -> $ret $body
    };
}

#[cfg(windows)]
macro_rules! op {
    (
        unsafe extern "?" fn $name:ident($($i:ident : $ty:ty),* $(,)?) -> $ret:ty $body:block
    ) => {
        unsafe extern "sysv64" fn $name($($i:$ty),*) -> $ret $body
    };
}

pub type Op<Operands> =
    Op!(fn(Operands, JumpTablePtr, StackPtr, InstructionPtr, ContextPtr) -> Control);

#[repr(transparent)]
pub struct Operands(u32);

pub type OpaqueOp =
    Op!(fn(Operands, JumpTablePtr, StackPtr, InstructionPtr, ContextPtr) -> Control);

macro_rules! declare_operand_type {
    ($name:ident, $ty:ident) => {
        #[derive(Clone, Copy)]
        #[repr(transparent)]
        pub struct $name($ty);

        impl $name {
            #[inline(always)]
            pub fn get(self) -> $ty {
                self.0
            }

            #[inline(always)]
            pub fn new(v: $ty) -> Self {
                Self(v)
            }
        }
    };
    ($name:ident, $ty:ident, $zx_ty:ident) => {
        declare_operand_type!($name, $ty);

        impl $name {
            #[inline(always)]
            pub fn zx(self) -> $zx_ty {
                self.0 as $zx_ty
            }
        }
    };
}

macro_rules! declare_operand_types {
    (
        $(
            $name:ident( $ty:ident $(as $zx_ty:ident)? )
        ),* $(,)?
    ) => {
        $(
            declare_operand_type!($name, $ty $(, $zx_ty)?);
        )*
    };
}

declare_operand_types! {
    Reg(u8 as usize),

    Lit(u16 as usize),
    Lit8(u8 as usize),

    Imm8(u8 as usize),
    Imm16(i16),
    Imm24(u24),
}

const fn assert_bit_equal<A, B>(a: &A, b: &B) {
    let a: [u32; 1] = unsafe { (a as *const A as *const [u32; 1]).read() };
    let b: [u32; 1] = unsafe { (b as *const B as *const [u32; 1]).read() };
    if a[0] != b[0] {
        panic!("not bit equal");
    }
}

// ...

#[derive(Clone, Copy)]
#[repr(u8, align(4))]
pub enum Instruction {
    Nop { _a: u8, _b: u8, _c: u8 } = 0,
    Mov { dst: Reg, src: Reg, _c: u8 } = 1,
    Lnil { dst: Reg, _b: u8, _c: u8 } = 2,
    Lsmi { dst: Reg, v: Imm16 } = 3,
    Ltrue { dst: Reg, _b: u8, _c: u8 } = 4,
    Lfalse { dst: Reg, _b: u8, _c: u8 } = 5,
    Lint { dst: Reg, id: Lit } = 6,
    Lnum { dst: Reg, id: Lit } = 7,
    Lstr { dst: Reg, id: Lit } = 8,
    Lcli { dst: Reg, id: Lit } = 9,
    Lfni { dst: Reg, id: Lit } = 10,
    Larr { dst: Reg, len: Imm8, _c: u8 } = 11,
    Lobj { dst: Reg, len: Imm8, _c: u8 } = 12,
    Jmp { rel: Imm24 } = 13,
    Istrue { v: Reg, _b: u8, _c: u8 } = 14,
    Istruec { dst: Reg, v: Reg, _c: u8 } = 15,
    Isfalse { v: Reg, _b: u8, _c: u8 } = 16,
    Isfalsec { dst: Reg, v: Reg, _c: u8 } = 17,
    Islt { lhs: Reg, rhs: Reg, _c: u8 } = 18,
    Isle { lhs: Reg, rhs: Reg, _c: u8 } = 19,
    Isgt { lhs: Reg, rhs: Reg, _c: u8 } = 20,
    Isge { lhs: Reg, rhs: Reg, _c: u8 } = 21,
    Iseq { lhs: Reg, rhs: Reg, _c: u8 } = 22,
    Isne { lhs: Reg, rhs: Reg, _c: u8 } = 23,
    Iseqs { lhs: Reg, rhs: Lit } = 24,
    Isnes { lhs: Reg, rhs: Lit } = 25,
    Iseqn { lhs: Reg, rhs: Lit } = 26,
    Isnen { lhs: Reg, rhs: Lit } = 27,
    Iseqp { lhs: Reg, rhs: Imm8, _c: u8 } = 28,
    Isnep { lhs: Reg, rhs: Imm8, _c: u8 } = 29,
    Addvv { dst: Reg, lhs: Reg, rhs: Reg } = 30,
    Addvn { dst: Reg, lhs: Reg, rhs: Lit8 } = 31,
    Addnv { dst: Reg, lhs: Lit8, rhs: Reg } = 32,
    Subvv { dst: Reg, lhs: Reg, rhs: Reg } = 33,
    Subvn { dst: Reg, lhs: Reg, rhs: Lit8 } = 34,
    Subnv { dst: Reg, lhs: Lit8, rhs: Reg } = 35,
    Mulvv { dst: Reg, lhs: Reg, rhs: Reg } = 36,
    Mulvn { dst: Reg, lhs: Reg, rhs: Lit8 } = 37,
    Mulnv { dst: Reg, lhs: Lit8, rhs: Reg } = 38,
    Divvv { dst: Reg, lhs: Reg, rhs: Reg } = 39,
    Divvn { dst: Reg, lhs: Reg, rhs: Lit8 } = 40,
    Divnv { dst: Reg, lhs: Lit8, rhs: Reg } = 41,
    Unm { dst: Reg, rhs: Reg, _c: u8 } = 42,
    Not { dst: Reg, rhs: Reg, _c: u8 } = 43,
    Call { dst: Reg, func: Reg, args: Imm8 } = 44,
    Fastcall { dst: Reg, id: Lit } = 45,
    Ret { _a: u8, _b: u8, _c: u8 } = 46,
}

// assert compatibility with `u32`
const _: () = assert!(std::mem::size_of::<Instruction>() == std::mem::size_of::<u32>());
const _: () = assert!(std::mem::align_of::<Instruction>() == std::mem::align_of::<u32>());

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Nop {
    _op: u8,
    _a: u8,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Nop>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Nop>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Nop {
        _op: 0,
        _a: 0x7A,
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Nop {
        _a: 0x7A,
        _b: 0x7B,
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Mov {
    _op: u8,
    pub dst: Reg,
    pub src: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Mov>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Mov>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Mov {
        _op: 1,
        dst: Reg(0x7A),
        src: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Mov {
        dst: Reg(0x7A),
        src: Reg(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lnil {
    _op: u8,
    pub dst: Reg,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Lnil>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lnil>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lnil {
        _op: 2,
        dst: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Lnil {
        dst: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lsmi {
    _op: u8,
    pub dst: Reg,
    pub v: Imm16,
}

const _: () = assert!(std::mem::size_of::<Lsmi>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lsmi>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lsmi {
        _op: 3,
        dst: Reg(0x7A),
        v: Imm16(0x7B7C),
    },
    &Instruction::Lsmi {
        dst: Reg(0x7A),
        v: Imm16(0x7B7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Ltrue {
    _op: u8,
    pub dst: Reg,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Ltrue>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Ltrue>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Ltrue {
        _op: 4,
        dst: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Ltrue {
        dst: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lfalse {
    _op: u8,
    pub dst: Reg,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Lfalse>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lfalse>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lfalse {
        _op: 5,
        dst: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Lfalse {
        dst: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lint {
    _op: u8,
    pub dst: Reg,
    pub id: Lit,
}

const _: () = assert!(std::mem::size_of::<Lint>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lint>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lint {
        _op: 6,
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
    &Instruction::Lint {
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lnum {
    _op: u8,
    pub dst: Reg,
    pub id: Lit,
}

const _: () = assert!(std::mem::size_of::<Lnum>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lnum>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lnum {
        _op: 7,
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
    &Instruction::Lnum {
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lstr {
    _op: u8,
    pub dst: Reg,
    pub id: Lit,
}

const _: () = assert!(std::mem::size_of::<Lstr>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lstr>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lstr {
        _op: 8,
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
    &Instruction::Lstr {
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lcli {
    _op: u8,
    pub dst: Reg,
    pub id: Lit,
}

const _: () = assert!(std::mem::size_of::<Lcli>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lcli>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lcli {
        _op: 9,
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
    &Instruction::Lcli {
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lfni {
    _op: u8,
    pub dst: Reg,
    pub id: Lit,
}

const _: () = assert!(std::mem::size_of::<Lfni>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lfni>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lfni {
        _op: 10,
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
    &Instruction::Lfni {
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Larr {
    _op: u8,
    pub dst: Reg,
    pub len: Imm8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Larr>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Larr>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Larr {
        _op: 11,
        dst: Reg(0x7A),
        len: Imm8(0x7B),
        _c: 0x7C,
    },
    &Instruction::Larr {
        dst: Reg(0x7A),
        len: Imm8(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Lobj {
    _op: u8,
    pub dst: Reg,
    pub len: Imm8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Lobj>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Lobj>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Lobj {
        _op: 12,
        dst: Reg(0x7A),
        len: Imm8(0x7B),
        _c: 0x7C,
    },
    &Instruction::Lobj {
        dst: Reg(0x7A),
        len: Imm8(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Jmp {
    _op: u8,
    pub rel: Imm24,
}

const _: () = assert!(std::mem::size_of::<Jmp>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Jmp>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Jmp {
        _op: 13,
        rel: Imm24(u24::new(0x7A7B7C)),
    },
    &Instruction::Jmp {
        rel: Imm24(u24::new(0x7A7B7C)),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Istrue {
    _op: u8,
    pub v: Reg,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Istrue>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Istrue>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Istrue {
        _op: 14,
        v: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Istrue {
        v: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Istruec {
    _op: u8,
    pub dst: Reg,
    pub v: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Istruec>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Istruec>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Istruec {
        _op: 15,
        dst: Reg(0x7A),
        v: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Istruec {
        dst: Reg(0x7A),
        v: Reg(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isfalse {
    _op: u8,
    pub v: Reg,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Isfalse>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isfalse>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isfalse {
        _op: 16,
        v: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Isfalse {
        v: Reg(0x7A),
        _b: 0x7B,
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isfalsec {
    _op: u8,
    pub dst: Reg,
    pub v: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Isfalsec>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isfalsec>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isfalsec {
        _op: 17,
        dst: Reg(0x7A),
        v: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Isfalsec {
        dst: Reg(0x7A),
        v: Reg(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Islt {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Islt>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Islt>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Islt {
        _op: 18,
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Islt {
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isle {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Isle>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isle>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isle {
        _op: 19,
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Isle {
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isgt {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Isgt>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isgt>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isgt {
        _op: 20,
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Isgt {
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isge {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Isge>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isge>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isge {
        _op: 21,
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Isge {
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Iseq {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Iseq>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Iseq>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Iseq {
        _op: 22,
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Iseq {
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isne {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Isne>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isne>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isne {
        _op: 23,
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Isne {
        lhs: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Iseqs {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Lit,
}

const _: () = assert!(std::mem::size_of::<Iseqs>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Iseqs>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Iseqs {
        _op: 24,
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
    &Instruction::Iseqs {
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isnes {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Lit,
}

const _: () = assert!(std::mem::size_of::<Isnes>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isnes>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isnes {
        _op: 25,
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
    &Instruction::Isnes {
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Iseqn {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Lit,
}

const _: () = assert!(std::mem::size_of::<Iseqn>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Iseqn>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Iseqn {
        _op: 26,
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
    &Instruction::Iseqn {
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isnen {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Lit,
}

const _: () = assert!(std::mem::size_of::<Isnen>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isnen>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isnen {
        _op: 27,
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
    &Instruction::Isnen {
        lhs: Reg(0x7A),
        rhs: Lit(0x7B7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Iseqp {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Imm8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Iseqp>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Iseqp>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Iseqp {
        _op: 28,
        lhs: Reg(0x7A),
        rhs: Imm8(0x7B),
        _c: 0x7C,
    },
    &Instruction::Iseqp {
        lhs: Reg(0x7A),
        rhs: Imm8(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Isnep {
    _op: u8,
    pub lhs: Reg,
    pub rhs: Imm8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Isnep>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Isnep>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Isnep {
        _op: 29,
        lhs: Reg(0x7A),
        rhs: Imm8(0x7B),
        _c: 0x7C,
    },
    &Instruction::Isnep {
        lhs: Reg(0x7A),
        rhs: Imm8(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Addvv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Addvv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Addvv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Addvv {
        _op: 30,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Addvv {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Addvn {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Lit8,
}

const _: () = assert!(std::mem::size_of::<Addvn>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Addvn>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Addvn {
        _op: 31,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
    &Instruction::Addvn {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Addnv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Lit8,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Addnv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Addnv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Addnv {
        _op: 32,
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Addnv {
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Subvv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Subvv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Subvv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Subvv {
        _op: 33,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Subvv {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Subvn {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Lit8,
}

const _: () = assert!(std::mem::size_of::<Subvn>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Subvn>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Subvn {
        _op: 34,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
    &Instruction::Subvn {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Subnv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Lit8,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Subnv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Subnv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Subnv {
        _op: 35,
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Subnv {
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Mulvv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Mulvv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Mulvv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Mulvv {
        _op: 36,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Mulvv {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Mulvn {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Lit8,
}

const _: () = assert!(std::mem::size_of::<Mulvn>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Mulvn>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Mulvn {
        _op: 37,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
    &Instruction::Mulvn {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Mulnv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Lit8,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Mulnv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Mulnv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Mulnv {
        _op: 38,
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Mulnv {
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Divvv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Divvv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Divvv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Divvv {
        _op: 39,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Divvv {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Reg(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Divvn {
    _op: u8,
    pub dst: Reg,
    pub lhs: Reg,
    pub rhs: Lit8,
}

const _: () = assert!(std::mem::size_of::<Divvn>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Divvn>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Divvn {
        _op: 40,
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
    &Instruction::Divvn {
        dst: Reg(0x7A),
        lhs: Reg(0x7B),
        rhs: Lit8(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Divnv {
    _op: u8,
    pub dst: Reg,
    pub lhs: Lit8,
    pub rhs: Reg,
}

const _: () = assert!(std::mem::size_of::<Divnv>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Divnv>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Divnv {
        _op: 41,
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
    &Instruction::Divnv {
        dst: Reg(0x7A),
        lhs: Lit8(0x7B),
        rhs: Reg(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Unm {
    _op: u8,
    pub dst: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Unm>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Unm>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Unm {
        _op: 42,
        dst: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Unm {
        dst: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Not {
    _op: u8,
    pub dst: Reg,
    pub rhs: Reg,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Not>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Not>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Not {
        _op: 43,
        dst: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
    &Instruction::Not {
        dst: Reg(0x7A),
        rhs: Reg(0x7B),
        _c: 0x7C,
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Call {
    _op: u8,
    pub dst: Reg,
    pub func: Reg,
    pub args: Imm8,
}

const _: () = assert!(std::mem::size_of::<Call>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Call>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Call {
        _op: 44,
        dst: Reg(0x7A),
        func: Reg(0x7B),
        args: Imm8(0x7C),
    },
    &Instruction::Call {
        dst: Reg(0x7A),
        func: Reg(0x7B),
        args: Imm8(0x7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Fastcall {
    _op: u8,
    pub dst: Reg,
    pub id: Lit,
}

const _: () = assert!(std::mem::size_of::<Fastcall>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Fastcall>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Fastcall {
        _op: 45,
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
    &Instruction::Fastcall {
        dst: Reg(0x7A),
        id: Lit(0x7B7C),
    },
);

#[derive(Clone, Copy)]
#[repr(C, align(4))]
pub struct Ret {
    _op: u8,
    _a: u8,
    _b: u8,
    _c: u8,
}

const _: () = assert!(std::mem::size_of::<Ret>() == std::mem::size_of::<Instruction>());
const _: () = assert!(std::mem::align_of::<Ret>() == std::mem::align_of::<Instruction>());
const _: () = assert_bit_equal(
    &Ret {
        _op: 46,
        _a: 0x7A,
        _b: 0x7B,
        _c: 0x7C,
    },
    &Instruction::Ret {
        _a: 0x7A,
        _b: 0x7B,
        _c: 0x7C,
    },
);

pub mod asm {
    use super::*;
    pub fn nop() -> Instruction {
        Instruction::Nop {
            _a: 0x7F,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
    pub fn mov(dst: Reg, src: Reg) -> Instruction {
        Instruction::Mov { dst, src, _c: 0x7F }
    }
    pub fn lnil(dst: Reg) -> Instruction {
        Instruction::Lnil {
            dst,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
    pub fn lsmi(dst: Reg, v: Imm16) -> Instruction {
        Instruction::Lsmi { dst, v }
    }
    pub fn ltrue(dst: Reg) -> Instruction {
        Instruction::Ltrue {
            dst,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
    pub fn lfalse(dst: Reg) -> Instruction {
        Instruction::Lfalse {
            dst,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
    pub fn lint(dst: Reg, id: Lit) -> Instruction {
        Instruction::Lint { dst, id }
    }
    pub fn lnum(dst: Reg, id: Lit) -> Instruction {
        Instruction::Lnum { dst, id }
    }
    pub fn lstr(dst: Reg, id: Lit) -> Instruction {
        Instruction::Lstr { dst, id }
    }
    pub fn lcli(dst: Reg, id: Lit) -> Instruction {
        Instruction::Lcli { dst, id }
    }
    pub fn lfni(dst: Reg, id: Lit) -> Instruction {
        Instruction::Lfni { dst, id }
    }
    pub fn larr(dst: Reg, len: Imm8) -> Instruction {
        Instruction::Larr { dst, len, _c: 0x7F }
    }
    pub fn lobj(dst: Reg, len: Imm8) -> Instruction {
        Instruction::Lobj { dst, len, _c: 0x7F }
    }
    pub fn jmp(rel: Imm24) -> Instruction {
        Instruction::Jmp { rel }
    }
    pub fn istrue(v: Reg) -> Instruction {
        Instruction::Istrue {
            v,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
    pub fn istruec(dst: Reg, v: Reg) -> Instruction {
        Instruction::Istruec { dst, v, _c: 0x7F }
    }
    pub fn isfalse(v: Reg) -> Instruction {
        Instruction::Isfalse {
            v,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
    pub fn isfalsec(dst: Reg, v: Reg) -> Instruction {
        Instruction::Isfalsec { dst, v, _c: 0x7F }
    }
    pub fn islt(lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Islt { lhs, rhs, _c: 0x7F }
    }
    pub fn isle(lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Isle { lhs, rhs, _c: 0x7F }
    }
    pub fn isgt(lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Isgt { lhs, rhs, _c: 0x7F }
    }
    pub fn isge(lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Isge { lhs, rhs, _c: 0x7F }
    }
    pub fn iseq(lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Iseq { lhs, rhs, _c: 0x7F }
    }
    pub fn isne(lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Isne { lhs, rhs, _c: 0x7F }
    }
    pub fn iseqs(lhs: Reg, rhs: Lit) -> Instruction {
        Instruction::Iseqs { lhs, rhs }
    }
    pub fn isnes(lhs: Reg, rhs: Lit) -> Instruction {
        Instruction::Isnes { lhs, rhs }
    }
    pub fn iseqn(lhs: Reg, rhs: Lit) -> Instruction {
        Instruction::Iseqn { lhs, rhs }
    }
    pub fn isnen(lhs: Reg, rhs: Lit) -> Instruction {
        Instruction::Isnen { lhs, rhs }
    }
    pub fn iseqp(lhs: Reg, rhs: Imm8) -> Instruction {
        Instruction::Iseqp { lhs, rhs, _c: 0x7F }
    }
    pub fn isnep(lhs: Reg, rhs: Imm8) -> Instruction {
        Instruction::Isnep { lhs, rhs, _c: 0x7F }
    }
    pub fn addvv(dst: Reg, lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Addvv { dst, lhs, rhs }
    }
    pub fn addvn(dst: Reg, lhs: Reg, rhs: Lit8) -> Instruction {
        Instruction::Addvn { dst, lhs, rhs }
    }
    pub fn addnv(dst: Reg, lhs: Lit8, rhs: Reg) -> Instruction {
        Instruction::Addnv { dst, lhs, rhs }
    }
    pub fn subvv(dst: Reg, lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Subvv { dst, lhs, rhs }
    }
    pub fn subvn(dst: Reg, lhs: Reg, rhs: Lit8) -> Instruction {
        Instruction::Subvn { dst, lhs, rhs }
    }
    pub fn subnv(dst: Reg, lhs: Lit8, rhs: Reg) -> Instruction {
        Instruction::Subnv { dst, lhs, rhs }
    }
    pub fn mulvv(dst: Reg, lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Mulvv { dst, lhs, rhs }
    }
    pub fn mulvn(dst: Reg, lhs: Reg, rhs: Lit8) -> Instruction {
        Instruction::Mulvn { dst, lhs, rhs }
    }
    pub fn mulnv(dst: Reg, lhs: Lit8, rhs: Reg) -> Instruction {
        Instruction::Mulnv { dst, lhs, rhs }
    }
    pub fn divvv(dst: Reg, lhs: Reg, rhs: Reg) -> Instruction {
        Instruction::Divvv { dst, lhs, rhs }
    }
    pub fn divvn(dst: Reg, lhs: Reg, rhs: Lit8) -> Instruction {
        Instruction::Divvn { dst, lhs, rhs }
    }
    pub fn divnv(dst: Reg, lhs: Lit8, rhs: Reg) -> Instruction {
        Instruction::Divnv { dst, lhs, rhs }
    }
    pub fn unm(dst: Reg, rhs: Reg) -> Instruction {
        Instruction::Unm { dst, rhs, _c: 0x7F }
    }
    pub fn not(dst: Reg, rhs: Reg) -> Instruction {
        Instruction::Not { dst, rhs, _c: 0x7F }
    }
    pub fn call(dst: Reg, func: Reg, args: Imm8) -> Instruction {
        Instruction::Call { dst, func, args }
    }
    pub fn fastcall(dst: Reg, id: Lit) -> Instruction {
        Instruction::Fastcall { dst, id }
    }
    pub fn ret() -> Instruction {
        Instruction::Ret {
            _a: 0x7F,
            _b: 0x7F,
            _c: 0x7F,
        }
    }
}
#[repr(C)]
pub struct JumpTable {
    pub nop: Op<Nop>,
    pub mov: Op<Mov>,
    pub lnil: Op<Lnil>,
    pub lsmi: Op<Lsmi>,
    pub ltrue: Op<Ltrue>,
    pub lfalse: Op<Lfalse>,
    pub lint: Op<Lint>,
    pub lnum: Op<Lnum>,
    pub lstr: Op<Lstr>,
    pub lcli: Op<Lcli>,
    pub lfni: Op<Lfni>,
    pub larr: Op<Larr>,
    pub lobj: Op<Lobj>,
    pub jmp: Op<Jmp>,
    pub istrue: Op<Istrue>,
    pub istruec: Op<Istruec>,
    pub isfalse: Op<Isfalse>,
    pub isfalsec: Op<Isfalsec>,
    pub islt: Op<Islt>,
    pub isle: Op<Isle>,
    pub isgt: Op<Isgt>,
    pub isge: Op<Isge>,
    pub iseq: Op<Iseq>,
    pub isne: Op<Isne>,
    pub iseqs: Op<Iseqs>,
    pub isnes: Op<Isnes>,
    pub iseqn: Op<Iseqn>,
    pub isnen: Op<Isnen>,
    pub iseqp: Op<Iseqp>,
    pub isnep: Op<Isnep>,
    pub addvv: Op<Addvv>,
    pub addvn: Op<Addvn>,
    pub addnv: Op<Addnv>,
    pub subvv: Op<Subvv>,
    pub subvn: Op<Subvn>,
    pub subnv: Op<Subnv>,
    pub mulvv: Op<Mulvv>,
    pub mulvn: Op<Mulvn>,
    pub mulnv: Op<Mulnv>,
    pub divvv: Op<Divvv>,
    pub divvn: Op<Divvn>,
    pub divnv: Op<Divnv>,
    pub unm: Op<Unm>,
    pub not: Op<Not>,
    pub call: Op<Call>,
    pub fastcall: Op<Fastcall>,
    pub ret: Op<Ret>,
}

impl JumpTable {
    #[inline]
    fn as_ptr(&self) -> JumpTablePtr {
        let ptr = &raw const self.nop;
        JumpTablePtr(ptr.cast())
    }
}
