//! Hebi code generator.
//!
//! [`emit`] is the entrypoint.
//!
//! Hebi is a dynamically-typed, interpreted language. Its virtual machine
//! executes fixed-width register-based bytecode. This module generates
//! that bytecode.
//!
//! Note the use of `unsafe` for constructing operands: the VM trusts that
//! the output of the code generator is _correct_, and that is the point
//! from which that trust originates.
//!
//! ## Instruction set
//!
//! The bytecode is fixed-width, meaning each instruction is exactly 4 bytes.
//! Most instructions use most of that space, but being maximally space-efficient
//! is not a goal of Hebi's instruction set.
//!
//! The instruction set in question is generated by `/asmgen` from `/src/codegen/opcodes.s`.
//!
//! ## Register allocation
//!
//! Register allocation is very simple: Whenever a register is needed,
//! allocate one by incrementing a number, then free it by decrementing
//! as soon the register is no longer required.
//! Registers can be long-lived if used by variables, or short-lived if
//! used by sub-expressions.
//!
//! ## Constant folding
//!
//! The code generator performs basic constant folding, modelled like a
//! partial tree-walking interpreter, centered around the [`Value`] type.
//!
//! Values are either:
//!
//! - A constant value (present in the source code verbatim), or
//! - A runtime-known value, which must be _materialized_ into a register
//!   if it is to be used.
//!
//! We want instructions to be able to use registers directly as much as possible,
//! to avoid allocating too many registers.
//!
//! - `eval` methods return `Value`s, and may emit some bytecode.
//! - `emit` methods only emit bytecode.
//!
//! If an `eval` returns a runtime-known value, then it expects the caller to use
//! the provided register when emitting its bytecode. For example, evaluating:
//!
//! ```text,ignore
//! var result = 0
//! var a = 1
//! result = a + 2
//! ```
//!
//! The "maximalist" version of the bytecode required to evaluate
//! that snippet of code would look something like:
//!
//! ```text,ignore
//! lint r1, l0  ; l0=0
//! lint r2, l1  ; l1=1
//! mov r4, r2
//! lint r5, l2  ; l2=2
//! add r3, r4, r5
//! mov r3, r1
//! lnil r0
//! ret
//! ```
//!
//! That's not great. We're using:
//! - 8 instructions
//! - 3 literal pool entries, and
//! - 6 registers!
//!
//! What the compiler actually emits today:
//!
//! ```text,ignore
//! lsmi r1, 0
//! lsmi r2, 1
//! add r1, r2, 2
//! lnil r0
//! ret
//! ```
//!
//! - The variables are initialized to *sm*all *i*nteger (`smi`) values
//!   of `0` and `1` embedded directly as an operand in `lsmi`
//! - A single `add` is emitted, which:
//!   - Writes directly to `result`'s register
//!   - Uses `a`'s register as the lhs
//!   - Uses a literal pool entry as the rhs
//!
//! The tally is:
//! - 5 instructions,
//! - 1 literal pool entry,
//! - 3 registers
//!
//! We can't easily get rid of `r0`, it's there to guarantee all functions
//! return _something_.
//!
//! ## Modules
//!
//! The result of code generation is a [`Module`], which is:
//! - A list of functions, each with a unique stable ID ([`FnId`]), and
//! - The ID of the main function.
//!
//! The VM begins execution by dispatching the module's main entrypoint.
//!

#[macro_use]
pub(crate) mod opcodes;

use beef::lean::Cow;
use bumpalo::{Bump, collections::Vec, vec};
use hashbrown::{HashMap, HashSet};
use opcodes::{FnId, Imm8, Imm16, Imm16s, Imm24s, Insn, Lit, Lit8, Opcode, Reg, asm, i24};
use rustc_hash::FxBuildHasher;

use crate::{
    ast::{self, Ast, Ident, Node, NodeList, Stmt, f64n},
    codegen::opcodes::{HostId, Mvar, Uv},
    core::CoreLib,
    error::{Result, error_span},
    module::{
        self, ClosureInfo, FuncDebugInfo, FuncInfo, ImportBinding, ImportInfo, Literal, Local,
        Module, UpvalueDescriptor,
    },
    span::Span,
    vm::{Control, VmState, value::ValueRaw},
};

macro_rules! f {
    (&$m:expr) => {
        unsafe {
            debug_assert!(!($m).func_stack.is_empty());
            ($m).func_stack.last().unwrap_unchecked()
        }
    };

    ($m:expr) => {
        unsafe {
            debug_assert!(!($m).func_stack.is_empty());
            ($m).func_stack.last_mut().unwrap_unchecked()
        }
    };
}

const NO_SPAN: Span = Span::empty();

#[derive(Clone)]
pub struct EmitOptions {
    pub dead_code_elimination: bool,
}

impl EmitOptions {
    pub fn empty() -> Self {
        Self {
            dead_code_elimination: false,
        }
    }
}

impl Default for EmitOptions {
    fn default() -> Self {
        Self {
            dead_code_elimination: true,
        }
    }
}

pub fn emit(name: Cow<'static, str>, ast: &Ast, options: EmitOptions) -> Result<Module> {
    let buf = &Bump::new();
    let mut m = State {
        options,
        buf,
        func_stack: vec![in buf],
        func_table: FunctionTable::new(buf),
        module_vars: vec![in buf],
    };

    // note: `main` cannot be called, so does not need a symbol
    let main = m
        .func_table
        .reserve("@main", Span::empty())
        .expect("should not fail to reserve main");
    assert!(main.get() == 0);

    let f = emit_func(
        &mut m,
        main,
        "@main".into(),
        Span::empty(),
        NodeList::empty(ast),
        &[],
        ast.root().body(),
    )?;

    m.func_table.define(main, f);

    Ok(Module::new(
        name,
        main,
        m.func_table.finish(),
        m.module_vars.len(),
    ))
}

struct State<'a> {
    options: EmitOptions,

    buf: &'a Bump,
    func_stack: Vec<'a, FunctionState<'a>>,
    func_table: FunctionTable<'a>,
    module_vars: Vec<'a, ModuleVar<'a>>,
}

#[derive(Clone)]
struct ModuleVar<'a> {
    name: &'a str,
    span: Span,
    id: Mvar,
}

struct FunctionTable<'a> {
    entries: Vec<'a, FunctionTableEntry<'a>>,
}

enum FunctionTableEntry<'a> {
    Occupied(FuncInfo),
    Reserved(Cow<'a, str>, Span),
}

impl<'a> FunctionTable<'a> {
    fn new(buf: &'a Bump) -> Self {
        Self {
            entries: vec![in buf],
        }
    }

    fn reserve(&mut self, name: impl Into<Cow<'a, str>>, span: Span) -> Result<FnId> {
        let id = self.entries.len();
        if id >= u16::MAX as usize {
            return error_span(format!("too many functions, maximum is {}", u16::MAX), span).into();
        }
        let id = id as u16;

        self.entries
            .push(FunctionTableEntry::Reserved(name.into(), span));
        Ok(unsafe { FnId::new_unchecked(id) })
    }

    fn define(&mut self, id: FnId, info: FuncInfo) {
        use FunctionTableEntry as E;

        match self.entries.get_mut(id.zx()) {
            Some(E::Occupied(..)) => panic!("ICE: function defined twice"),
            Some(E::Reserved(name, span)) => {
                assert!(
                    info.name() == name,
                    "ICE: function definition mismatch: expected {name:?} for fn id {id}, got {:?}\n\
                    NOTE: function was declared at {span}",
                    info.name()
                );
            }
            None => {
                panic!("ICE: function finished before declaration");
            }
        }

        self.entries[id.zx()] = E::Occupied(info);
    }

    fn finish(self) -> Vec<'a, FuncInfo> {
        let mut out = Vec::with_capacity_in(self.entries.len(), self.entries.bump());
        for entry in self.entries {
            use FunctionTableEntry as E;
            match entry {
                E::Occupied(func_info) => out.push(func_info),
                E::Reserved(name, span) => {
                    panic!("ICE: function declared but not defined: {name:?} at {span}");
                }
            }
        }
        out
    }
}

struct FunctionState<'a> {
    options: EmitOptions,

    name: Cow<'a, str>,
    scopes: Vec<'a, Scope<'a>>,
    ra: RegAlloc,
    code: Vec<'a, Insn>,
    literals: Literals<'a>,
    loop_: Option<Loop<'a>>,

    top_level: bool,
    upvalues: Vec<'a, Upvalue<'a>>,

    /// Tracking basic block boundaries
    in_block: bool,

    dbg: FunctionDebug<'a>,
}

struct Upvalue<'a> {
    name: Cow<'a, str>,
    span: Span,
    info: UpvalueDescriptor,
}

struct Scope<'a> {
    reg_scope: RegScope,
    variables: Vec<'a, Variable<'a>>,
    undefined_functions: Vec<'a, FnId>,
}

impl<'a> Scope<'a> {
    fn push(&mut self, var: Variable<'a>) {
        self.variables.push(var)
    }
}

enum Variable<'a> {
    Local {
        name: Cow<'a, str>,
        span: Span,
        reg: Reg,
    },
    Function {
        name: Cow<'a, str>,
        arity: u8,
        span: Span,
        id: FnId,
    },
}

impl<'a> Variable<'a> {
    fn name(&self) -> &str {
        match self {
            Variable::Local { name, span, reg } => name,
            Variable::Function {
                name,
                arity,
                span,
                id,
            } => name,
        }
    }

    fn symbol(&self) -> Symbol {
        match self {
            Variable::Local { name, span, reg } => Symbol::Local {
                span: *span,
                reg: *reg,
            },
            Variable::Function {
                name,
                arity,
                span,
                id,
            } => Symbol::Function {
                arity: *arity,
                span: *span,
                id: *id,
            },
        }
    }
}

struct FunctionDebug<'a> {
    spans: Vec<'a, Span>,
    locals: Vec<'a, Local>,
    upvalues: Vec<'a, module::Upvalue>,
}

struct RegAlloc {
    scope_start: u8,
    vars_in_scope: u8,
    next: u8,
    max_size: u8,
}

impl RegAlloc {
    fn new() -> Self {
        Self {
            scope_start: 0,
            vars_in_scope: 0,
            next: 0,
            max_size: 0,
        }
    }

    fn alloc(&mut self, span: Span) -> Result<Reg> {
        if self.next == u8::MAX {
            return error_span("too many registers", span).into();
        }

        let r = unsafe { Reg::new_unchecked(self.next) };

        self.next += 1;
        if self.next > self.max_size {
            self.max_size = self.next;
        }

        Ok(r)
    }

    fn alloc_var(&mut self, span: Span) -> Result<Reg> {
        let r = self.alloc(span)?;
        self.vars_in_scope += 1;
        Ok(r)
    }

    fn alloc_n(&mut self, span: Span, n: u8) -> Result<RegRange> {
        if n == 0 {
            return Ok(RegRange::empty());
        }

        if self.next as usize + n as usize >= u8::MAX as usize {
            return error_span("too many registers", span).into();
        }

        let start = unsafe { Reg::new_unchecked(self.next) };

        self.next += n;
        if self.next > self.max_size {
            self.max_size = self.next;
        }

        Ok(RegRange { start, n })
    }

    fn is_at_top(&self, r: Reg) -> bool {
        self.next == r.get() + 1
    }

    fn free(&mut self, r: Reg) {
        // Do not free variables.
        if r.get() < self.scope_start + self.vars_in_scope {
            return;
        }

        if self.next != r.get() + 1 {
            unreachable!(
                "ICE: registers freed out of order (next={}, r={}, scope_start={})",
                self.next,
                r.get(),
                self.scope_start
            );
        }
        self.next = r.get();
    }

    fn free_n(&mut self, range: RegRange) {
        // ignore empty ranges
        if range.n == 0 {
            return;
        }

        if self.next != range.end().get() + 1 {
            unreachable!(
                "ICE: registers freed out of order ({range:?}, next={next})",
                next = self.next,
            );
        }
        self.next = range.start.get();
    }

    #[cfg_attr(debug_assertions, track_caller)]
    fn begin_scope(&mut self) -> RegScope {
        let snapshot = RegScope {
            prev_scope_start: self.scope_start,
            prev_scope_next: self.next,
            prev_scope_nvars: self.vars_in_scope,
        };
        self.scope_start = self.next;
        self.vars_in_scope = 0;

        #[cfg(debug_assertions)]
        if option_env!("PRINT_REGALLOC").is_some() {
            eprintln!("new reg scope {snapshot:?}");
        }

        snapshot
    }

    #[cfg_attr(debug_assertions, track_caller)]
    fn end_scope(&mut self, snapshot: RegScope) {
        self.scope_start = snapshot.prev_scope_start;
        self.next = snapshot.prev_scope_next;
        self.vars_in_scope = snapshot.prev_scope_nvars;

        #[cfg(debug_assertions)]
        if option_env!("PRINT_REGALLOC").is_some() {
            eprintln!("end reg scope {snapshot:?}");
        }
    }
}

#[derive(Debug)]
struct RegScope {
    prev_scope_start: u8,
    prev_scope_next: u8,
    prev_scope_nvars: u8,
}

#[derive(Debug, Clone, Copy)]
struct RegRange {
    start: Reg,
    n: u8,
}

impl RegRange {
    fn empty() -> Self {
        Self { start: R0, n: 0 }
    }

    fn end(&self) -> Reg {
        if self.n == 0 {
            return R0;
        }

        unsafe { Reg::new_unchecked(self.start.get() + self.n - 1) }
    }
}

struct RegRangeIter {
    start: u8,
    end: u8,
    n: u8,
}

impl IntoIterator for RegRange {
    type Item = Reg;

    type IntoIter = RegRangeIter;

    fn into_iter(self) -> Self::IntoIter {
        RegRangeIter {
            start: self.start.get(),
            end: self.start.get() + self.n,
            n: self.n,
        }
    }
}

impl Iterator for RegRangeIter {
    type Item = Reg;

    fn next(&mut self) -> Option<Self::Item> {
        if self.n == 0 {
            return None;
        }

        let n = self.n;
        self.n -= 1;

        Some(unsafe { Reg::new_unchecked(self.end - n) })
    }
}

#[derive(Debug)]
struct ReservedRegRange {
    span: Span,
    start: Reg,
    n: u8,
    next: u8,
}

impl ReservedRegRange {
    fn empty() -> Self {
        Self {
            span: Span::empty(),
            start: R0,
            n: 0,
            next: 0,
        }
    }

    #[cfg_attr(debug_assertions, track_caller)]
    fn get(&mut self, m: &mut State, index: usize) -> Result<Reg> {
        if self.next >= self.n {
            unreachable!("ICE: reserved reg range exceeded");
        }
        if index != self.next as usize {
            unreachable!("ICE: reserved reg range used out of order");
        }

        let reg = f!(m).ra.alloc(self.span)?;

        #[cfg(debug_assertions)]
        if option_env!("PRINT_REGALLOC").is_some() {
            eprintln!("use reserved {reg:?} at {}", std::panic::Location::caller());
        }

        self.next += 1;

        if self.next == 0 && self.start.get() != reg.get() {
            unreachable!("ICE: reserved reg range must be used before next reg alloc");
        }

        Ok(reg)
    }

    #[cfg_attr(debug_assertions, track_caller)]
    fn free(self, m: &mut State) {
        free_reg_range(
            m,
            RegRange {
                start: self.start,
                n: self.n,
            },
        )
    }
}

/// Returns true if `reg` is at the top of the stack,
/// meaning the next allocated register would be `reg + 1`.
fn is_at_top<'a>(m: &mut State<'a>, reg: Reg) -> bool {
    f!(m).ra.is_at_top(reg)
}

/// Attempt to reuse `reg` if present, otherwise allocate a fresh register.
#[cfg_attr(debug_assertions, track_caller)]
fn maybe_reuse_reg<'a>(m: &mut State<'a>, span: Span, reg: Option<Reg>) -> Result<Reg> {
    #[cfg(debug_assertions)]
    if option_env!("PRINT_REGALLOC").is_some() {
        eprintln!("reuse {reg:?} at {}", std::panic::Location::caller());
    }

    let r = match reg {
        Some(reg) => Ok(reg),
        None => fresh_reg(m, span),
    };

    r
}

#[cfg_attr(debug_assertions, track_caller)]
/// Allocate a register.
fn fresh_reg<'a>(m: &mut State<'a>, span: Span) -> Result<Reg> {
    let r = f!(m).ra.alloc(span);

    #[cfg(debug_assertions)]
    if option_env!("PRINT_REGALLOC").is_some() {
        eprintln!("alloc {r:?} at {}", std::panic::Location::caller());
    }

    r
}

/// Allocate a contiguous range of registers.
#[cfg_attr(debug_assertions, track_caller)]
fn fresh_reg_range<'a>(m: &mut State<'a>, span: Span, n: u8) -> Result<RegRange> {
    let range = f!(m).ra.alloc_n(span, n);

    #[cfg(debug_assertions)]
    if option_env!("PRINT_REGALLOC").is_some() {
        eprintln!(
            "alloc range {range:?} at {}",
            std::panic::Location::caller()
        );
    }

    range
}

/// Reserve a contiguous range of registers.
///
/// These are _ephemeral_, which means they are not actually allocated,
/// but the maximum stack space is bumped as if they were.
///
/// As each register is used, it must be allocated first.
///
/// All the registers in this range can then be freed with a `free_reg_range`.
#[cfg_attr(debug_assertions, track_caller)]
fn reserve_reg_range<'a>(m: &mut State<'a>, span: Span, n: u8) -> Result<ReservedRegRange> {
    let range = f!(m).ra.alloc_n(span, n);

    #[cfg(debug_assertions)]
    if option_env!("PRINT_REGALLOC").is_some() {
        eprintln!(
            "reserve range {range:?} at {}",
            std::panic::Location::caller()
        );
    }

    let range = range?;
    f!(m).ra.free_n(range);

    let range = Ok(ReservedRegRange {
        span,
        start: range.start,
        n: range.n,
        next: 0,
    });

    range
}

/// Allocate a register, and mark it as in use by a variable.
///
/// When in use by a variable, a register won't be freed by `free_reg` and others,
/// instead being freed automatically at the end of the current scope.
#[cfg_attr(debug_assertions, track_caller)]
fn fresh_var<'a>(m: &mut State<'a>, span: Span) -> Result<Reg> {
    let r = f!(m).ra.alloc_var(span);

    #[cfg(debug_assertions)]
    if option_env!("PRINT_REGALLOC").is_some() {
        eprintln!("alloc var {r:?} at {}", std::panic::Location::caller());
    }

    r
}

/// Free a register.
#[cfg_attr(debug_assertions, track_caller)]
fn free_reg<'a>(m: &mut State<'a>, reg: Reg) {
    #[cfg(debug_assertions)]
    if option_env!("PRINT_REGALLOC").is_some() {
        eprintln!(
            "free reg {reg:?} (variable={}) at {}",
            reg.get() < f!(m).ra.scope_start + f!(m).ra.vars_in_scope,
            std::panic::Location::caller(),
        );
    }

    f!(m).ra.free(reg);
}

/// Free a register range.
#[cfg_attr(debug_assertions, track_caller)]
fn free_reg_range<'a>(m: &mut State<'a>, range: RegRange) {
    #[cfg(debug_assertions)]
    if option_env!("PRINT_REGALLOC").is_some() {
        eprintln!("free range {range:?} at {}", std::panic::Location::caller());
    }

    f!(m).ra.free_n(range);
}

/// If `value` is dynamic, free its register.
#[cfg_attr(debug_assertions, track_caller)]
fn free_value<'a>(m: &mut State<'a>, value: Value<'a>) {
    if let ValueKind::Dynamic(reg) = value.kind {
        #[cfg(debug_assertions)]
        if option_env!("PRINT_REGALLOC").is_some() {
            eprintln!(
                "free value {:?} (variable={}) at {}",
                value.kind,
                reg.get() < f!(m).ra.scope_start + f!(m).ra.vars_in_scope,
                std::panic::Location::caller(),
            );
        }

        f!(m).ra.free(reg);
    } else {
        #[cfg(debug_assertions)]
        if option_env!("PRINT_REGALLOC").is_some() {
            eprintln!(
                "free value {:?} at {}",
                value.kind,
                std::panic::Location::caller(),
            );
        }
    }
}

/// If `operand` is a register, free it.
#[cfg_attr(debug_assertions, track_caller)]
fn free_operand<'a>(m: &mut State<'a>, operand: Operand) {
    #[cfg(debug_assertions)]
    if option_env!("PRINT_REGALLOC").is_some() {
        eprintln!(
            "free operand {operand:?} at {}",
            std::panic::Location::caller(),
        );
    }

    if let Operand::Reg(reg) = operand {
        f!(m).ra.free(reg);
    }
}

struct Literals<'a> {
    flat: Vec<'a, Literal>,
    ints: HashMap<i64, Lit, rustc_hash::FxBuildHasher, &'a Bump>,
    floats: HashMap<f64n, Lit, rustc_hash::FxBuildHasher, &'a Bump>,
    strings: HashMap<&'a str, Lit, rustc_hash::FxBuildHasher, &'a Bump>,
}

impl<'a> Literals<'a> {
    fn new(buf: &'a Bump) -> Self {
        Self {
            flat: vec![in buf],
            ints: HashMap::with_capacity_and_hasher_in(
                16,
                rustc_hash::FxBuildHasher::default(),
                buf,
            ),
            floats: HashMap::with_capacity_and_hasher_in(
                16,
                rustc_hash::FxBuildHasher::default(),
                buf,
            ),
            strings: HashMap::with_capacity_and_hasher_in(
                16,
                rustc_hash::FxBuildHasher::default(),
                buf,
            ),
        }
    }

    fn is_next_id_8bit(&self) -> bool {
        let id = self.flat.len();
        id <= u8::MAX as usize
    }

    fn next_id(flat: &mut Vec<'a, Literal>, span: Span) -> Result<Lit> {
        let id = flat.len();
        if id > u16::MAX as usize {
            return error_span("too many literals", span).into();
        }
        Ok(unsafe { Lit::new_unchecked(id as u16) })
    }

    fn i64(&mut self, v: i64, span: Span) -> Result<Lit> {
        match self.ints.entry(v) {
            hashbrown::hash_map::Entry::Occupied(entry) => Ok(*entry.get()),
            hashbrown::hash_map::Entry::Vacant(entry) => {
                let id = Self::next_id(&mut self.flat, span)?;
                self.flat.push(Literal::Int(v));
                entry.insert(id);

                Ok(id)
            }
        }
    }

    fn f64(&mut self, v: f64n, span: Span) -> Result<Lit> {
        match self.floats.entry(v) {
            hashbrown::hash_map::Entry::Occupied(entry) => Ok(*entry.get()),
            hashbrown::hash_map::Entry::Vacant(entry) => {
                let id = Self::next_id(&mut self.flat, span)?;
                self.flat.push(Literal::Float(v.get()));
                entry.insert(id);

                Ok(id)
            }
        }
    }

    fn str(&mut self, v: &str, span: Span) -> Result<Lit> {
        let s = self.strings.allocator().alloc_str(v);
        match self.strings.entry(s) {
            hashbrown::hash_map::Entry::Occupied(entry) => Ok(*entry.get()),
            hashbrown::hash_map::Entry::Vacant(entry) => {
                let id = Self::next_id(&mut self.flat, span)?;
                self.flat.push(Literal::String(v.into()));
                entry.insert(id);

                Ok(id)
            }
        }
    }

    fn closure(&mut self, closure: ClosureInfo, span: Span) -> Result<Lit> {
        let id = Self::next_id(&mut self.flat, span)?;
        self.flat.push(Literal::ClosureInfo(closure));
        Ok(id)
    }

    fn import(&mut self, import: ImportInfo, span: Span) -> Result<Lit> {
        let id = Self::next_id(&mut self.flat, span)?;
        self.flat.push(Literal::ImportInfo(import));
        Ok(id)
    }
}

struct Loop<'a> {
    /// Points to first instruction in the loop body.
    entry: BackwardLabel,

    /// Points to after the last instruction in the loop body.
    exit: ForwardLabel<'a>,
}

struct ForwardLabel<'a> {
    /// Position of targets to patch
    patch_targets: Vec<'a, usize>,
}

impl<'a> ForwardLabel<'a> {
    fn new(buf: &'a Bump) -> Self {
        Self {
            patch_targets: vec![in buf],
        }
    }

    fn add_target(&mut self, m: &mut State<'a>, pos: usize) {
        assert!(matches!(
            f!(m).code.get(pos).map(|i| i.op()),
            Some(Opcode::Jmp)
        ));
        self.patch_targets.push(pos);
    }

    fn bind(self, f: &mut FunctionState<'a>) -> Result<()> {
        // if the label is unused, that means no `jmp` targets it,
        // therefore it is not actually a basic block entry.
        if !self.patch_targets.is_empty() {
            f.enter_basic_block();
        }

        let pos = f.code.len();
        let span = *f.dbg.spans.last().unwrap();
        for target in self.patch_targets {
            let offset = i24::try_from((pos - target) as isize)
                .map_err(|_| error_span("jump offset out of bounds for i24", span))?;

            let span = f.dbg.spans[target];
            let insn = &mut f.code[target];
            let Opcode::Jmp = insn.op() else {
                unreachable!("ICE: invalid label referree ({:?})", insn.op());
            };
            *insn = asm::jmp(unsafe { Imm24s::new_unchecked(offset) });
        }

        Ok(())
    }
}

struct BasicForwardLabel {
    patch_target: Option<usize>,
}

impl BasicForwardLabel {
    fn new() -> Self {
        Self { patch_target: None }
    }

    fn set_target(&mut self, m: &mut State<'_>, pos: usize) {
        assert!(matches!(
            f!(m).code.get(pos).map(|i| i.op()),
            Some(Opcode::Jmp)
        ));
        self.patch_target = Some(pos);
    }

    fn bind(self, f: &mut FunctionState<'_>) -> Result<()> {
        // if the label is unused, that means no `jmp` targets it,
        // therefore it is not actually a basic block entry.
        if self.patch_target.is_some() {
            f.enter_basic_block();
        }

        let pos = f.code.len();
        let span = *f.dbg.spans.last().unwrap();
        let Some(target) = self.patch_target else {
            return Ok(());
        };

        let offset = i24::try_from((pos - target) as isize)
            .map_err(|_| error_span("jump offset out of bounds for i24", span))?;

        let span = f.dbg.spans[target];
        let insn = &mut f.code[target];
        let Opcode::Jmp = insn.op() else {
            unreachable!("ICE: invalid label referree ({:?})", insn.op());
        };
        *insn = asm::jmp(unsafe { Imm24s::new_unchecked(offset) });

        Ok(())
    }
}

struct BackwardLabel {
    /// Instruction position
    pos: usize,
}

impl BackwardLabel {
    fn bind(f: &mut FunctionState<'_>) -> Self {
        Self { pos: f.code.len() }
    }

    fn offset(&self, jmp_pos: usize, span: Span) -> Result<Imm24s> {
        let offset = i24::try_from((self.pos as isize) - (jmp_pos as isize))
            .map_err(|_| error_span("jump offset exceeds u24::MAX", span))?;
        Ok(unsafe { Imm24s::new_unchecked(offset) })
    }
}

impl<'a> FunctionState<'a> {
    fn new(options: EmitOptions, name: Cow<'a, str>, top_level: bool, buf: &'a Bump) -> Self {
        Self {
            options,

            name,
            scopes: vec![in buf],
            ra: RegAlloc::new(),
            code: vec![in buf],
            literals: Literals::new(buf),
            loop_: None,
            in_block: true,

            top_level,
            upvalues: vec![in buf],

            dbg: FunctionDebug {
                spans: vec![in buf],
                locals: vec![in buf],
                upvalues: vec![in buf],
            },
        }
    }

    fn begin_scope(&mut self, buf: &'a Bump) {
        let reg_scope = self.ra.begin_scope();
        self.scopes.push(Scope {
            reg_scope,
            variables: vec![in buf],
            undefined_functions: vec![in buf],
        });
    }

    fn end_scope(&mut self) {
        let scope = self
            .scopes
            .pop()
            .expect("`end_scope` called without any scopes");
        self.ra.end_scope(scope.reg_scope);
    }

    fn begin_loop(&mut self, buf: &'a Bump) -> Option<Loop<'a>> {
        let entry = BackwardLabel::bind(self);
        let exit = ForwardLabel::new(buf);
        self.loop_.replace(Loop { entry, exit })
    }

    fn end_loop(&mut self, prev: Option<Loop<'a>>) -> Result<()> {
        let loop_ = std::mem::replace(&mut self.loop_, prev).expect("some loop");

        loop_.exit.bind(self)
    }

    fn declare_local(&mut self, name: &'a str, reg: Reg, span: Span) {
        let scope = self
            .scopes
            .last_mut()
            .expect("must always have at least one scope");
        scope.push(Variable::Local {
            name: name.into(),
            span,
            reg,
        });
        self.dbg.locals.push(Local { span, reg });
    }

    fn declare_upvalue(
        &mut self,
        name: &'a str,
        info: UpvalueDescriptor,
        span: Span,
    ) -> Result<Uv> {
        debug_assert!(!self.upvalues.iter().any(|c| c.name == name));

        if self.upvalues.len() >= u8::MAX as usize {
            return error_span(format!("too many upvalues, maximum is {}", u8::MAX), span).into();
        }

        let uv = unsafe { Uv::new_unchecked(self.upvalues.len() as u8) };
        self.upvalues.push(Upvalue {
            name: name.into(),
            span,
            info,
        });
        self.dbg.upvalues.push(module::Upvalue { span, info });
        Ok(uv)
    }

    fn declare_function(&mut self, name: impl Into<Cow<'a, str>>, arity: u8, span: Span, id: FnId) {
        let scope = self
            .scopes
            .last_mut()
            .expect("must always have at least one scope");
        scope.push(Variable::Function {
            name: name.into(),
            arity,
            span,
            id,
        });
    }

    fn resolve(&mut self, name: &'a str, span: Span) -> Result<Option<Symbol>> {
        for scope in self.scopes.iter().rev() {
            for var in scope.variables.iter().rev() {
                if var.name() == name {
                    return Ok(Some(var.symbol()));
                }
            }
        }

        for (idx, upvalue) in self.upvalues.iter().enumerate() {
            if upvalue.name == name {
                return Ok(Some(Symbol::Upvalue {
                    span: upvalue.span,
                    idx: unsafe { Uv::new_unchecked(idx as u8) },
                }));
            }
        }

        // to support function recursion in inner scopes, we treat the function
        // or closure itself as an upvalue:
        if !self.top_level && name == self.name {
            // next time around this will be picked up by `resolve` above,
            // yielding the same upvalue
            let id = self.declare_upvalue(name, UpvalueDescriptor::Rec, span)?;
            return Ok(Some(Symbol::Upvalue { span, idx: id }));
        }

        Ok(None)
    }

    fn resolve_in_scope(&self, name: &str) -> Option<Symbol> {
        for var in self.scopes.last()?.variables.iter().rev() {
            if var.name() == name {
                return Some(var.symbol());
            }
        }

        None
    }

    fn emit(&mut self, insn: Insn, span: Span) -> Option<usize> {
        // TODO(opt): dce should also affect regalloc
        if self.in_dead_code() {
            return None;
        }

        if let Some(prev_insn) = self.code.last().copied() {
            let prev_insn_index = self.code.len() - 1;

            if is_basic_block_exit(prev_insn, insn) {
                self.leave_basic_block();
            }

            // TODO(opt): what if it's a jump target?
            // if let Some(insn) = peephole(prev_insn, insn) {
            //     self.code[prev_insn_index] = insn;
            //     return None;
            // }
        }

        let index = self.code.len();
        self.code.push(insn);
        self.dbg.spans.push(span);
        Some(index)
    }

    fn in_dead_code(&self) -> bool {
        self.options.dead_code_elimination && !self.in_block
    }

    fn enter_basic_block(&mut self) {
        self.in_block = true;
    }

    fn leave_basic_block(&mut self) {
        self.in_block = false;
    }
}

impl<'a> State<'a> {
    fn begin_scope(&mut self) {
        f!(self).begin_scope(self.buf);
    }

    fn end_scope(&mut self) {
        f!(self).end_scope()
    }

    fn begin_loop(&mut self) -> Option<Loop<'a>> {
        f!(self).begin_loop(self.buf)
    }

    fn end_loop(&mut self, prev: Option<Loop<'a>>) -> Result<()> {
        f!(self).end_loop(prev)
    }

    fn is_top_level(&self) -> bool {
        self.func_stack.len() == 1 && f!(&self).scopes.len() == 1
    }

    fn declare_local(&mut self, name: &'a str, span: Span) -> Result<Reg> {
        let reg = fresh_var(self, span)?;
        f!(self).declare_local(name, reg, span);
        Ok(reg)
    }

    fn declare_local_in(&mut self, name: &'a str, reg: Reg, span: Span) -> Result<Reg> {
        f!(self).declare_local(name, reg, span);
        Ok(reg)
    }

    fn resolve(&mut self, name: &'a str, span: Span) -> Result<Option<Symbol>> {
        if let Some(symbol) = f!(self).resolve(name, span)? {
            return Ok(Some(symbol));
        }

        // Current function doesn't yet contain any local,
        // upvalue, or function with that name.

        // iterate in reverse over remaining functions,
        // skipping the current one
        for i in (0..self.func_stack.len()).rev().skip(1) {
            let Some(symbol) = self.func_stack[i].resolve(name, span)? else {
                continue;
            };

            match symbol {
                Symbol::Local { reg, span, .. } => {
                    // Found a variable in the enclosing scope.
                    // Declare it as a upvalue in all functions up the stack,
                    // including current function:
                    let mut info = UpvalueDescriptor::Reg(reg);
                    let mut idx = None;
                    for i in i + 1..self.func_stack.len() {
                        // This will fail if a function does not allow upvalues.
                        let new_upvalue = self.func_stack[i].declare_upvalue(name, info, span)?;
                        info = UpvalueDescriptor::Uv(new_upvalue);
                        idx = Some(new_upvalue);
                    }

                    // Then return the upvalue index for the top-level function:
                    let Some(idx) = idx else {
                        unreachable!("ICE: failed to get top-level upvalue index");
                    };

                    return Ok(Some(Symbol::Upvalue { span, idx }));
                }
                Symbol::Upvalue { idx, span, .. } => {
                    // Found a upvalue in the enclosing scope.
                    // Declare it as a upvalue in all functions up the stack,
                    // including current function:
                    let mut info = UpvalueDescriptor::Uv(idx);
                    let mut idx = idx;
                    for i in i + 1..self.func_stack.len() {
                        // This will fail if a function does not allow upvalues.
                        idx = self.func_stack[i].declare_upvalue(name, info, span)?;
                        info = UpvalueDescriptor::Uv(idx);
                    }

                    return Ok(Some(Symbol::Upvalue { span, idx }));
                }
                Symbol::Function { .. } => {
                    // Found a function in the enclosing scope, return it as-is.
                    return Ok(Some(symbol));
                }
                Symbol::ModuleVar { span, idx } => {
                    unreachable!("ICE: locals should never resolve to module vars");
                }
                Symbol::HostFunction { arity, id } => {
                    unreachable!("ICE: locals should never resolve to host functions")
                }
            }
        }

        if let Some(v) = self.module_vars.iter().find(|v| v.name == name) {
            return Ok(Some(Symbol::ModuleVar {
                span: v.span,
                idx: v.id,
            }));
        }

        if let Some((id, func)) = CoreLib::get().find(name) {
            return Ok(Some(Symbol::HostFunction {
                arity: func.arity,
                id,
            }));
        }

        Ok(None)
    }

    fn check_top_level_shadowing(&self, name: &str, span: Span) -> Result<()> {
        if !self.is_top_level() {
            return Ok(());
        }

        let Some(s) = self.resolve_in_scope(name) else {
            return Ok(());
        };

        match s {
            Symbol::Upvalue { .. } => unreachable!("ICE: upvalues in top-level code"),
            Symbol::Local { .. } | Symbol::ModuleVar { .. } | Symbol::Function { .. } => {
                return error_span("cannot shadow module variables", span).into();
            }
            Symbol::HostFunction { .. } => {
                // shadowing host functions is OK
                Ok(())
            }
        }
    }

    fn resolve_in_scope(&self, name: &str) -> Option<Symbol> {
        if let Some(s) = f!(&self).resolve_in_scope(name) {
            return Some(s);
        }

        if self.is_top_level() {
            if let Some(v) = self.module_vars.iter().find(|v| v.name == name) {
                return Some(Symbol::ModuleVar {
                    span: v.span,
                    idx: v.id,
                });
            }
        }

        None
    }

    fn emit(&mut self, insn: Insn, span: Span) -> Option<usize> {
        f!(self).emit(insn, span)
    }

    /// Declare a function which has not yet been emitted
    ///
    /// This assign it an ID and declares a symbol with its name
    fn declare_function(
        &mut self,
        name: impl Into<Cow<'a, str>>,
        arity: u8,
        span: Span,
    ) -> Result<FnId> {
        let name = name.into();
        let id = self.func_table.reserve(name.clone(), span)?;
        f!(self).declare_function(name, arity, span, id);
        Ok(id)
    }

    /// Define an function once that it's been emitted
    fn define_function(&mut self, id: FnId, f: FuncInfo) {
        self.func_table.define(id, f);
    }

    fn expect_module_var(&self, name: &str) -> ModuleVar<'a> {
        let Some(mvar) = self.module_vars.iter().find(|mv| mv.name == name).cloned() else {
            unreachable!("ICE: cannot find module var {name:?}");
        };

        mvar
    }

    fn enter_basic_block(&mut self) {
        f!(self).enter_basic_block();
    }

    fn leave_basic_block(&mut self) {
        f!(self).leave_basic_block();
    }
}

#[must_use]
#[derive(Clone, Copy)]
enum FreshVar {
    Reg(Reg),
    Mvar(Mvar),
}

#[repr(align(16))]
enum Symbol {
    Local { span: Span, reg: Reg },
    Upvalue { span: Span, idx: Uv },
    ModuleVar { span: Span, idx: Mvar },
    Function { arity: u8, span: Span, id: FnId },
    HostFunction { arity: u8, id: HostId },
}

fn emit_closure<'a>(
    m: &mut State<'a>,
    id: FnId,
    name: Cow<'a, str>,
    span: Span,
    params: NodeList<'a, Ident>,
    param_spans: &'a [Span],
    body: NodeList<'a, Stmt>,
) -> Result<(FuncInfo, ClosureInfo)> {
    let f = emit_func_inner(m, name, span, params, param_spans, body)?;

    let func = FuncInfo::new(
        f.name.into_owned(),
        params.len() as u8,
        f.ra.max_size,
        f.code.into_iter().collect(),
        f.literals.flat.into_iter().collect(),
        FuncDebugInfo {
            spans: f.dbg.spans.into_iter().collect(),
            locals: f.dbg.locals.into_iter().collect(),
            upvalues: f.dbg.upvalues.into_iter().collect(),
        },
    );
    let closure = ClosureInfo::new(id, f.upvalues.into_iter().map(|c| c.info).collect());

    Ok((func, closure))
}

fn emit_func<'a>(
    m: &mut State<'a>,
    id: FnId,
    name: Cow<'a, str>,
    span: Span,
    params: NodeList<'a, Ident>,
    param_spans: &'a [Span],
    body: NodeList<'a, Stmt>,
) -> Result<FuncInfo> {
    let f = emit_func_inner(m, name, span, params, param_spans, body)?;

    Ok(FuncInfo::new(
        f.name.into_owned(),
        params.len() as u8,
        f.ra.max_size,
        f.code.into_iter().collect(),
        f.literals.flat.into_iter().collect(),
        FuncDebugInfo {
            spans: f.dbg.spans.into_iter().collect(),
            locals: f.dbg.locals.into_iter().collect(),
            upvalues: f.dbg.upvalues.into_iter().collect(),
        },
    ))
}

fn emit_func_inner<'a>(
    m: &mut State<'a>,
    name: Cow<'a, str>,
    span: Span,
    params: NodeList<'a, Ident>,
    param_spans: &'a [Span],
    body: NodeList<'a, Stmt>,
) -> Result<FunctionState<'a>> {
    if params.len() > 100 {
        return error_span(
            "too many parameters, maximum is 100",
            *param_spans.last().unwrap(),
        )
        .into();
    }

    #[cfg(debug_assertions)]
    if option_env!("PRINT_REGALLOC").is_some() {
        eprintln!("new func {name}");
    }

    let top_level = m.is_top_level();
    let f = FunctionState::new(m.options.clone(), name, top_level, m.buf);
    m.func_stack.push(f);

    {
        m.begin_scope();
        // NOTE: don't free `ret_reg` as locals are placed above it,
        //       will be freed in `end_scope`.
        let r0 = fresh_var(m, span)?;
        for (param, &span) in params.iter().zip(param_spans.iter()) {
            let _ = m.declare_local(param.get(), span)?;
        }

        let ret = eval_block(m, body, Some(r0))?;
        let ret = value_to_reg_reuse(m, ret, r0)?;

        if ret != r0 {
            m.emit(asm::retv(ret), NO_SPAN);
        } else {
            m.emit(asm::ret(), NO_SPAN);
        }

        m.end_scope();
    }

    let f = m.func_stack.pop().expect("function stack is empty");

    #[cfg(debug_assertions)]
    if option_env!("PRINT_REGALLOC").is_some() {
        eprintln!("pop func {}", f.name);
    }

    Ok(f)
}

/// A compile-time value.
///
/// The code generator uses these to perform limited constant evaluation.
///
/// These values are either directly embedded into various instructions,
/// (e.g. `addvn` embeds a literal number in `n`), or materialized by
/// emitting a load instruction.
///
/// If the value is a constant, then no code to produce it at runtime
/// has been emitted yet.
#[derive(Clone, Copy)]
struct Value<'a> {
    kind: ValueKind<'a>,
    span: Span,
}

#[derive(Debug, Clone, Copy)]
enum ValueKind<'a> {
    /// `nil`
    Nil,

    /// `true` or `false`
    Bool(bool),

    /// Signed 64-bit integer
    Int(i64),

    /// 64-bit floating-point number
    ///
    /// Cannot be `NaN`.
    Float(f64n),

    /// Constant string
    Str(&'a str),

    // TODO: add mvar/uv kinds
    /// Value which can only be known at runtime,
    /// which will be stored in the given register.
    Dynamic(Reg),
}

enum Place {
    Reg(Reg),
    Mvar(Mvar),
    Uv(Uv),
}

impl<'a> Value<'a> {
    #[inline]
    fn type_name(self) -> &'static str {
        match self.kind {
            ValueKind::Nil => "Nil",
            ValueKind::Bool(_) => "Bool",
            ValueKind::Int(_) => "Int",
            ValueKind::Float(_) => "Float",
            ValueKind::Str(_) => "Str",
            ValueKind::Dynamic(_) => "Unknown",
        }
    }

    #[inline]
    fn is_const(self) -> bool {
        match self.kind {
            ValueKind::Nil
            | ValueKind::Bool(_)
            | ValueKind::Int(_)
            | ValueKind::Float(_)
            | ValueKind::Str(_) => true,
            ValueKind::Dynamic(_) => false,
        }
    }

    #[inline]
    fn is_in(self, reg: Reg) -> bool {
        matches!(self.kind, ValueKind::Dynamic(r) if r == reg)
    }

    #[inline]
    fn nil(span: Span) -> Self {
        Self {
            kind: ValueKind::Nil,
            span,
        }
    }

    #[inline]
    fn bool(v: bool, span: Span) -> Self {
        Self {
            kind: ValueKind::Bool(v),
            span,
        }
    }

    #[inline]
    fn int(v: i64, span: Span) -> Self {
        Self {
            kind: ValueKind::Int(v),
            span,
        }
    }

    #[inline]
    fn float(v: f64n, span: Span) -> Self {
        Self {
            kind: ValueKind::Float(v),
            span,
        }
    }

    #[inline]
    fn str(v: &'a str, span: Span) -> Self {
        Self {
            kind: ValueKind::Str(v),
            span,
        }
    }

    #[inline]
    fn dynamic(reg: Reg, span: Span) -> Self {
        Self {
            kind: ValueKind::Dynamic(reg),
            span,
        }
    }

    #[inline]
    fn coerce_bool(self) -> bool {
        match self.kind {
            ValueKind::Nil => false,
            ValueKind::Bool(v) => v,
            ValueKind::Int(v) => v != 0,
            ValueKind::Float(v) => v.get() != 0.0,
            ValueKind::Str(v) => true,
            ValueKind::Dynamic(reg) => unreachable!("ICE: coerce_bool on a register"),
        }
    }
}

const R0: Reg = unsafe { Reg::new_unchecked(0) };

fn eval_block<'a>(
    m: &mut State<'a>,
    list: NodeList<'a, Stmt>,
    dst: Option<Reg>,
) -> Result<Value<'a>> {
    let (stmt_list, tail) = match list.last().map(|node| node.kind()) {
        Some(ast::StmtKind::StmtExpr(tail)) => (list.slice(0..list.len() - 1), Some(tail)),
        _ => (list, None),
    };

    emit_stmt_list(m, stmt_list)?;

    match tail {
        None => Ok(Value::nil(Span::empty())),
        Some(tail) => eval_expr_maybe_reuse(m, tail.inner(), tail.inner_span(), dst),
    }
}

fn emit_stmt_list<'a>(m: &mut State<'a>, list: NodeList<'a, Stmt>) -> Result<()> {
    if m.is_top_level() {
        // 1. Declare all functions and variables in the stmt list
        let mut undefined_functions = vec![in m.buf];
        let mut module_vars = vec![in m.buf];
        let mut module_var_names =
            HashSet::with_capacity_and_hasher_in(16, FxBuildHasher::default(), m.buf);

        macro_rules! try_insert_module_var {
            ($name:expr, $span:expr $(,)?) => {{
                let name = $name;
                let span = $span;
                if !module_var_names.insert(name) {
                    return Err(error_span("cannot shadow module variables", span));
                }
                if module_vars.len() >= u8::MAX as usize {
                    return Err(error_span(
                        format!("too many module variables, maximum is {}", u8::MAX),
                        span,
                    ));
                }
                let id = module_vars.len() as u8;
                let id = unsafe { Mvar::new_unchecked(id) };
                module_vars.push(ModuleVar { name, span, id });
                Ok(())
            }};
        }

        macro_rules! try_insert_function {
            ($name:expr, $arity:expr, $span:expr $(,)?) => {{
                let name = $name;
                let arity = $arity;
                let span = $span;
                if !module_var_names.insert(name) {
                    return Err(error_span("cannot shadow module variables", span));
                }
                let id = m.declare_function(name, arity, span)?;
                undefined_functions.push(id);
                Ok(())
            }};
        }

        for stmt in list.iter().rev() {
            match stmt.kind() {
                ast::StmtKind::FuncDecl(node) => {
                    try_insert_function!(
                        node.name().get(),
                        // NOTE: `params` is always less than `u8::MAX`
                        node.params().len() as u8,
                        node.name_span(),
                    )?;
                }
                ast::StmtKind::Var(node) => {
                    try_insert_module_var!(node.name().get(), node.name_span())?
                }
                ast::StmtKind::Import(node) => {
                    for (node, span) in node.items().iter().zip(node.items_spans()) {
                        try_insert_module_var!(node.name().get(), node.name_span())?;
                    }
                }
                ast::StmtKind::ImportBare(node) => {
                    try_insert_module_var!(node.binding().get(), node.binding_span())?;
                }
                _ => {
                    continue;
                }
            }
        }

        f!(m)
            .scopes
            .last_mut()
            .expect("some scope")
            .undefined_functions = undefined_functions;

        m.module_vars = module_vars;

        // 2. Then process the stmt list.
        // As the stmt list is traversed, we come across `FuncDecl`/`Var`
        // again, at which point we _define_ them.
        //
        // To get the id of a function declaration, we `pop` from the
        // `undefined_functions` list, because we are guaranteed to
        // process them in the same order.
    }

    for (i, stmt) in list.iter().enumerate() {
        let span = list.get_span(i).unwrap();
        emit_stmt(m, stmt, span)?;
    }

    Ok(())
}

fn emit_stmt<'a>(m: &mut State<'a>, stmt: Node<'a, Stmt>, span: Span) -> Result<()> {
    #[cfg(debug_assertions)]
    if option_env!("PRINT_REGALLOC").is_some() {
        eprintln!("== emit stmt {stmt:?}");
    }

    match stmt.kind() {
        ast::StmtKind::Var(node) => emit_stmt_var(m, node)?,
        ast::StmtKind::Loop(node) => emit_stmt_loop(m, node)?,
        ast::StmtKind::FuncDecl(node) => emit_stmt_func(m, node)?,
        ast::StmtKind::StmtExpr(node) => emit_stmt_expr(m, node, span)?,
        ast::StmtKind::Import(node) => emit_stmt_import(m, Import::Named(node), span)?,
        ast::StmtKind::ImportBare(node) => emit_stmt_import(m, Import::Bare(node), span)?,
    }

    #[cfg(debug_assertions)]
    if option_env!("PRINT_REGALLOC").is_some() {
        eprintln!("== end stmt {stmt:?}");
    }

    Ok(())
}

fn emit_stmt_var<'a>(m: &mut State<'a>, var: Node<'a, ast::Var>) -> Result<()> {
    if m.is_top_level() {
        // NOTE: `emit_stmt_list` already checks for invalid shadowing
        // fast path: module variable

        let id = m.expect_module_var(var.name().get()).id;
        let tmp = fresh_reg(m, var.value_span())?;
        let value = eval_expr_reuse(m, var.value(), var.value_span(), tmp)?;
        value_force_reg(m, value, tmp)?;
        m.emit(asm::smvar(id, tmp), var.name_span());
        free_reg(m, tmp);

        return Ok(());
    }

    let dst = match m.resolve_in_scope(var.name().get()) {
        Some(Symbol::Local { reg, .. }) => Some(reg),
        _ => None,
    };

    if let Some(dst) = dst {
        // variable shadowing, reuse `reg`
        let value = eval_expr_reuse(m, var.value(), var.value_span(), dst)?;
        value_force_reg(m, value, dst)?;
        let _ = m.declare_local_in(var.name().get(), dst, var.name_span())?;
    } else {
        // fresh variable in some local scope
        let tmp = fresh_var(m, var.value_span())?;
        let value = eval_expr_reuse(m, var.value(), var.value_span(), tmp)?;
        value_force_reg(m, value, tmp)?;
        let _ = m.declare_local_in(var.name().get(), tmp, var.name_span())?;
    }

    Ok(())
}

fn emit_stmt_loop<'a>(m: &mut State<'a>, loop_: Node<'a, ast::Loop>) -> Result<()> {
    let prev_loop = m.begin_loop();
    m.begin_scope();
    emit_stmt_list(m, loop_.body())?;
    m.end_scope();

    // unconditional jump back to start
    let span = loop_.body_spans().last().copied().unwrap_or_default();
    let pos = f!(&m).code.len();
    let rel = f!(&m)
        .loop_
        .as_ref()
        .expect("some loop")
        .entry
        .offset(pos, span)?;
    m.emit(asm::jmp(rel), span);

    m.end_loop(prev_loop)?;

    Ok(())
}

fn emit_stmt_func<'a>(m: &mut State<'a>, func: Node<'a, ast::FuncDecl>) -> Result<()> {
    if m.is_top_level() {
        // top-level: emit a function table entry
        let id = f!(m)
            .scopes
            .last_mut()
            .expect("some scope")
            .undefined_functions
            .pop()
            .expect("some function");

        let f = emit_func(
            m,
            id,
            func.name().get().into(),
            func.name_span(),
            func.params(),
            func.params_spans(),
            func.body().body(),
        )?;

        m.define_function(id, f);

        Ok(())
    } else {
        // local: emit a closure in a local variable
        let span = func.name_span();
        let name = func.name().get();
        let id = m.func_table.reserve(name, span)?;

        let (func, closure) = emit_closure(
            m,
            id,
            name.into(),
            span,
            func.params(),
            func.params_spans(),
            func.body().body(),
        )?;

        m.func_table.define(id, func);
        let id = f!(m).literals.closure(closure, span)?;

        let reg = m.declare_local(name, span)?;
        m.emit(asm::lclosure(reg, id), span);
        Ok(())
    }
}

fn emit_stmt_expr<'a>(m: &mut State<'a>, node: Node<'a, ast::StmtExpr>, span: Span) -> Result<()> {
    m.begin_scope();
    let _ = eval_expr(m, node.inner(), node.inner_span())?;
    m.end_scope();

    Ok(())
}

enum Import<'a> {
    Named(Node<'a, ast::Import>),
    Bare(Node<'a, ast::ImportBare>),
}

fn emit_stmt_import<'a>(m: &mut State<'a>, node: Import<'a>, span: Span) -> Result<()> {
    let import_info = match node {
        Import::Named(node) => {
            // import a as x, b as y, c as z from "spec"
            let spec = node.path().get();

            let mut bindings = vec![in m.buf];
            for item in node.items() {
                let name = item.name().get();
                let alias = match item.alias().as_option() {
                    Some(alias) => alias.get(),
                    None => name,
                };

                if m.is_top_level() {
                    let id = m.expect_module_var(name).id;
                    bindings.push((name.to_string(), ImportBinding::Mvar(id)))
                } else {
                    let reg = m.declare_local(alias, item.alias_span())?;
                    bindings.push((name.to_string(), ImportBinding::Reg(reg)))
                }
            }

            ImportInfo::named(spec.to_string(), bindings.into_iter().collect())
        }
        Import::Bare(node) => {
            // import "spec" as name
            let spec = node.path().get();
            let binding = node.binding().get();

            let binding = if m.is_top_level() {
                let id = m.expect_module_var(binding).id;
                ImportBinding::Mvar(id)
            } else {
                let reg = m.declare_local(binding, node.binding_span())?;
                ImportBinding::Reg(reg)
            };

            ImportInfo::bare(spec.to_string(), binding)
        }
    };

    let lit = f!(m).literals.import(import_info, span)?;
    m.emit(asm::import(unsafe { Reg::new_unchecked(0) }, lit), span);

    Ok(())
}

fn eval_expr_maybe_reuse<'a>(
    m: &mut State<'a>,
    expr: Node<'a, ast::Expr>,
    span: Span,
    dst: Option<Reg>,
) -> Result<Value<'a>> {
    #[cfg(debug_assertions)]
    if option_env!("PRINT_REGALLOC").is_some() {
        eprintln!("== eval expr {expr:?}");
    }

    let result = match expr.kind() {
        ast::ExprKind::Return(node) => eval_expr_return(m, node, span, dst),
        ast::ExprKind::Break(node) => eval_expr_break(m, node, span, dst),
        ast::ExprKind::Continue(node) => eval_expr_continue(m, node, span, dst),
        ast::ExprKind::IfSimple(node) => eval_expr_if(m, If::Simple(node), span, dst),
        ast::ExprKind::IfMulti(node) => eval_expr_if(m, If::Multi(node), span, dst),
        ast::ExprKind::Block(node) => eval_expr_block(m, node, span, dst),
        ast::ExprKind::FuncAnon(node) => eval_expr_func(m, node, span, dst),
        ast::ExprKind::GetVar(node) => eval_expr_get_var(m, node, span, dst),
        ast::ExprKind::SetVar(node) => eval_expr_set_var(m, node, span, dst),
        ast::ExprKind::GetField(node) => eval_expr_get_field(m, node, span, dst),
        ast::ExprKind::SetField(node) => eval_expr_set_field(m, node, span, dst),
        ast::ExprKind::GetIndex(node) => eval_expr_get_index(m, node, span, dst),
        ast::ExprKind::SetIndex(node) => eval_expr_set_index(m, node, span, dst),
        ast::ExprKind::Call(node) => eval_expr_call(m, node, span, dst),
        ast::ExprKind::Infix(node) => eval_expr_infix(m, node, span, dst),
        ast::ExprKind::Prefix(node) => eval_expr_prefix(m, node, span, dst),
        ast::ExprKind::List(node) => eval_expr_list(m, node, span, dst),
        ast::ExprKind::Table(node) => eval_expr_table(m, node, span, dst),
        ast::ExprKind::Int32(node) => Ok(eval_expr_int(m, IntExpr::I32(node), span)),
        ast::ExprKind::Int64(node) => Ok(eval_expr_int(m, IntExpr::I64(node), span)),
        ast::ExprKind::Float32(node) => Ok(eval_expr_float(m, FloatExpr::F32(node), span)),
        ast::ExprKind::Float64(node) => Ok(eval_expr_float(m, FloatExpr::F64(node), span)),
        ast::ExprKind::Bool(node) => Ok(eval_expr_bool(m, node, span)),
        ast::ExprKind::Str(node) => Ok(eval_expr_str(m, node, span)),
        ast::ExprKind::Nil(node) => Ok(eval_expr_nil(m, node, span)),
    };

    #[cfg(debug_assertions)]
    if option_env!("PRINT_REGALLOC").is_some() {
        eprintln!("== end expr {expr:?}");
    }

    result
}

fn eval_expr<'a>(m: &mut State<'a>, expr: Node<'a, ast::Expr>, span: Span) -> Result<Value<'a>> {
    eval_expr_maybe_reuse(m, expr, span, None)
}

fn eval_expr_reuse<'a>(
    m: &mut State<'a>,
    expr: Node<'a, ast::Expr>,
    span: Span,
    dst: Reg,
) -> Result<Value<'a>> {
    eval_expr_maybe_reuse(m, expr, span, Some(dst))
}

fn eval_expr_return<'a>(
    m: &mut State<'a>,
    node: Node<'a, ast::Return>,
    span: Span,
    _dst: Option<Reg>,
) -> Result<Value<'a>> {
    let dst = R0;

    if let Some(value) = node.value().as_option() {
        let value = eval_expr_reuse(m, value, node.value_span(), dst)?;
        let value = value_to_reg_reuse(m, value, dst)?;

        if value != R0 {
            free_reg(m, value);
            m.emit(asm::retv(value), span);
        } else {
            m.emit(asm::ret(), span);
        }
    } else {
        value_force_reg(m, Value::nil(span), R0)?;
        m.emit(asm::ret(), span);
    }

    Ok(Value::nil(span))
}

fn eval_expr_break<'a>(
    m: &mut State<'a>,
    brk: Node<'a, ast::Break>,
    span: Span,
    dst: Option<Reg>,
) -> Result<Value<'a>> {
    let Some(mut loop_) = f!(m).loop_.take() else {
        return error_span("cannot use `break` outside of loop", span).into();
    };

    // break = unconditional jump to loop exit
    emit_forward_jmp(m, span, &mut loop_.exit);

    f!(m).loop_ = Some(loop_);

    Ok(Value::nil(span))
}

fn eval_expr_continue<'a>(
    m: &mut State<'a>,
    brk: Node<'a, ast::Continue>,
    span: Span,
    dst: Option<Reg>,
) -> Result<Value<'a>> {
    let Some(loop_) = f!(m).loop_.take() else {
        return error_span("cannot use `continue` outside of loop", span).into();
    };

    // continue = unconditional jump back to loop entry
    let pos = f!(m).code.len();
    let rel = loop_.entry.offset(pos, span)?;

    m.emit(asm::jmp(rel), span);

    f!(m).loop_ = Some(loop_);

    Ok(Value::nil(span))
}

enum If<'a> {
    Simple(Node<'a, ast::IfSimple>),
    Multi(Node<'a, ast::IfMulti>),
}

fn eval_expr_if<'a>(
    m: &mut State<'a>,
    node: If<'a>,
    span: Span,
    dst: Option<Reg>,
) -> Result<Value<'a>> {
    let out = maybe_reuse_reg(m, span, dst)?;

    let mut exit = ForwardLabel::new(m.buf);

    match node {
        // if <cond> do <body> else <tail>
        If::Simple(node) => {
            // TODO(clean): dedup
            let mut targets = BranchTargets {
                next: ForwardLabel::new(m.buf),
                body: ForwardLabel::new(m.buf),
            };

            // if the condition is true, execute `body`. otherwise, `jmp` to `tail`.
            emit_if_cond(m, node.cond(), node.cond_span(), out, &mut targets)?;
            emit_forward_jmp(m, span, &mut targets.next);

            targets.body.bind(f!(m))?;

            m.begin_scope();
            let value = eval_block(m, node.body(), Some(out))?;
            value_force_reg(m, value, out)?;
            m.end_scope();

            // if `tail` exists and we execute `body`, we should skip `tail`.
            if node.tail().is_some() {
                emit_forward_jmp(m, span, &mut exit);
            }

            targets.next.bind(f!(m))?;

            if let Some(tail) = node.tail().as_option() {
                let value = eval_expr_block(m, tail, node.tail_span(), Some(out))?;
                value_force_reg(m, value, out)?;
            }

            if node.tail().is_some() {
                exit.bind(f!(m))?;
            }
        }
        If::Multi(node) => {
            let mut branches = node.branches().iter().peekable();

            while let Some(branch) = branches.next() {
                let mut targets = BranchTargets {
                    next: ForwardLabel::new(m.buf),
                    body: ForwardLabel::new(m.buf),
                };

                // if the condition is true, execute `body`. otherwise, `jmp` to `tail`.
                emit_if_cond(m, branch.cond(), branch.cond_span(), out, &mut targets)?;
                emit_forward_jmp(m, span, &mut targets.next);

                targets.body.bind(f!(m))?;

                m.begin_scope();
                let value = eval_block(m, branch.body(), Some(out))?;
                value_force_reg(m, value, out)?;
                m.end_scope();

                let has_next = branches.peek().is_some() || node.tail().is_some();
                if has_next {
                    emit_forward_jmp(m, span, &mut exit);
                }

                targets.next.bind(f!(m))?;
            }

            if let Some(tail) = node.tail().as_option() {
                let value = eval_expr_block(m, tail, node.tail_span(), Some(out))?;
                value_force_reg(m, value, out)?;
            }

            exit.bind(f!(m))?;
        }
    }

    Ok(Value::dynamic(out, span))
}

struct BranchTargets<'a> {
    next: ForwardLabel<'a>,
    body: ForwardLabel<'a>,
}

fn emit_if_cond<'a>(
    m: &mut State<'a>,
    node: Node<'a, ast::Expr>,
    span: Span,
    dst: Reg,
    targets: &mut BranchTargets<'a>,
) -> Result<()> {
    emit_if_cond_inner(m, node, span, dst, false, targets)
}

fn emit_if_cond_inner<'a>(
    m: &mut State<'a>,
    node: Node<'a, ast::Expr>,
    span: Span,
    dst: Reg,
    negated: bool,
    targets: &mut BranchTargets<'a>,
) -> Result<()> {
    use ast::InfixOp as Op;
    match node.kind() {
        ast::ExprKind::Infix(node) if node.op().is_logical() => match (*node.op(), negated) {
            (Op::And, false) => {
                emit_if_cond_inner(m, node.lhs(), node.lhs_span(), dst, false, targets)?;
                emit_forward_jmp(m, span, &mut targets.next);
                emit_if_cond_inner(m, node.rhs(), node.rhs_span(), dst, false, targets)?;
                // `rhs` jmp is emitted by caller

                Ok(())
            }
            (Op::And, true) => {
                // de morgan says: not(lhs and rhs) == not(lhs) or not(rhs)
                // semantics:
                //   if not(lhs) do body()
                //   else if not(rhs) do body()
                //   end
                emit_if_cond_inner(m, node.lhs(), node.lhs_span(), dst, false, targets)?;
                emit_forward_jmp(m, span, &mut targets.body);
                emit_if_cond_inner(m, node.rhs(), node.rhs_span(), dst, true, targets)?;
                // `rhs` jmp is emitted by caller

                Ok(())
            }

            (Op::Or, false) => {
                // semantics:
                //   if lhs do body()
                //   else if rhs do body()
                //   end
                emit_if_cond_inner(m, node.lhs(), node.lhs_span(), dst, true, targets)?;
                emit_forward_jmp(m, span, &mut targets.body);
                emit_if_cond_inner(m, node.rhs(), node.rhs_span(), dst, false, targets)?;
                // `rhs` jmp is emitted by caller

                Ok(())
            }
            (Op::Or, true) => {
                // de morgan says: not(lhs or rhs) == not(lhs) and not(rhs)
                // semantics:
                //   if not(lhs) do
                //     if not(rhs) do body() end
                //   end
                emit_if_cond_inner(m, node.lhs(), node.lhs_span(), dst, true, targets)?;
                emit_forward_jmp(m, span, &mut targets.next);
                emit_if_cond_inner(m, node.rhs(), node.rhs_span(), dst, true, targets)?;
                // `rhs` jmp is emitted by caller

                Ok(())
            }

            _ => unreachable!(),
        },

        ast::ExprKind::Infix(node) if node.op().is_comparison() => {
            let lhs = eval_expr_reuse(m, node.lhs(), node.lhs_span(), dst)?;
            let rhs = eval_expr(m, node.rhs(), node.rhs_span())?;

            // put whichever side is const on the rhs
            let (lhs, rhs) = if rhs.is_const() {
                (lhs, rhs)
            } else if lhs.is_const() {
                (rhs, lhs)
            } else {
                (lhs, rhs)
            };

            let lhs = value_to_reg_reuse(m, lhs, dst)?;
            let insn = if node.op().is_eq() && rhs.is_const() {
                use ValueKind as V;

                match (*node.op(), negated) {
                    (Op::Eq, false) | (Op::Ne, true) => match rhs.kind {
                        V::Nil => asm::isnil(lhs),
                        V::Bool(true) => asm::istrue(lhs),
                        V::Bool(false) => asm::isfalse(lhs),
                        V::Int(v) => asm::iseqi(lhs, f!(m).literals.i64(v, node.rhs_span())?),
                        V::Float(v) => asm::iseqf(lhs, f!(m).literals.f64(v, node.rhs_span())?),
                        V::Str(v) => asm::iseqs(lhs, f!(m).literals.str(v, node.rhs_span())?),
                        _ => unreachable!("ICE: non-const value in rhs of const eq path"),
                    },
                    (Op::Ne, false) | (Op::Eq, true) => match rhs.kind {
                        V::Nil => asm::isnotnil(lhs),
                        V::Bool(true) => asm::isfalse(lhs),
                        V::Bool(false) => asm::istrue(lhs),
                        V::Int(v) => asm::isnei(lhs, f!(m).literals.i64(v, node.rhs_span())?),
                        V::Float(v) => asm::isnef(lhs, f!(m).literals.f64(v, node.rhs_span())?),
                        V::Str(v) => asm::isnes(lhs, f!(m).literals.str(v, node.rhs_span())?),
                        _ => unreachable!("ICE: non-const value in rhs of const eq path"),
                    },
                    _ => unreachable!("ICE: non-eq op in eq op path"),
                }
            } else {
                let rhs = value_to_reg(m, rhs)?;
                let insn = match (*node.op(), negated) {
                    (Op::Eq, false) | (Op::Ne, true) => asm::iseq(lhs, rhs),
                    (Op::Ne, false) | (Op::Eq, true) => asm::isne(lhs, rhs),
                    (Op::Gt, false) | (Op::Le, true) => asm::isgt(lhs, rhs),
                    (Op::Ge, false) | (Op::Lt, true) => asm::isge(lhs, rhs),
                    (Op::Lt, false) | (Op::Ge, true) => asm::islt(lhs, rhs),
                    (Op::Le, false) | (Op::Gt, true) => asm::isle(lhs, rhs),
                    _ => unreachable!("ICE: non-comparison in if cond comparison path"),
                };
                free_reg(m, rhs);
                insn
            };

            m.emit(insn, span);

            if lhs != dst {
                free_reg(m, lhs);
            }

            Ok(())
        }

        ast::ExprKind::Prefix(node) if *node.op() == ast::PrefixOp::Not => {
            emit_if_cond_inner(m, node.rhs(), node.rhs_span(), dst, true, targets)
        }

        _ => emit_if_cond_generic(m, node, span, dst, negated, targets),
    }
}

fn emit_if_cond_generic<'a>(
    m: &mut State<'a>,
    node: Node<'a, ast::Expr>,
    span: Span,
    dst: Reg,
    negated: bool,
    targets: &mut BranchTargets<'a>,
) -> Result<()> {
    // we don't know what `node` holds, so we have to emit it into `dst`
    // and then test it.
    let value = eval_expr_reuse(m, node, span, dst)?;
    let value = value_to_reg_reuse(m, value, dst)?;

    // values will be coerced to `bool` by `isfalse`/`istrue`.
    let insn = if negated {
        // we want to skip the `jmp` if the value is _falsey_.
        asm::isfalse(value)
    } else {
        // we want to skip the `jmp` if the value is _truthy_.
        asm::istrue(value)
    };

    m.emit(insn, span);

    if value != dst {
        free_reg(m, value);
    }

    // `jmp` is emitted by caller.

    Ok(())
}

fn eval_expr_block<'a>(
    m: &mut State<'a>,
    block: Node<'a, ast::Block>,
    span: Span,
    dst: Option<Reg>,
) -> Result<Value<'a>> {
    m.begin_scope();
    let dst = eval_block(m, block.body(), dst)?;
    m.end_scope();
    Ok(dst)
}

fn eval_expr_func<'a>(
    m: &mut State<'a>,
    func: Node<'a, ast::FuncAnon>,
    span: Span,
    dst: Option<Reg>,
) -> Result<Value<'a>> {
    let span = if func.name().is_some() {
        func.name_span()
    } else {
        func.body_span()
    };

    let dst = maybe_reuse_reg(m, span, dst)?;

    let name: Cow<_> = if let Some(name) = func.name().as_option() {
        let name = name.get();
        format!("closure{{{name}@{span}}}").into()
    } else {
        format!("closure{{@{span}}}").into()
    };

    // note: function expressions can't be referenced before
    // they're fully defined, so we don't need to reserve
    // them ahead of time
    let id = m.func_table.reserve(name.clone(), span)?;

    let (func, closure) = emit_closure(
        m,
        id,
        name,
        span,
        func.params(),
        func.params_spans(),
        func.body().body(),
    )?;

    m.func_table.define(id, func);
    let id = f!(m).literals.closure(closure, span)?;
    m.emit(asm::lclosure(dst, id), span);

    Ok(Value::dynamic(dst, span))
}

fn eval_expr_get_var<'a>(
    m: &mut State<'a>,
    get: Node<'a, ast::GetVar>,
    span: Span,
    dst: Option<Reg>,
) -> Result<Value<'a>> {
    let span = get.name_span();

    // variable must exist at this point
    match m
        .resolve(get.name().get(), get.name_span())?
        .ok_or_else(|| error_span("could not resolve name", span))?
    {
        Symbol::Local { reg, .. } => Ok(Value::dynamic(reg, span)),
        Symbol::Upvalue { idx, .. } => {
            let dst = maybe_reuse_reg(m, span, dst)?;
            m.emit(asm::luv(dst, idx), span);
            Ok(Value::dynamic(dst, span))
        }
        Symbol::ModuleVar { idx, .. } => {
            let dst = maybe_reuse_reg(m, span, dst)?;
            m.emit(asm::lmvar(dst, idx), span);
            Ok(Value::dynamic(dst, span))
        }
        Symbol::Function { id, .. } => {
            let dst = maybe_reuse_reg(m, span, dst)?;
            m.emit(asm::lfunc(dst, id), span);
            Ok(Value::dynamic(dst, span))
        }
        Symbol::HostFunction { id, .. } => {
            let dst = maybe_reuse_reg(m, span, dst)?;
            m.emit(asm::lhost(dst, id), span);
            Ok(Value::dynamic(dst, span))
        }
    }
}

fn eval_expr_set_var<'a>(
    m: &mut State<'a>,
    set: Node<'a, ast::SetVar>,
    span: Span,
    dst: Option<Reg>,
) -> Result<Value<'a>> {
    let _ = dst;

    #[derive(Clone, Copy)]
    enum Id {
        Reg(Reg),
        Uv(Reg, Uv),
        Mvar(Reg, Mvar),
    }

    impl Id {
        fn dst(&self) -> Reg {
            match self {
                Id::Reg(reg) => *reg,
                Id::Uv(reg, cap) => *reg,
                Id::Mvar(reg, mvar) => *reg,
            }
        }

        fn load<'a>(&self, m: &mut State<'a>, span: Span) -> Result<()> {
            match self {
                Id::Reg(reg) => Ok(()),
                Id::Uv(reg, cap) => {
                    m.emit(asm::luv(*reg, *cap), span);
                    Ok(())
                }
                Id::Mvar(reg, mvar) => {
                    m.emit(asm::lmvar(*reg, *mvar), span);
                    Ok(())
                }
            }
        }

        fn store<'a>(&self, m: &mut State<'a>, span: Span) {
            match self {
                Id::Reg(reg) => { /* already in reg */ }
                Id::Uv(reg, cap) => {
                    m.emit(asm::suv(*cap, *reg), span);
                }
                Id::Mvar(reg, mvar) => {
                    m.emit(asm::smvar(*mvar, *reg), span);
                }
            }
        }
    }

    fn free_id<'a>(m: &mut State<'a>, id: Id) {
        match id {
            Id::Reg(reg) => { /* variable */ }
            Id::Uv(reg, cap) => free_reg(m, reg),
            Id::Mvar(reg, mvar) => free_reg(m, reg),
        }
    }

    // variable must exist at this point
    let id = match m
        .resolve(set.base().name().get(), set.base().name_span())?
        .ok_or_else(|| error_span("could not resolve name", set.base().name_span()))?
    {
        // when adding other symbols, remember to error out here,
        // only local variables may be assigned to
        Symbol::Local { reg, .. } => Id::Reg(reg),
        Symbol::Upvalue { idx, .. } => Id::Uv(fresh_reg(m, span)?, idx),
        Symbol::ModuleVar { idx, .. } => Id::Mvar(fresh_reg(m, span)?, idx),
        Symbol::Function { .. } => return error_span("cannot assign to function", span).into(),
        Symbol::HostFunction { .. } => {
            return error_span("cannot assign to host function", span).into();
        }
    };

    // lhs is always a register, so we only evaluate rhs, and emit either `vv` or `vn`.
    let (vv, vn): (fn(Reg, Reg, Reg) -> Insn, fn(Reg, Reg, Lit8) -> Insn) = match *set.op() {
        ast::AssignOp::None => {
            // emit the value, then optionally store it in upvalue/module var
            let value = eval_expr_reuse(m, set.value(), set.value_span(), id.dst())?;
            match id {
                Id::Reg(reg) => {
                    value_force_reg(m, value, reg)?;
                }
                Id::Uv(reg, uv) => {
                    m.emit(asm::suv(uv, reg), span);
                }
                Id::Mvar(reg, mvar) => {
                    m.emit(asm::smvar(mvar, reg), span);
                }
            }
            return Ok(Value::nil(span));
        }
        ast::AssignOp::Add => (asm::addvv, asm::addvn),
        ast::AssignOp::Sub => (asm::subvv, asm::subvn),
        ast::AssignOp::Mul => (asm::mulvv, asm::mulvn),
        ast::AssignOp::Div => (asm::divvv, asm::divvn),
        ast::AssignOp::Rem => (asm::remvv, asm::remvn),
    };

    // For arithmetic assign, first need to load the value from upvalue/module var.
    // If `id` is a register, this will do nothing.
    id.load(m, set.base().name_span())?;

    // Then evaluate the rhs:
    let value = eval_expr(m, set.value(), set.value_span())?;
    let value = value_to_operand(m, value)?;
    let insn = match value {
        Operand::Reg(rhs) => vv(id.dst(), id.dst(), rhs),
        Operand::Const(rhs) => vn(id.dst(), id.dst(), rhs),
    };
    m.emit(insn, span);

    // And optionally assign it back to its upvalue/module var:
    id.store(m, span);

    free_operand(m, value);
    free_id(m, id);

    Ok(Value::nil(span))
}

fn eval_expr_get_field<'a>(
    m: &mut State<'a>,
    node: Node<'a, ast::GetField>,
    span: Span,
    dst: Option<Reg>,
) -> Result<Value<'a>> {
    let dst = maybe_reuse_reg(m, span, dst)?;

    let parent = eval_expr_reuse(m, node.parent(), node.parent_span(), dst)?;
    let parent = value_to_reg_reuse(m, parent, dst)?;

    let idx = str_to_operand(m, node.key().get(), node.key_span(), None)?;
    runtime_eval_key(m, dst, parent, idx, span);

    free_operand(m, idx);
    if parent != dst {
        free_reg(m, parent);
    }

    Ok(Value::dynamic(dst, span))
}

fn runtime_eval_key<'a>(m: &mut State<'a>, dst: Reg, parent: Reg, idx: Operand, span: Span) {
    let insn = match idx {
        Operand::Reg(idx) => asm::lkey(dst, parent, idx),
        Operand::Const(idx) => asm::lkeyc(dst, parent, idx),
    };
    m.emit(insn, span);
}

fn eval_expr_set_field<'a>(
    m: &mut State<'a>,
    node: Node<'a, ast::SetField>,
    span: Span,
    dst: Option<Reg>,
) -> Result<Value<'a>> {
    let _ = dst;

    let parent = eval_expr(m, node.base().parent(), node.base().parent_span())?;
    let parent = value_to_reg(m, parent)?;

    let idx = str_to_operand(m, node.base().key().get(), node.base().key_span(), None)?;

    let value = if *node.op() != ast::AssignOp::None {
        let lhs = fresh_reg(m, node.base_span())?;
        runtime_eval_key(m, lhs, parent, idx, span);

        let rhs = eval_expr(m, node.value(), node.value_span())?;
        let rhs = value_to_operand(m, rhs)?;

        let op = match *node.op() {
            ast::AssignOp::Add => ast::InfixOp::Add,
            ast::AssignOp::Sub => ast::InfixOp::Sub,
            ast::AssignOp::Mul => ast::InfixOp::Mul,
            ast::AssignOp::Div => ast::InfixOp::Div,
            _ => unreachable!("ICE: assign op none"),
        };
        runtime_eval_expr_infix_arith(m, op, lhs, Operand::Reg(lhs), rhs, span);

        free_operand(m, rhs);

        lhs
    } else {
        let value = eval_expr(m, node.value(), node.value_span())?;
        value_to_reg(m, value)?
    };

    let insn = match idx {
        Operand::Reg(idx) => asm::skey(parent, idx, value),
        Operand::Const(idx) => asm::skeyc(parent, idx, value),
    };
    m.emit(insn, span);

    free_reg(m, value);
    free_operand(m, idx);
    free_reg(m, parent);

    Ok(Value::nil(span))
}

fn eval_expr_get_index<'a>(
    m: &mut State<'a>,
    node: Node<'a, ast::GetIndex>,
    span: Span,
    dst: Option<Reg>,
) -> Result<Value<'a>> {
    let dst = maybe_reuse_reg(m, span, dst)?;

    let parent = eval_expr_reuse(m, node.parent(), node.parent_span(), dst)?;
    let parent = value_to_reg_reuse(m, parent, dst)?;

    let idx = eval_idx(m, node.key(), node.key_span())?;
    runtime_eval_idx(m, dst, parent, idx, span);

    free_idx(m, idx);
    if parent != dst {
        free_reg(m, parent);
    }

    Ok(Value::dynamic(dst, span))
}

fn runtime_eval_idx<'a>(m: &mut State<'a>, dst: Reg, parent: Reg, idx: Idx, span: Span) {
    let insn = match idx {
        Idx::Str(idx) => asm::lkeyc(dst, parent, idx),
        Idx::Int(idx) => asm::lidxn(dst, parent, idx),
        Idx::Reg(idx) => asm::lidx(dst, parent, idx),
    };
    m.emit(insn, span);
}

fn eval_expr_set_index<'a>(
    m: &mut State<'a>,
    node: Node<'a, ast::SetIndex>,
    span: Span,
    dst: Option<Reg>,
) -> Result<Value<'a>> {
    let _ = dst;

    let parent = eval_expr(m, node.base().parent(), node.base().parent_span())?;
    let parent = value_to_reg(m, parent)?;

    let idx = eval_idx(m, node.base().key(), node.base().key_span())?;

    let value = if *node.op() != ast::AssignOp::None {
        let lhs = fresh_reg(m, node.base_span())?;
        runtime_eval_idx(m, lhs, parent, idx, node.base().key_span());

        let rhs = eval_expr(m, node.value(), node.value_span())?;
        let rhs = value_to_operand(m, rhs)?;

        let op = match *node.op() {
            ast::AssignOp::Add => ast::InfixOp::Add,
            ast::AssignOp::Sub => ast::InfixOp::Sub,
            ast::AssignOp::Mul => ast::InfixOp::Mul,
            ast::AssignOp::Div => ast::InfixOp::Div,
            _ => unreachable!("ICE: assign op none"),
        };
        runtime_eval_expr_infix_arith(m, op, lhs, Operand::Reg(lhs), rhs, span);

        free_operand(m, rhs);

        lhs
    } else {
        let value = eval_expr(m, node.value(), node.value_span())?;
        value_to_reg(m, value)?
    };

    let insn = match idx {
        Idx::Str(idx) => asm::skeyc(parent, idx, value),
        Idx::Int(idx) => asm::sidxn(parent, idx, value),
        Idx::Reg(idx) => asm::sidx(parent, idx, value),
    };
    m.emit(insn, span);

    free_reg(m, value);
    free_idx(m, idx);
    free_reg(m, parent);

    Ok(Value::nil(span))
}

#[derive(Clone, Copy)]
enum Idx {
    Str(Lit8),
    Int(Lit8),
    Reg(Reg),
}

fn free_idx(m: &mut State<'_>, idx: Idx) {
    match idx {
        Idx::Str(_) => {}
        Idx::Int(_) => {}
        Idx::Reg(reg) => free_reg(m, reg),
    }
}

fn eval_idx<'a>(m: &mut State<'a>, idx: Node<'a, ast::Expr>, span: Span) -> Result<Idx> {
    let idx = eval_expr(m, idx, span)?;
    let idx = match idx.kind {
        ValueKind::Int(idx) => {
            let idx = int_to_operand(m, idx, span, None)?;

            match idx {
                Operand::Const(idx) => Idx::Int(idx),
                Operand::Reg(idx) => Idx::Reg(idx),
            }
        }
        ValueKind::Str(idx) => {
            let idx = str_to_operand(m, idx, span, None)?;
            match idx {
                Operand::Const(idx) => Idx::Str(idx),
                Operand::Reg(idx) => Idx::Reg(idx),
            }
        }
        _ => {
            let idx = value_to_reg(m, idx)?;
            Idx::Reg(idx)
        }
    };
    Ok(idx)
}

fn prepare_fast_call<'a>(
    m: &mut State<'a>,
    call: Node<'a, ast::Call>,
    dst: Option<Reg>,
    span: Span,
    arity: u8,
) -> Result<(Reg, ReservedRegRange)> {
    // Fastcall optimization: If the symbol is syntactically a function, then
    // - check arity now, and
    // - call the function by ID, avoiding arity/type checking

    let nargs = call.args().len() as u8;
    let (dst, mut args) = match dst {
        // We can use `dst` directly:
        // - If `dst` is top of stack, meaning argument registers can be
        //   allocated contiguously after `dst`
        Some(dst) if is_at_top(m, dst) => {
            // Yes; allocate registers for args right above `dst`, if there are any.
            let args = reserve_reg_range(m, span, nargs)?;
            (dst, args)
        }
        _ => {
            // No; allocate our own `dst` and args contiguously
            let dst = fresh_reg(m, span)?;
            let args = reserve_reg_range(m, span, nargs)?;
            (dst, args)
        }
    };
    if nargs != arity {
        return error_span(
            format!("invalid number of arguments, expected {arity} but got {nargs}"),
            span,
        )
        .into();
    }

    for (i, (value, &span)) in call.args().into_iter().zip(call.args_spans()).enumerate() {
        let reg = args.get(m, i)?;
        let value = eval_expr_reuse(m, value, span, reg)?;
        value_force_reg(m, value, reg)?;
        if !value.is_in(reg) {
            free_value(m, value);
        }
    }

    Ok((dst, args))
}

// TODO(feat): specialize "method" calls (get prop -> call in a single instruction)
fn eval_expr_call<'a>(
    m: &mut State<'a>,
    call: Node<'a, ast::Call>,
    span: Span,
    dst: Option<Reg>,
) -> Result<Value<'a>> {
    // `out+1` is start of args, `out` and args must be contiguous
    // maximum number of args is 100, so they always fit within `u8`

    let out = if let ast::ExprKind::GetVar(node) = call.callee().kind()
        && let Some(Symbol::Function { arity, id, .. }) =
            m.resolve(node.name().get(), node.name_span())?
    {
        let (dst, args) = prepare_fast_call(m, call, dst, span, arity)?;

        m.emit(asm::fastcall(dst, id), span);

        args.free(m);

        dst
    } else if let ast::ExprKind::GetVar(node) = call.callee().kind()
        && let Some(Symbol::HostFunction { arity, id, .. }) =
            m.resolve(node.name().get(), node.name_span())?
    {
        let (dst, args) = prepare_fast_call(m, call, dst, span, arity)?;

        m.emit(asm::hostcall(dst, id), span);

        args.free(m);

        dst
    } else {
        // this is `maybe_reuse_reg` with additional condition of
        // the reused register being at the top of the stack
        let dst = match dst {
            Some(dst) if is_at_top(m, dst) => {
                #[cfg(debug_assertions)]
                if option_env!("PRINT_REGALLOC").is_some() {
                    eprintln!("reuse (call) {dst:?} at {}", std::panic::Location::caller());
                }

                dst
            }
            _ => fresh_reg(m, span)?,
        };

        let nargs = call.args().len() as u8;
        let args_span = Span {
            start: call.args_spans().first().unwrap_or(&span).start,
            end: call.args_spans().last().unwrap_or(&span).end,
        };
        let mut args = reserve_reg_range(m, span, nargs)?;

        // the reuse here is sound, because if the callee expr is another call,
        // it will check for itself if the `dst` is at top or not.
        // So calls like `v()()` can re-use `dst`, but `v(1)(2)` cannot.
        let callee = eval_expr_reuse(m, call.callee(), call.callee_span(), dst)?;
        let callee = value_to_reg_reuse(m, callee, dst)?;

        for (i, (value, &span)) in call.args().into_iter().zip(call.args_spans()).enumerate() {
            let reg = args.get(m, i)?;
            let value = eval_expr_reuse(m, value, span, reg)?;
            value_force_reg(m, value, reg)?;
            if !value.is_in(reg) {
                free_value(m, value);
            }
        }

        m.emit(
            asm::call(dst, callee, unsafe { Imm8::new_unchecked(nargs) }),
            span,
        );

        args.free(m);
        if callee != dst {
            free_reg(m, callee);
        }

        dst
    };

    Ok(Value::dynamic(out, span))
}

trait ExprInfo {
    fn needs_contiguous_registers(&self) -> bool;
}

impl ExprInfo for Node<'_, ast::Expr> {
    fn needs_contiguous_registers(&self) -> bool {
        match self.kind() {
            ast::ExprKind::Call(node) => !node.args().is_empty(),

            ast::ExprKind::Return(..)
            | ast::ExprKind::Break(..)
            | ast::ExprKind::Continue(..)
            | ast::ExprKind::IfSimple(..)
            | ast::ExprKind::IfMulti(..)
            | ast::ExprKind::Block(..)
            | ast::ExprKind::FuncAnon(..)
            | ast::ExprKind::GetVar(..)
            | ast::ExprKind::SetVar(..)
            | ast::ExprKind::GetField(..)
            | ast::ExprKind::SetField(..)
            | ast::ExprKind::GetIndex(..)
            | ast::ExprKind::SetIndex(..)
            | ast::ExprKind::Infix(..)
            | ast::ExprKind::Prefix(..)
            | ast::ExprKind::List(..)
            | ast::ExprKind::Table(..)
            | ast::ExprKind::Int32(..)
            | ast::ExprKind::Int64(..)
            | ast::ExprKind::Float32(..)
            | ast::ExprKind::Float64(..)
            | ast::ExprKind::Bool(..)
            | ast::ExprKind::Str(..)
            | ast::ExprKind::Nil(..) => false,
        }
    }
}

fn eval_expr_infix<'a>(
    m: &mut State<'a>,
    node: Node<'a, ast::Infix>,
    span: Span,
    dst: Option<Reg>,
) -> Result<Value<'a>> {
    let op = *node.op();

    if op.is_logical() {
        return eval_expr_infix_logical(m, node, span, dst);
    }

    if op.is_comparison() {
        return eval_expr_infix_comparison(m, node, span, dst);
    }

    let dst = maybe_reuse_reg(m, span, dst)?;

    let lhs = eval_expr_reuse(m, node.lhs(), node.lhs_span(), dst)?;
    let (lhs, rhs) = if lhs.is_const() {
        let rhs = eval_expr(m, node.rhs(), node.rhs_span())?;
        if rhs.is_const() {
            return const_eval_expr_infix_arith(op, lhs, rhs, span);
        }

        let lhs = value_to_operand_reuse(m, lhs, dst)?;
        let rhs = value_to_operand(m, rhs)?;

        (lhs, rhs)
    } else {
        let lhs = value_to_operand_reuse(m, lhs, dst)?;

        let rhs = eval_expr(m, node.rhs(), node.rhs_span())?;
        let rhs = value_to_operand(m, rhs)?;

        (lhs, rhs)
    };

    runtime_eval_expr_infix_arith(m, op, dst, lhs, rhs, span);

    free_operand(m, rhs);
    if !lhs.is_in(dst) {
        free_operand(m, lhs);
    }

    Ok(Value::dynamic(dst, span))
}

fn runtime_eval_expr_infix_arith<'a>(
    m: &mut State<'a>,
    op: ast::InfixOp,
    dst: Reg,
    lhs: Operand,
    rhs: Operand,
    span: Span,
) {
    use Operand as O;
    let insn = match op {
        ast::InfixOp::Add => match (lhs, rhs) {
            (O::Reg(lhs), O::Reg(rhs)) => asm::addvv(dst, lhs, rhs),
            (O::Reg(lhs), O::Const(rhs)) => asm::addvn(dst, lhs, rhs),
            (O::Const(lhs), O::Reg(rhs)) => asm::addnv(dst, lhs, rhs),
            _ => unreachable!("ICE: const/const in non-const path"),
        },
        ast::InfixOp::Sub => match (lhs, rhs) {
            (O::Reg(lhs), O::Reg(rhs)) => asm::subvv(dst, lhs, rhs),
            (O::Reg(lhs), O::Const(rhs)) => asm::subvn(dst, lhs, rhs),
            (O::Const(lhs), O::Reg(rhs)) => asm::subnv(dst, lhs, rhs),
            _ => unreachable!("ICE: const/const in non-const path"),
        },
        ast::InfixOp::Mul => match (lhs, rhs) {
            (O::Reg(lhs), O::Reg(rhs)) => asm::mulvv(dst, lhs, rhs),
            (O::Reg(lhs), O::Const(rhs)) => asm::mulvn(dst, lhs, rhs),
            (O::Const(lhs), O::Reg(rhs)) => asm::mulnv(dst, lhs, rhs),
            _ => unreachable!("ICE: const/const in non-const path"),
        },
        ast::InfixOp::Div => match (lhs, rhs) {
            (O::Reg(lhs), O::Reg(rhs)) => asm::divvv(dst, lhs, rhs),
            (O::Reg(lhs), O::Const(rhs)) => asm::divvn(dst, lhs, rhs),
            (O::Const(lhs), O::Reg(rhs)) => asm::divnv(dst, lhs, rhs),
            _ => unreachable!("ICE: const/const in non-const path"),
        },
        ast::InfixOp::Rem => match (lhs, rhs) {
            (O::Reg(lhs), O::Reg(rhs)) => asm::remvv(dst, lhs, rhs),
            (O::Reg(lhs), O::Const(rhs)) => asm::remvn(dst, lhs, rhs),
            (O::Const(lhs), O::Reg(rhs)) => asm::remnv(dst, lhs, rhs),
            _ => unreachable!("ICE: const/const in non-const path"),
        },
        op => unreachable!("ICE: invalid op in infix: {op:?}"),
    };

    m.emit(insn, span);
}

fn const_eval_expr_infix_arith<'a>(
    op: ast::InfixOp,
    lhs: Value<'a>,
    rhs: Value<'a>,
    span: Span,
) -> Result<Value<'a>> {
    // both sides are constants, return a constant.
    use ast::InfixOp as Op;
    let (iop, fop, desc): (
        fn(i64, i64) -> Result<i64, &'static str>,
        fn(f64n, f64n) -> f64n,
        &'static str,
    ) = match op {
        Op::Add => (|a, b| Ok(a + b), |a, b| a + b, "+"),
        Op::Sub => (|a, b| Ok(a - b), |a, b| a - b, "-"),
        Op::Mul => (|a, b| Ok(a * b), |a, b| a * b, "*"),
        Op::Div => (
            |a: i64, b: i64| {
                if b == 0 {
                    Err("evaluation would fail: cannot divide by zero")
                } else {
                    Ok(a / b)
                }
            },
            |a, b| a / b,
            "/",
        ),
        Op::Rem => (
            |a: i64, b: i64| {
                if b == 0 {
                    Err("evaluation would fail: cannot divide by zero")
                } else {
                    Ok(a % b)
                }
            },
            |a, b| a % b,
            "%",
        ),
        op => unreachable!("ICE: invalid op in infix: {op:?}"),
    };

    use ValueKind as V;
    let v = match (lhs.kind, rhs.kind) {
        (V::Int(lhs), V::Int(rhs)) => {
            Value::int(iop(lhs, rhs).map_err(|err| error_span(err, span))?, span)
        }
        (V::Float(lhs), V::Float(rhs)) => Value::float(fop(lhs, rhs), span),
        (V::Float(lhs), V::Int(rhs)) => Value::float(fop(lhs, f64n::new(rhs as f64)), span),
        (V::Int(lhs), V::Float(rhs)) => Value::float(fop(f64n::new(lhs as f64), rhs), span),
        _ => {
            return error_span(
                format!(
                    "evaluation would fail with a type mismatch: {} {} {}",
                    lhs.type_name(),
                    desc,
                    rhs.type_name()
                ),
                span,
            )
            .into();
        }
    };
    Ok(v)
}

fn eval_expr_infix_logical<'a>(
    m: &mut State<'a>,
    node: Node<'a, ast::Infix>,
    span: Span,
    dst: Option<Reg>,
) -> Result<Value<'a>> {
    let dst = maybe_reuse_reg(m, span, dst)?;

    // TODO(opt): const eval
    let lhs = eval_expr_reuse(m, node.lhs(), node.lhs_span(), dst)?;
    value_force_reg(m, lhs, dst)?;

    use ast::InfixOp as Op;
    match *node.op() {
        Op::And => {
            let mut exit = ForwardLabel::new(m.buf);

            /*
            dst = lhs
            if dst:
                dst = rhs
            */

            m.emit(asm::istrue(dst), node.lhs_span());
            emit_forward_jmp(m, span, &mut exit);

            // NOTE: if `lhs` is true, then the value is discarded,
            // so the `dst` register can be reused.
            let rhs = eval_expr_reuse(m, node.rhs(), node.rhs_span(), dst)?;
            value_force_reg(m, rhs, dst)?;

            exit.bind(f!(m))?;

            if !rhs.is_in(dst) {
                free_value(m, rhs);
            }
        }
        Op::Or => {
            let mut exit = ForwardLabel::new(m.buf);

            /*
            dst = lhs
            if not dst:
                dst = rhs
            */

            m.emit(asm::isfalse(dst), node.lhs_span());
            emit_forward_jmp(m, span, &mut exit);

            // NOTE: if `lhs` is false, then the value is discarded,
            // so the `dst` register can be reused.
            let rhs = eval_expr_reuse(m, node.rhs(), node.rhs_span(), dst)?;
            value_force_reg(m, rhs, dst)?;

            exit.bind(f!(m))?;

            if !rhs.is_in(dst) {
                free_value(m, rhs);
            }
        }
        op => unreachable!("ICE: invalid op in infix logical: {op:?}"),
    }

    if !lhs.is_in(dst) {
        free_value(m, lhs);
    }

    Ok(Value::dynamic(dst, span))
}

fn eval_expr_infix_comparison<'a>(
    m: &mut State<'a>,
    node: Node<'a, ast::Infix>,
    span: Span,
    dst: Option<Reg>,
) -> Result<Value<'a>> {
    let op = *node.op();

    let dst = maybe_reuse_reg(m, span, dst)?;

    let lhs = eval_expr_reuse(m, node.lhs(), node.lhs_span(), dst)?;
    let (lhs, rhs) = if lhs.is_const() {
        let rhs = eval_expr(m, node.rhs(), node.rhs_span())?;
        if rhs.is_const() {
            return const_eval_expr_infix_comparison(op, lhs, rhs, span);
        }

        let lhs = value_to_reg_reuse(m, lhs, dst)?;
        let rhs = value_to_reg(m, rhs)?;

        (lhs, rhs)
    } else {
        let lhs = value_to_reg_reuse(m, lhs, dst)?;

        let rhs = eval_expr(m, node.rhs(), node.rhs_span())?;
        let rhs = value_to_reg(m, rhs)?;

        (lhs, rhs)
    };

    runtime_eval_expr_infix_comparison(m, op, dst, lhs, rhs, span);

    free_reg(m, rhs);
    if lhs != dst {
        free_reg(m, lhs);
    }

    Ok(Value::dynamic(dst, span))
}

fn runtime_eval_expr_infix_comparison<'a>(
    m: &mut State<'a>,
    op: ast::InfixOp,
    dst: Reg,
    lhs: Reg,
    rhs: Reg,
    span: Span,
) {
    use ast::InfixOp as Op;
    let insn = match op {
        Op::Eq => asm::iseqv(dst, lhs, rhs),
        Op::Ne => asm::isnev(dst, lhs, rhs),
        Op::Lt => asm::isltv(dst, lhs, rhs),
        Op::Le => asm::islev(dst, lhs, rhs),
        Op::Gt => asm::isgtv(dst, lhs, rhs),
        Op::Ge => asm::isgev(dst, lhs, rhs),
        op => unreachable!("ICE: invalid op in infix comparison: {op:?}"),
    };

    m.emit(insn, span);
}
fn const_eval_expr_infix_comparison<'a>(
    op: ast::InfixOp,
    lhs: Value<'a>,
    rhs: Value<'a>,
    span: Span,
) -> Result<Value<'a>> {
    // both sides are constants, return a constant.
    use ast::InfixOp as Op;

    macro_rules! op {
        ($tt:tt) => {(
            |a, b| a $tt b,
            |a, b| a $tt b,
            |a, b| a $tt b,
            |a, b| a $tt b,
            |a, b| a $tt b,
        )};
    }

    let (nil_op, int_op, flt_op, bool_op, str_op): (
        fn((), ()) -> bool,
        fn(i64, i64) -> bool,
        fn(f64n, f64n) -> bool,
        fn(bool, bool) -> bool,
        fn(&str, &str) -> bool,
    ) = match op {
        Op::Eq => op!(==),
        Op::Ne => op!(!=),
        Op::Lt => op!(<),
        Op::Le => op!(<=),
        Op::Gt => op!(>),
        Op::Ge => op!(>=),
        op => unreachable!("ICE: invalid op in comparison: {op:?}"),
    };

    use ValueKind as V;
    let v = match (lhs.kind, rhs.kind) {
        (V::Nil, V::Nil) => Value::bool(nil_op((), ()), span),
        (V::Bool(lhs), V::Bool(rhs)) => Value::bool(bool_op(lhs, rhs), span),
        (V::Int(lhs), V::Int(rhs)) => Value::bool(int_op(lhs, rhs), span),
        (V::Float(lhs), V::Float(rhs)) => Value::bool(flt_op(lhs, rhs), span),
        (V::Float(lhs), V::Int(rhs)) => Value::bool(flt_op(lhs, f64n::new(rhs as f64)), span),
        (V::Int(lhs), V::Float(rhs)) => Value::bool(flt_op(f64n::new(lhs as f64), rhs), span),
        (V::Str(lhs), V::Str(rhs)) => Value::bool(str_op(lhs, rhs), span),
        _ => {
            return error_span(
                format!(
                    "evaluation would fail with a type mismatch: cannot compare {} and {}",
                    lhs.type_name(),
                    rhs.type_name()
                ),
                span,
            )
            .into();
        }
    };

    Ok(v)
}

fn eval_expr_prefix<'a>(
    m: &mut State<'a>,
    node: Node<'a, ast::Prefix>,
    span: Span,
    dst: Option<Reg>,
) -> Result<Value<'a>> {
    let dst = maybe_reuse_reg(m, span, dst)?;
    let rhs = eval_expr_reuse(m, node.rhs(), node.rhs_span(), dst)?;

    let result = if rhs.is_const() {
        const_eval_expr_prefix(*node.op(), rhs, span)?
    } else {
        let rhs = value_to_reg_reuse(m, rhs, dst)?;

        let insn = match *node.op() {
            ast::PrefixOp::Minus => asm::unm(dst, rhs),

            ast::PrefixOp::Not => asm::not(dst, rhs),
        };

        m.emit(insn, span);

        if rhs != dst {
            free_reg(m, rhs);
        }

        Value::dynamic(dst, span)
    };

    Ok(result)
}

fn const_eval_expr_prefix<'a>(op: ast::PrefixOp, rhs: Value<'a>, span: Span) -> Result<Value<'a>> {
    use ValueKind as V;
    use ast::PrefixOp as Op;

    assert!(rhs.is_const());

    let result = match op {
        Op::Minus => match rhs.kind {
            V::Nil => {
                return error_span(
                    format!("evaluation would fail with a type error: cannot invert nil"),
                    span,
                )
                .into();
            }
            V::Bool(_) => {
                return error_span(
                    format!("evaluation would fail with a type error: cannot invert bool"),
                    span,
                )
                .into();
            }
            V::Int(v) => Value::int(-v, span),
            V::Float(v) => Value::float(f64n::new(-v.get()), span),
            V::Str(_) => {
                return error_span(
                    format!("evaluation would fail with a type error: cannot invert str"),
                    span,
                )
                .into();
            }
            V::Dynamic(reg) => unreachable!("ICE: const eval on a register"),
        },
        Op::Not => Value::bool(!rhs.coerce_bool(), span),
    };

    Ok(result)
}

fn eval_expr_list<'a>(
    m: &mut State<'a>,
    node: Node<'a, ast::List>,
    span: Span,
    dst: Option<Reg>,
) -> Result<Value<'a>> {
    // TODO(opt): constant array

    let dst = maybe_reuse_reg(m, span, dst)?;

    let cap = node.items().len().min(u16::MAX as usize) as u16;
    let cap = unsafe { Imm16::new_unchecked(cap) };
    m.emit(asm::llist(dst, cap), span);

    for (idx, (item, &span)) in node
        .items()
        .into_iter()
        .zip(node.items_spans().iter())
        .enumerate()
    {
        let value = eval_expr(m, item, span)?;
        let value = value_to_reg(m, value)?;

        let idx = value_to_operand(m, Value::int(idx as i64, span))?;
        match idx {
            Operand::Reg(idx) => m.emit(asm::sidx(dst, idx, value), span),
            Operand::Const(idx) => m.emit(asm::sidxn(dst, idx, value), span),
        };

        free_operand(m, idx);
        free_reg(m, value);
    }

    Ok(Value::dynamic(dst, span))
}

fn eval_expr_table<'a>(
    m: &mut State<'a>,
    node: Node<'a, ast::Table>,
    span: Span,
    dst: Option<Reg>,
) -> Result<Value<'a>> {
    // TODO(opt): constant object

    let dst = maybe_reuse_reg(m, span, dst)?;

    let cap = node.entries().len().min(u16::MAX as usize) as u16;
    let cap = unsafe { Imm16::new_unchecked(cap) };
    m.emit(asm::ltable(dst, cap), span);

    for (entry, &span) in node.entries().into_iter().zip(node.entries_spans().iter()) {
        let key = entry.key().get();

        let value = eval_expr(m, entry.value(), entry.value_span())?;
        let value = value_to_reg(m, value)?;

        let key = value_to_operand(m, Value::str(key, entry.key_span()))?;
        match key {
            Operand::Reg(key) => m.emit(asm::skey(dst, key, value), span),
            Operand::Const(key) => m.emit(asm::skeyc(dst, key, value), span),
        };

        free_operand(m, key);
        free_reg(m, value);
    }

    Ok(Value::dynamic(dst, span))
}

enum IntExpr<'a> {
    I32(Node<'a, ast::Int32>),
    I64(Node<'a, ast::Int64>),
}

impl<'a> IntExpr<'a> {
    fn value(&self) -> i64 {
        match self {
            IntExpr::I32(node) => (*node.value()) as i64,
            IntExpr::I64(node) => *node.get(),
        }
    }
}

fn eval_expr_int<'a>(m: &mut State<'a>, int: IntExpr<'a>, span: Span) -> Value<'a> {
    Value::int(int.value(), span)
}

enum FloatExpr<'a> {
    F32(Node<'a, ast::Float32>),
    F64(Node<'a, ast::Float64>),
}

impl<'a> FloatExpr<'a> {
    fn value(&self) -> f64n {
        match self {
            FloatExpr::F32(node) => f64n::new(*node.value() as f64),
            FloatExpr::F64(node) => *node.get(),
        }
    }
}

fn eval_expr_float<'a>(m: &mut State<'a>, float: FloatExpr<'a>, span: Span) -> Value<'a> {
    Value::float(float.value(), span)
}

fn eval_expr_bool<'a>(m: &mut State, bool: Node<'a, ast::Bool>, span: Span) -> Value<'a> {
    Value::bool(*bool.value(), span)
}

fn eval_expr_str<'a>(m: &mut State<'a>, str: Node<'a, ast::Str>, span: Span) -> Value<'a> {
    Value::str(str.get(), span)
}

fn eval_expr_nil<'a>(m: &mut State<'a>, nil: Node<'a, ast::Nil>, span: Span) -> Value<'a> {
    Value::nil(span)
}

#[derive(Debug, Clone, Copy)]
enum Operand {
    /// The value exists in this register.
    Reg(Reg),

    /// The value exists only in the literal pool.
    Const(Lit8),
}

impl Operand {
    fn is_in(self, reg: Reg) -> bool {
        matches!(self, Operand::Reg(r) if r == reg)
    }
}

impl PartialEq<Reg> for Reg {
    fn eq(&self, other: &Reg) -> bool {
        self.get() == other.get()
    }
}

impl Eq for Reg {}

fn nil_to_operand<'a>(m: &mut State<'a>, span: Span, dst: Option<Reg>) -> Result<Operand> {
    // `nil` is never stored in the literal pool, because it is a singleton,
    // so always emit into a register.
    nil_to_reg(m, span, dst).map(Operand::Reg)
}

fn nil_to_reg<'a>(m: &mut State<'a>, span: Span, dst: Option<Reg>) -> Result<Reg> {
    let dst = maybe_reuse_reg(m, span, dst)?;
    m.emit(asm::lnil(dst), span);
    Ok(dst)
}

fn bool_to_operand<'a>(
    m: &mut State<'a>,
    value: bool,
    span: Span,
    dst: Option<Reg>,
) -> Result<Operand> {
    bool_to_reg(m, value, span, dst).map(Operand::Reg)
}

fn bool_to_reg<'a>(m: &mut State<'a>, value: bool, span: Span, dst: Option<Reg>) -> Result<Reg> {
    let dst = maybe_reuse_reg(m, span, dst)?;
    match value {
        true => m.emit(asm::ltrue(dst), span),
        false => m.emit(asm::lfalse(dst), span),
    };
    Ok(dst)
}

fn int_to_operand<'a>(
    m: &mut State<'a>,
    value: i64,
    span: Span,
    dst: Option<Reg>,
) -> Result<Operand> {
    if f!(m).literals.is_next_id_8bit() {
        // emit it as a literal, use it as operand
        let id = f!(m).literals.i64(value, span)?;
        Ok(Operand::Const(unsafe {
            Lit8::new_unchecked(id.get() as u8)
        }))
    } else {
        int_to_reg(m, value, span, dst).map(Operand::Reg)
    }
}

fn int_to_reg<'a>(m: &mut State<'a>, value: i64, span: Span, dst: Option<Reg>) -> Result<Reg> {
    let dst = maybe_reuse_reg(m, span, dst)?;
    // emit it as a load, use the register
    if value <= i16::MAX as i64 {
        let v = unsafe { Imm16s::new_unchecked(value as i16) };
        m.emit(asm::lsmi(dst, v), span);
    } else {
        let id = f!(m).literals.i64(value, span)?;
        m.emit(asm::lint(dst, id), span);
    }
    Ok(dst)
}

fn float_to_operand<'a>(
    m: &mut State<'a>,
    value: f64n,
    span: Span,
    dst: Option<Reg>,
) -> Result<Operand> {
    if f!(m).literals.is_next_id_8bit() {
        // emit it as a literal, use it as operand
        let id = f!(m).literals.f64(value, span)?;
        Ok(Operand::Const(unsafe {
            Lit8::new_unchecked(id.get() as u8)
        }))
    } else {
        float_to_reg(m, value, span, dst).map(Operand::Reg)
    }
}

fn float_to_reg<'a>(m: &mut State<'a>, value: f64n, span: Span, dst: Option<Reg>) -> Result<Reg> {
    let dst = maybe_reuse_reg(m, span, dst)?;
    let id = f!(m).literals.f64(value, span)?;
    m.emit(asm::lnum(dst, id), span);
    Ok(dst)
}

fn str_to_operand<'a>(
    m: &mut State<'a>,
    value: &'a str,
    span: Span,
    dst: Option<Reg>,
) -> Result<Operand> {
    if f!(m).literals.is_next_id_8bit() {
        let id = f!(m).literals.str(value, span)?;
        Ok(Operand::Const(unsafe {
            Lit8::new_unchecked(id.get() as u8)
        }))
    } else {
        str_to_reg(m, value, span, dst).map(Operand::Reg)
    }
}

fn str_to_reg<'a>(m: &mut State<'a>, value: &'a str, span: Span, dst: Option<Reg>) -> Result<Reg> {
    let dst = maybe_reuse_reg(m, span, dst)?;
    let id = f!(m).literals.str(value, span)?;
    m.emit(asm::lstr(dst, id), span);
    Ok(dst)
}

fn value_to_operand_maybe_reuse<'a>(
    m: &mut State<'a>,
    value: Value<'a>,
    dst: Option<Reg>,
) -> Result<Operand> {
    match value.kind {
        // already materialized
        ValueKind::Dynamic(reg) => Ok(Operand::Reg(reg)),

        ValueKind::Nil => nil_to_operand(m, value.span, dst),
        ValueKind::Bool(inner) => bool_to_operand(m, inner, value.span, dst),
        ValueKind::Int(inner) => int_to_operand(m, inner, value.span, dst),
        ValueKind::Float(inner) => float_to_operand(m, inner, value.span, dst),
        ValueKind::Str(inner) => str_to_operand(m, inner, value.span, dst),
    }
}

/// Materialize `value` into a register or literal for use in emit.
fn value_to_operand<'a>(m: &mut State<'a>, value: Value<'a>) -> Result<Operand> {
    value_to_operand_maybe_reuse(m, value, None)
}

/// Materialize `value` into a register or literal for use in emit, emitting into `dst` if possible.
fn value_to_operand_reuse<'a>(m: &mut State<'a>, value: Value<'a>, dst: Reg) -> Result<Operand> {
    value_to_operand_maybe_reuse(m, value, Some(dst))
}

fn value_to_reg_maybe_reuse<'a>(
    m: &mut State<'a>,
    value: Value<'a>,
    dst: Option<Reg>,
) -> Result<Reg> {
    match value.kind {
        // already materialized
        ValueKind::Dynamic(reg) => Ok(reg),

        ValueKind::Nil => nil_to_reg(m, value.span, dst),
        ValueKind::Bool(inner) => bool_to_reg(m, inner, value.span, dst),
        ValueKind::Int(inner) => int_to_reg(m, inner, value.span, dst),
        ValueKind::Float(inner) => float_to_reg(m, inner, value.span, dst),
        ValueKind::Str(inner) => str_to_reg(m, inner, value.span, dst),
    }
}

/// Materialize `value` into a register for use in emit.
fn value_to_reg<'a>(m: &mut State<'a>, value: Value<'a>) -> Result<Reg> {
    value_to_reg_maybe_reuse(m, value, None)
}

/// Materialize `value` into a register for use in emit, emitting into `dst` if possible.
fn value_to_reg_reuse<'a>(m: &mut State<'a>, value: Value<'a>, dst: Reg) -> Result<Reg> {
    value_to_reg_maybe_reuse(m, value, Some(dst))
}

/// Materialize `value` into `dst`.
///
/// This function guarantees the value will be present in `dst` instead of
/// some other register.
fn value_force_reg<'a>(m: &mut State<'a>, value: Value<'a>, dst: Reg) -> Result<()> {
    let src = value_to_reg_reuse(m, value, dst)?;
    if src != dst {
        m.emit(asm::mov(dst, src), value.span);
    }
    Ok(())
}

fn emit_forward_jmp<'a>(m: &mut State<'a>, span: Span, label: &mut ForwardLabel<'a>) {
    const PLACEHOLDER: Imm24s = unsafe { Imm24s::new_unchecked(i24::ZERO) };
    if let Some(pos) = m.emit(asm::jmp(PLACEHOLDER), span) {
        label.add_target(m, pos);
    }
}

fn is_basic_block_exit(prev: Insn, insn: Insn) -> bool {
    match insn.op() {
        Opcode::Jmp if is_jump_condition(prev) => false,
        Opcode::Jmp => true,

        Opcode::Ret | Opcode::Retv | Opcode::Stop => true,

        Opcode::Nop
        | Opcode::Mov
        | Opcode::Lmvar
        | Opcode::Smvar
        | Opcode::Luv
        | Opcode::Suv
        | Opcode::Lidx
        | Opcode::Lidxn
        | Opcode::Sidx
        | Opcode::Sidxn
        | Opcode::Lkey
        | Opcode::Lkeyc
        | Opcode::Skey
        | Opcode::Skeyc
        | Opcode::Lnil
        | Opcode::Lsmi
        | Opcode::Ltrue
        | Opcode::Lfalse
        | Opcode::Lint
        | Opcode::Lnum
        | Opcode::Lstr
        | Opcode::Lclosure
        | Opcode::Lfunc
        | Opcode::Lhost
        | Opcode::Llist
        | Opcode::Ltable
        | Opcode::Istrue
        | Opcode::Isfalse
        | Opcode::Islt
        | Opcode::Isle
        | Opcode::Isgt
        | Opcode::Isge
        | Opcode::Iseq
        | Opcode::Isne
        | Opcode::Iseqs
        | Opcode::Isnes
        | Opcode::Iseqi
        | Opcode::Isnei
        | Opcode::Iseqf
        | Opcode::Isnef
        | Opcode::Isnil
        | Opcode::Isnotnil
        | Opcode::Isltv
        | Opcode::Islev
        | Opcode::Isgtv
        | Opcode::Isgev
        | Opcode::Iseqv
        | Opcode::Isnev
        | Opcode::Addvv
        | Opcode::Addvn
        | Opcode::Addnv
        | Opcode::Subvv
        | Opcode::Subvn
        | Opcode::Subnv
        | Opcode::Mulvv
        | Opcode::Mulvn
        | Opcode::Mulnv
        | Opcode::Divvv
        | Opcode::Divvn
        | Opcode::Divnv
        | Opcode::Remvv
        | Opcode::Remvn
        | Opcode::Remnv
        | Opcode::Unm
        | Opcode::Not
        | Opcode::Call
        | Opcode::Fastcall
        | Opcode::Hostcall
        | Opcode::Import => false,
    }
}

fn is_jump_condition(insn: Insn) -> bool {
    match insn.op() {
        Opcode::Istrue
        | Opcode::Isfalse
        | Opcode::Islt
        | Opcode::Isle
        | Opcode::Isgt
        | Opcode::Isge
        | Opcode::Iseq
        | Opcode::Isne
        | Opcode::Iseqs
        | Opcode::Isnes
        | Opcode::Iseqi
        | Opcode::Isnei
        | Opcode::Iseqf
        | Opcode::Isnef
        | Opcode::Isnil
        | Opcode::Isnotnil => true,

        Opcode::Nop
        | Opcode::Mov
        | Opcode::Lmvar
        | Opcode::Smvar
        | Opcode::Luv
        | Opcode::Suv
        | Opcode::Lidx
        | Opcode::Lidxn
        | Opcode::Sidx
        | Opcode::Sidxn
        | Opcode::Lkey
        | Opcode::Lkeyc
        | Opcode::Skey
        | Opcode::Skeyc
        | Opcode::Lnil
        | Opcode::Lsmi
        | Opcode::Ltrue
        | Opcode::Lfalse
        | Opcode::Lint
        | Opcode::Lnum
        | Opcode::Lstr
        | Opcode::Lclosure
        | Opcode::Lfunc
        | Opcode::Lhost
        | Opcode::Llist
        | Opcode::Ltable
        | Opcode::Jmp
        | Opcode::Isltv
        | Opcode::Islev
        | Opcode::Isgtv
        | Opcode::Isgev
        | Opcode::Iseqv
        | Opcode::Isnev
        | Opcode::Addvv
        | Opcode::Addvn
        | Opcode::Addnv
        | Opcode::Subvv
        | Opcode::Subvn
        | Opcode::Subnv
        | Opcode::Mulvv
        | Opcode::Mulvn
        | Opcode::Mulnv
        | Opcode::Divvv
        | Opcode::Divvn
        | Opcode::Divnv
        | Opcode::Remvv
        | Opcode::Remvn
        | Opcode::Remnv
        | Opcode::Unm
        | Opcode::Not
        | Opcode::Call
        | Opcode::Fastcall
        | Opcode::Hostcall
        | Opcode::Ret
        | Opcode::Retv
        | Opcode::Stop
        | Opcode::Import => false,
    }
}

fn peephole(prev_insn: Insn, insn: Insn) -> Option<Insn> {
    use Opcode as Op;

    match (prev_insn.op(), insn.op()) {
        (Op::Ret, Op::Ret) => Some(prev_insn),
        _ => None,
    }
}

#[cfg(test)]
mod tests;
